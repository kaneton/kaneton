--
 bon en fait malloc a tjs des problemes.......

--
 bon, en decembre on doit avoir

 - tout les managers codés clean		-> cf todo plus bas
 - les tests pour tout ce qui a été codé	-> idem
 - kaneton book a jour				-> mettre a jour les proto
						-> ajouter cpu et io
 - ia32-virtual book ecrit			-> cf todo
 - la moulette					-> idem
 - l'intra					-> quasi ok

 il doit rester comme managers a faire :

 - message
 - capability (a priori Julien l'a bien entamé)
 - io (juste le revoir en fait, cf remarque plus bas)
 - share ?
 - (pas urgent) cpu

--
 liste des endroits vraiment ok :

 * ia32-virtual's bootloader
 * id
 * set, set_ll, set_bpt, set_pipe, set_stack
 * ia32-virtual segment
 * ia32-virtual timer
 * as

 c'est maigre... mais ca devrait vite se remplir ! cf la todo plus bas

 aussi: deplacer kaneton/core/debug/* dans les machdep

--
 bien qu'on a pas encore les IPC, faudrait reflechir a l'interface
 pour les drivers assez vite.

--
 stats manager: utiliser l'instruction qui compte les cycles plutot
 qu'un timer ?

   + hyper precis
   - pas dispo partout

 en fait, le stat manager deconne trop maintenant qu'il y a le
 scheduling. il faut augmenter vachement la latence du kernel pour
 pouvoir s'en servir (dans timer.h: TIMER_MS_PER_TICK et dans sched.h:
 SCHED_QUANTUM_INIT).

--
 faudrait implementer des regions copy-on-write pour gagner en
 performance. qui plus est, il faut de toute facon pouvoir préciser si
 un segment doit etre cloné en cas d'as_clone. par exemple, on a pas
 envie de dupliquer la GDT, l'IDT, la kstack etc... qui sont mappés
 dans chaque as.

--
 peut etre que le I/O manager est mal pensé. Sur SUN par exemple, les
 I/O se font avec des load/store en mémoire. Pour gerer les permissions
 c'est chaud (utiliser le paging ne changerais rien car pas
 fragmentable).

 peut etre on devrait faire en plus une interface du genre :

 io_read_8, 16, 32, 64
 io_write_8, 16, 32, 64

 sur IA-32, on ne serait pas obligé de les utiliser (on utilise direct
 les instructions in/out).

 sur une archi qui fonction comme SUN, alors on utiliserais du coup un
 set pour gerer les permissions, et c'est le kernel qui ferait les
 acces memoire qu'il faut lors des io_read/io_write

--
 ameliorer la moulette:
  - gerer les exceptions
	--> OK, 1 warning a corriger
  - ajouter des descriptions aux tests
	--> on pourrait utiliser le test "common" pour afficher les
	    descriptions dans la trace
  - refaire les output des tests des sets, jugés "non explicites" par certains
  - verifier les tests bizarres (segment_r/w par exemple :-)

--
 bon, on va se fixer des deadline comme ça au moins ca avancera:
 (sinon panpan cucu)

 next => 15 octobre
 todo: as_clone X, region_resize X, ia32_region_reserve X, sched_update, as/03 X

 next => 30 octobre
 todo: task_wait, task_clone, task/*

 next => 15 novembre
 todo: context switch FPU/SSE X, thread_*

 next => 30 novembre
 todo: time/*, event/*

 fil rouge:
  * retravailler encore un peu la moulinette (cf todo plus haut)
  * ecrire ia32 book

 choses à reflechir:
  ia32_as_reserve, *_split *_coalesce *_resize, segment_perms, ia32_sched_yield

 CHOSES A FAIRE PAR MANAGER:

 * as
  - ia32_as_reserve: ne mapper que certaines sections du ELF
  - ia32_as_reserve: ajuster les flags G des pte du kas
 * map
  - map_resize: a revoir en fct des modifications de region/segment
 * region
  - region_split: a modifier - 2 regions / 1 segment
 * sched
  - sched_update: optimiser car ca pue
  - ia32_sched_yield
 * segment
  - segment_resize: segment OK (bug pour le 1er/dernier seg), regions TODO
  - segment_split: segment OK, regions TODO
  - segment_coalesce: segment OK, regions TODO
  - segment_perms: gestion des regions
 * set
  - set_array_locate : dicho desactivée
 * task
  - wait et clone a finir
 * thread
  - thread_clone: quand on clone un thread, il faut peut etre changer le
    cr3 plutot que le recopier.
  - thread_give: copier la pile dans le nouvel AS ?
  - gestion des wait

 * tests
   + time/01, time/02, time/03
   + task/01, task/02, task/03, task/04, task/05, task/06
   + event/*

--
 ecrire les parties correspondantes dans le book kaneton a propos d'io
 et cpu s'assurer que l'interface de collera bien.

--
 probleme du malloc:  a priori c'est ok. mais  l'idéal serait en effet
 de faire un set special qui ne poserait pas ce problème.

--
 + moulinette triche
 + norme dans books/kaneton

--
 enlever QUICKSTART et expliquer ce qu'il faut sur le site

--
 verifier que dans chaque manager il y a:

   machdep_include()
   tous les machdep_call()

   la variable globale correspondante au manager

--
 au lancement du core, celui-ci genere un nombre sur 64-bit.

 ce nombre va devenir son machine-id.

 de plus son node-id va etre calcule de la maniere suivante:

   node-id = hash(machine-id + 0)

 ou '+' designe la concatenation de donnees.

 plus tard, chaque tache pourra simplement calcule son node-id avec:

   node-id = hash(machine-id + task-id)

 ainsi chaque tache du systeme reparti aura un node-id unique et de plus
 les cores a leurs lancements auront un id, ce qui est requis pour la
 generation des capabilities.

--
 finalement on va surement avoir besoin de mapper les modules pour que
 le core puisse extraire le premier module et le lancer.

--
 tous les profiles machines sauf linux et linux.mips sont foireux

 il faudra les mettre a jour enfin les refaire plutot

--
 virer les CFLAGS = ___kernel c'est trop laid/specifique

--
 revoir la doc: apparamment les etudiants ne comprennent pas instinctivement
 qu il y a trois parties bien distinctes: core, machdep, libarch

--
 pour resoudre les forward declarations, normalement faire comme set.h
 et ca marche, cad forward declarer tous les types d'un .h AVANT de
 faire les includes recursifs.

--
 ce serait interessant de rajouter un ensemble 'slab' qui ne se baserait
 pas sur malloc.

 ca montrerait la possibilite du set manager et en plus on pourrait faire
 des tests de perf avec le slab.

--
 probleme de nomenclature: chiche_get(o* o) ca marche pour recuperer un
 objet mais quand ce seront des programs userland, recuperer l objet
 entier ca ne les interesse pas, c'est lourd et c est pas le but.

 donc on devrait changer pour mettre a disposition des fonctions pour
 recuperer que certaines proprietes.

--
 revoir le bootloader:

  t_modules
  {
    + t_module* modules;
  }
  t_module
  {
    + void* content;
    + t_module* next;
  }

--
 les images microkernel_examples_* dans seminar sont a passer au format xfig

--
 il faut prevoir que tout le demarrage des services via fichier de conf
 doit pouvoir etre fait en dynamique. par exemple si mod reserve un
 segment special (CATCH) pour le service tty (console) et bien il faut
 imaginer que si on lance ce meme serveur a la main une fois le systeme
 boote, soit le systeme de lui meme (via un fichier de conf) sait quels
 sont les objets dont il herite ou alors il faut prevoir des messages style
 segment_acquire() pour acquerir un segment specifique: la memoire video.

--
 nettoyer conf.h, debug.h, check.h rendre tout ca coherent car la c'est
 un peu le bordel.

 faire que tout ce qui touche a conf soit genere et qu il n y ait plus
 conf.c et conf.h

--
 hevea -exec xxdate.exe kaneton.tex pour generer du html

 latex -> html: HeVeA

 ca aurait ete bien un make web mais bon c'est mort.

--
 trouver un moyen de gerer un systeme d'evenements intra kernel. soit
 comme unix soit on fait differemment. sleep/wakeup

 en fait le systeme des pthreads est vraiment pas mal avec les condition
 variables ayant un mutex associe.

--
 segment:

 il faudra rajouter dans le bootloader init.c un segment correspondant
 au dma: SEGMENT_TYPE_CATCH

 on pourrait imaginer dans le fichier de conf dire que telle zone
 est en mode catch et qu elle est catchable que par telle tache (avec
 tel nom par exemple)

 en fait revoir le concept de catch car c'est quand meme pas clair encore.

-- norme commit
  [core/kaneton/set/set_bpt.c]
    1) init function updated to properly handle set options.
    2) ...

  [core/kaneton/kaneton.c]
    1) ...

  -> les points 1,2,3 etc.. sont pas ordre d'importance
