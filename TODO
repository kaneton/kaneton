#
# ---------- buck -------------------------------------------------------------
#

 cswitch: no io bitmap copy when class < 1
 et puis meme ca s'optimise encore : faire un set de i_port a granter,
c'est tjs mieux que 8192 bytes a memcpy.

--

 un truc qui me parait bizarre dans le bootloader: la stack courant
elle est pas mappee explicitement !

--

autre:
 - map_resize, {region,segment}_{split,resize,coalesce}
 - {task,thread}_wait
 - ia32_as_reserve: ajuster les flags G des pte du kas
 - sched_update: optimiser car ca pue
 - set_array_locate : dicho desactivÃ©e

--
  on devrait (dans kaneton) fournir la possibilite de creer une capability
  utilisable une fois, ou dans une periode de temps etc.

  inclure le nom du process dans la capability pour que ce ne soit pas anonyme?

#
# ---------- mycure -----------------------------------------------------------
#

DISPATCHER/MACHINE
 - ajuster le dispatcher + rajouter des machine_call + mettre a jour glue
   (attention exist, get etc. ne doivent pas etre inclus dans le dispatch)
 - verifier que les machine_call sont biens places: tout ce qui modifie c'est
   a la fin, tout ce qui detruit c'est au debut.
 - dispatcher comment

MACHINE
 - est-ce que chaque object/manager appelle machine_data()

ARGUMENTS
 - verifier que les arguments sont dans le bon ordre: target en dernier

ALIGNMENT
 - aligner les prototypes

SIZEOF
 - checker les sizeof() => sizeof ()

ASSERT
 - il ne doit pas rester d'assert i.e verifier les arguments
   + verifier que tous argument ecrit (pointeur) est verifie.

SHOW
 - dans show montrer les infos dependentes o_ et dans dump m_
 - margin pour le show

CODE
 - commenter tout le code

--- BUGS?

- j'ai change dans regions: object->options &= REGION_OPTION_FORCE; en |=
  dans inject()
- dans region, les ids sont id = address / PAGESZ - 1
- meme chose dans segment.

- s'assurer que PAGESZ n'est pas utilise mais kaneton$pagesz
- changer ces definitions en: $kaneton, $kernel, $server, $driver, $service,
  $guest, $pagesz, $wordsz, $endian -> a mettre dans les layout

- changer le scheduler et utiliser un set indexe par la priorite
- delete les macro QUEUE et UNQUEUE

- coder un morgue/mortuary/cremation/mortician/undertaker/burier qui, regulierement, enterre les morts

- attention thread_wait() les args ont change d'ordre

- mettre en place le timer pour la morgue de task et thread

- reorganiser kernel_clean comme l'init

- transformer les %qu en %qd

--- GLUE

- verifier que les donnees dependantes sont displayed dans show
- verifier que les tailles/adresses sont alignees dans core (region/segment..)

---- TESTS

- tester le nouveau robot
- recompiler les tests vu qu'on a changer quelques trucs
  - checker les warnings a la fois dans kaneton et tests
- dissocier les tests timer et clock

---- IMPLEM SERIEUSE

- commenter modules=fait machine/glue=? machine/plat=? core=?
- reverifier les protos pour que la target soit toujours en dernier argument: reserve, give etc.
- bien noter que l'interface ne marche plus.
- faire marcher les wait et differents etats de task
- IA32_DEPENDENT (dans architecture.h) a garder? ARCHITECTURE = IA32 ce serait mieux
- pourquoi le set container n'est pas alloue dans le initialize? d'autant plus qu'il est release dans clean()
- les types de glue (g_) et de arch (a_)

--- IA32

- dans interrupt, on trigger des events (soit on appelle la fonction a la main
  soit on utiliser event_notify) -> deja ca ca pue, ca devrait etre unifie
- de plus, on passe un code a la fonction alors que ce n'est pas prevu! pour
  faire ca il suffit d'ajouter un code dans la partie machine de l'event!
  -> chercher tous les event_notify et verifier que c'est propre
     puis corriger event_notify dans event si besoin

- virer les returns dans arch contre des LEAVE (core/glue/platform ont ete verifies)
- les include guards ainsi que macros et fonction prefixes doivent etre PLATFORM,
  ARCHITECTURE, GLUE et non IA32. il faut faire ca dans les tests egalement.
  => surtout dans machine/ia32/ car le reste est fait
- revoir context.h avec les 2 macros
- virer mmx, sse et x87? (sinon renommer ia32_*)
- meme chose avec les CPU?
- meme chose pour les IPI?
- dans paging.h, pas clair! on devrait avoir une structure pour: directory entry, table entry. directory et table serait des tableaux de ces structures.
  au lieu de ca, actuellement on a des structures abstraites qui ne sont utilisees que lorsque l'on a besoin en castant!
- pt_add_page et pd_add_page: ces fonctions devraient etre donnees car elles n'apportent rien et ca fait juste chier l'etudiant
- commenter/steps toutes les fonctions
- spinlock.h a virer?
- est-ce que ___kaneton$pagesize etc. sont toujours definis car il semble que ce ne soit
  le cas que dans HOST=linux/ia32.ia32 pas linux/ia32
- verifier que IA32_ENTRY_ADDRESS prend une pde et pte en arguments car
  le test kaneton/as/ia32/mapping a l'air de l'utiliser differemment.
- on peut fournir le boot loader en .lo pour eviter qu'ils grugent libia32

- chercher les XXX dans le code, il ne doit pas en rester

--- WIKI

- section news: nouveau systeme de tests pour cette annee (merci d'etre comprehensif)
- ajouter osdev.org dans les liens sur le wiki! + SOS (lire les articles)
- limiter l'acces au Wiki pour l'edition finalement.
- mettre novuelle version de devleopment book sur le site

--- EXPORT

- fini le ARCH=IA32 ce sera tjs IA32/EDUCATIONAL, changer les fichiers
- bien verifier que ca compiler/clear ie que les Makefiles sont bons

--- EVALUATION

- faire un super test et en 1 semaine faire une tranche de challenge ou ils doivent optimiser kaneton!
  -> genre lancer tous les tests a la suite sans rebooter

--- FUTURE

- changer tous les types de core en prefixant avec c_ pour core.
  t_options deviendrait ct_options, m_scheduler, cm_scheduler, i_task, ci_task
  etc.
  -> ensuite on definierait l'interface kernel qui elle definierait des
     aliases: ci_task -> i_task etc.
