--
 faire des screenshots pour kaneton: installation, configuration, env-dev,
 boot, into (mjpeg)

--
 axe kaneton sur le multiproc car avec les multicoeurs ca va devenir courant

--
 catch(addr, size, asid) then the asid could be able to do: reserve(addr, size)

--
 choses a faire (encore):

 - reorganiser et nettoyer check/ et check-students/
 - tester as_clone
 - faire les messages pour les event + timers
 - interface
 - map_resize, {region,segment}_{split,resize,coalesce}
 - malloc qui foire...
 - {task,thread}_wait
 - thread_args
 - pb de stack dans thread_clone

--
 voir pourquoi les taches de classe DRIVER et SERVICE ne fonctionnent
pas (ca semble etre un problème de segment selectors).

--
 aligner les modules lors de leur relocation + tenir compte de
l'endianness dans mod_load

--
 refaire la libc et inclure une libcrypt car le kernel en a besoin

--
 revoir l'interface shell qui est pourrave pour tout ce qui est
 manipulation de chaines, fichiers bref regexp

--
 ajouter des check sur les macros via #error

--
 utiliser _CHECK_ pour activer ou non le debug

--
 stats manager: utiliser l'instruction qui compte les cycles plutot
 qu'un timer ?

   + hyper precis
   - pas dispo partout

 en fait, le stat manager deconne trop maintenant qu'il y a le
 scheduling. il faut augmenter vachement la latence du kernel pour
 pouvoir s'en servir (dans timer.h: TIMER_MS_PER_TICK et dans sched.h:
 SCHED_QUANTUM_INIT).

--
 ecrire un paper juste sur la portabilite ou alors dans le reference
 book mais bien detaille car ca doit etre flou pour les lecteurs.

--
 trouver un nom pour les modules histoire que ce soit coherent:
 module = module noyaut, XXX = entite passive d'execution
 program -> ??? (logram)

--
 il doit y avoir moyen d'eviter les fichiers o2.h et octane.h
 dans la libmipsr10000 en definissant les macros dans l'archi
 et non la lib. a etudier.

--
 faudrait implementer des regions copy-on-write pour gagner en
 performance. qui plus est, il faut de toute facon pouvoir préciser si
 un segment doit etre cloné en cas d'as_clone. par exemple, on a pas
 envie de dupliquer la GDT, l'IDT, la kstack etc... qui sont mappés
 dans chaque as.

 +stack expansion

--


 * as
  - ia32_as_reserve: ajuster les flags G des pte du kas
 * map
  - map_resize: a revoir en fct des modifications de region/segment
 * region
  - region_split: a modifier - 2 regions / 1 segment
 * sched
  - sched_update: optimiser car ca pue
  - ia32_sched_yield
 * segment
  - segment_resize: segment OK (bug pour le 1er/dernier seg), regions TODO
  - segment_split: segment OK, regions TODO
  - segment_coalesce: segment OK, regions TODO
  - segment_perms: gestion des regions
 * set
  - set_array_locate : dicho desactivée
 * task
  - wait et clone a finir
 * thread
  - thread_clone: quand on clone un thread, il faut peut etre changer le
    cr3 plutot que le recopier.
  - thread_give: copier la pile dans le nouvel AS ?
  - gestion des wait

--
 + moulinette triche
 + norme dans books/kaneton

--
 enlever QUICKSTART et expliquer ce qu'il faut sur le site

--
 verifier que dans chaque manager il y a:

   machdep_include()
   tous les machdep_call()

   la variable globale correspondante au manager

--
 au lancement du core, celui-ci genere un nombre sur 64-bit.

 ce nombre va devenir son machine-id.

 de plus son node-id va etre calcule de la maniere suivante:

   node-id = hash(machine-id + 0)

 ou '+' designe la concatenation de donnees.

 plus tard, chaque tache pourra simplement calcule son node-id avec:

   node-id = hash(machine-id + task-id)

 ainsi chaque tache du systeme reparti aura un node-id unique et de plus
 les cores a leurs lancements auront un id, ce qui est requis pour la
 generation des capabilities.

--
 finalement on va surement avoir besoin de mapper les modules pour que
 le core puisse extraire le premier module et le lancer.

 ou mieux il faudrait que le bootloader passe en argument le premier module
 a lancer comme ca le kernel ne refait pas un boulot identique au bootloader.

--
 tous les profiles machines sauf linux et linux.mips sont foireux

 il faudra les mettre a jour enfin les refaire plutot

--
 virer les CFLAGS = ___kernel c'est trop laid/specifique

--
 revoir la doc: apparamment les etudiants ne comprennent pas instinctivement
 qu il y a trois parties bien distinctes: core, machdep, libarch

--
 pour resoudre les forward declarations, normalement faire comme set.h
 et ca marche, cad forward declarer tous les types d'un .h AVANT de
 faire les includes recursifs.

--
 ce serait interessant de rajouter un ensemble 'slab' qui ne se baserait
 pas sur malloc.

 ca montrerait la possibilite du set manager et en plus on pourrait faire
 des tests de perf avec le slab.

--
 probleme de nomenclature: chiche_get(o* o) ca marche pour recuperer un
 objet mais quand ce seront des programs userland, recuperer l objet
 entier ca ne les interesse pas, c'est lourd et c est pas le but.

 donc on devrait changer pour mettre a disposition des fonctions pour
 recuperer que certaines proprietes.

 une unique fonction genre chiche_pick()

--
 revoir le bootloader:

  t_modules
  {
    + t_module* modules;
  }
  t_module
  {
    + void* content;
    + t_module* next;
  }

--
 il faut prevoir que tout le demarrage des services via fichier de conf
 doit pouvoir etre fait en dynamique. par exemple si mod reserve un
 segment special (CATCH) pour le service tty (console) et bien il faut
 imaginer que si on lance ce meme serveur a la main une fois le systeme
 boote, soit le systeme de lui meme (via un fichier de conf) sait quels
 sont les objets dont il herite ou alors il faut prevoir des messages style
 segment_acquire() pour acquerir un segment specifique: la memoire video.

--
 hevea -exec xxdate.exe kaneton.tex pour generer du html

 latex -> html: HeVeA

 ca aurait ete bien un make web: faire un rep web/ au pire avec generation
 de doc, generation des resultats de tests et de la doc le tout en html.

--
 trouver un moyen de gerer un systeme d'evenements intra kernel. soit
 comme unix soit on fait differemment. sleep/wakeup

 en fait le systeme des pthreads est vraiment pas mal avec les condition
 variables ayant un mutex associe.

--
 segment:

 il faudra rajouter dans le bootloader init.c un segment correspondant
 au dma: SEGMENT_TYPE_CATCH

 on pourrait imaginer dans le fichier de conf dire que telle zone
 est en mode catch et qu elle est catchable que par telle tache (avec
 tel nom par exemple)

 en fait revoir le concept de catch car c'est quand meme pas clair encore.

-- norme commit
  [core/kaneton/set/set_bpt.c]
    1) init function updated to properly handle set options.
    2) ...

  [core/kaneton/kaneton.c]
    1) ...

  -> les points 1,2,3 etc.. sont pas ordre d'importance

--
 pour detecter les fichiers qui sont executables, ce qui n'est pas normal:

   find ./ -type f -perm +111

--
 dire dans kaneton design que un kernel c'est: des structures de donnees et
 de l'archi. dans kaneton, l'archi est separee de ce qui est independant
 de l'archi et les sturctures de donnees sont simplifiees au maximum via
 le set manager.

 mettre a jour le papier sur le design: capabilities, message, cpu etc..

--

securite et gestion des objets fondamentaux: zone memoire DMA, IRQ etc..

le kernel ne peut pas deviner a qui doivent revenir ces objets. il est
donc evident qu'une assistance externe est requise: un fichier de configuration

ce fichier de configuration contiendra la liste des taches qui requiert
un objet particulier. les taches seront identifiees par un nom de binaire
genre 'zsh' et un hash sur le code executable pour eviter tout detournement.

1) le kernel a la liste des objets prereserves et lorsqu'un reserve arrive
   sur cet objet il autorise seulement si ca matche un objet de la liste.

   cette technique est propre car le comportement des taches est identique
   peu importe que ce soit un objet normal ou prereserve: X_reserve()

   le probleme c'est que c'est le kernel qui doit s'occuper de se fichier
   ce qui implique parsing dans le kernel, probleme pour mettre a jour
   cette liste dynamiquement etc..

2) le service 'mod' lorsqu'une lance une nouvelle tache, regarde si des objets
   sont dans la liste pour cette tache. si c'est le cas, mod reserve l'objet
   et le donne a la tache.

   le parsing se fait dans mod et pas dans le kernel donc c'est plus propre.
   la mise a jour est egalement plus simple car 'mod' reste un programme,
   c'est plus flexible: interface de mise a jour, serialisation puis
   relancement de 'mod' etc.. bref il existe des methodes.

   le probleme c'est que 'mod' a le droit de reserver tous les objets donc
   au niveau securite, si ce service contient une faille c'est dangereux.

   de plus, dans cette solution, l'objet est detenu par la tache sans qu'elle
   n'ai rien eu a faire. c'est un peu bizarre comme fonctionnement pusisque
   la tache n'est pas censee savoir que 'mod' va reserve tel truc pour elle.

3) une sorte de mix des deux solutions precedentes.

   le service 'mod' a chaque creation de tache, va dire au kernel de
   prereserve un objet on the behalf of la tache en question. comme ca
   quand un reserve arrive, on voit que l'objet est deja reserve mais le
   kernel verifie. si l'objet est en realite pseudo reserve (catch) alors
   l'objet est en fait reserve et son etant passe de catchable->reserved.

   la fonction utilisee est unique: reserve(), l'interface ne change donc pas.
   la tache n'est pas au courant que quelqu'un a prereserve pour elle.

   le seul probleme c'est que 'mod' doit avoir le droit de prereserver des
   objets. ce n'est pas vraiment dramatique puisque 'mod' est considere comme
   un service prioritaire puisqu'il est la continuite du kernel. il effectue
   des taches kernels: loading de code etc.. a la place du kernel car
   c'est plus adapte que ce soit en dehors du kernel pour des raisons de
   proprete: parsing et evolutivite: fichier de conf, format de fichiers.

   en conclusion, 'mod' fait des catch() [fonction a renommer car aucun
   sens, ou plutot pire ca veut dire l'inverse de ce que l'on veut] sur
   tous les objets listes, puis les taches font des reserve dessus.

   le probleme c'est que l'evolutivite est moyenne. si on se rend compte que
   finalement une zone memoire ne devrait etre reservee que par une tache
   particuliere mais que cette info n'est pas dans le fichier de conf et
   bein meme si l'oin recharge le fichier de conf, une tache a tres bien pu
   deja reserver cette zone. bien entendu c'est un faux probleme puisque
   impossible a resoudre. si on veut faire les matheux, on formule LTL
   devrait suffir a le prouver.
