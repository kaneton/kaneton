#
# ---------- general ----------------------------------------------------------
#

- pas de CORE_, de XXX, de IA32, de return, warning: dans kaneton + test

- chercher les XXX restants et en faire des TODO
- afficher PD, GDT, IDT dans le show de glue

#
# ---------- assignments ------------------------------------------------------
#

- segmentation (GDT) dans k0
- IDT dans k1
- etc.

- donner des tips: commencer par trigger une interrupt, dumper quand une exception occurs, dumper la page directory/table lors d'un page fault etc.
- donner des references de chapitres importants dans doc IA32

#
# ---------- core -------------------------------------------------------------
#

- inutile d'avoir des pointeurs pour les managers!

- matter dans le trac car du coup la plupart des tickets ont du etre resolus!
- le trac n'est surement plus necessaire! ce fichier suffit!

#
# ---------- test -------------------------------------------------------------
#

- systeme de test en non-bloquant: list retourne la liste du serveur, display
  aussi et test retourne direct avec un email envoye quand termine.
- rajouter du logging dans le systeme de tests pour savoir quel test est
  en cours, de quel user etc.
- mettre le timeout dans le manifest, en fonction de l'environment
    { xen: XXX, qemu: XXX }

#
# ---------- ia32 -------------------------------------------------------------
#

- renommer esp dans _arch en pile car tous les pointeurs sur fin de pile
  sont nommes pile

#
# ---------- export -----------------------------------------------------------
#

- fini le ARCH=IA32 ce sera tjs IA32/EDUCATIONAL, changer les fichiers
- bien verifier que ca compiler/clear ie que les Makefiles sont bons
- on peut fournir le boot loader en .lo pour eviter qu'ils grugent libia32

#
# ---------- evaluation -------------------------------------------------------
#

- faire un super test et en 1 semaine faire une tranche de challenge ou ils doivent optimiser kaneton!
  -> genre lancer tous les tests a la suite sans rebooter

#
# ---------- future -----------------------------------------------------------
#

- changer tous les types de core en prefixant avec c_ pour core.
  t_options deviendrait ct_options, m_scheduler, cm_scheduler, i_task, ci_task
  etc.
  -> ensuite on definierait l'interface kernel qui elle definierait des
     aliases: ci_task -> i_task etc.

- le probleme d'allocation recursive (design): (i) deux objets avec le meme
  id ne devraient jamais etre ajoutes sans erreur (ii) a corriger
  fondamentalement
- malloc double-free qui devrait peter ou peter un warning
- page fault dans malloc:
    int i;

    for (i = 0; i < 1000; i++)
      {
        printf("[%u]\n", i);

        i_task t;
        i_as a;

        assert(task_reserve(TASK_CLASS_KERNEL,
                            TASK_BEHAVIOUR_KERNEL,
                            TASK_PRIORITY_KERNEL,
                            &t) == ERROR_OK);

        assert(as_reserve(t, &a) == ERROR_OK);
      }

- pour les capabilities: (i) soit un autorise l'attenuation hierarchique,
  auquel cas, c'est tres flexible mais pas super secure car en donnant une
  cap a un gars, il peut la refiler a tout le monde (sous-attenuee ou non)
  (ii) soit on limite a un niveau et en plus on inclue l'id de la tache qui
  va recevoir la cap pour eviter qu'il ne la refile (juste inclure un id et
  autoriser l'attenuation peut etre interessant cela dit). -> en incluant
  l'id on perd en perf car il faut faire un appel par attenuation i.e on ne
  peut pas attenuer une fois et balancer a 100 mecs.

- terminer d'ecrire les cours (fs, scheduling etc.)

- super test pour departager les gens en fonction de la rapidite -> points
  bonus => 25/20

--- LIBRARY

- tout clean, re-arranger le code, le commenter, utiliser le prefixe de
  type l_ etc.
