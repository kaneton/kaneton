#
# ---------- buck -------------------------------------------------------------
#

 cswitch: no io bitmap copy when class < 1
 et puis meme ca s'optimise encore : faire un set de i_port a granter,
c'est tjs mieux que 8192 bytes a memcpy.

--

 un truc qui me parait bizarre dans le bootloader: la stack courant
elle est pas mappee explicitement !

--

autre:
 - map_resize, {region,segment}_{split,resize,coalesce}
 - {task,thread}_wait
 - ia32_as_reserve: ajuster les flags G des pte du kas
 - sched_update: optimiser car ca pue
 - set_array_locate : dicho desactivÃ©e

--
  on devrait (dans kaneton) fournir la possibilite de creer une capability
  utilisable une fois, ou dans une periode de temps etc.

  inclure le nom du process dans la capability pour que ce ne soit pas anonyme?

#
# ---------- mycure -----------------------------------------------------------
#

- malloc double-free qui devrait peter ou peter un warning

--- TEST

- faire un test qui reserve/inject des trucs non-alignes

--- IA32

- renommer diretory and pd et table en pt
- dans interrupt, on trigger des events (soit on appelle la fonction a la main
  soit on utiliser event_notify) -> deja ca ca pue, ca devrait etre unifie
- de plus, on passe un code a la fonction alors que ce n'est pas prevu! pour
  faire ca il suffit d'ajouter un code dans la partie machine de l'event!
  -> chercher tous les event_notify et verifier que c'est propre
     puis corriger event_notify dans event si besoin

- virer les returns dans arch contre des LEAVE (core/glue/platform ont ete verifies)
- les include guards ainsi que macros et fonction prefixes doivent etre PLATFORM,
  ARCHITECTURE, GLUE et non IA32. il faut faire ca dans les tests egalement.
  => surtout dans machine/ia32/ car le reste est fait
- revoir context.h avec les 2 macros
- virer mmx, sse et x87? (sinon renommer ia32_*)
- meme chose avec les CPU?
- meme chose pour les IPI?
- dans paging.h, pas clair! on devrait avoir une structure pour: directory entry, table entry. directory et table serait des tableaux de ces structures.
  au lieu de ca, actuellement on a des structures abstraites qui ne sont utilisees que lorsque l'on a besoin en castant!
- pt_add_page et pd_add_page: ces fonctions devraient etre donnees car elles n'apportent rien et ca fait juste chier l'etudiant
- commenter/steps toutes les fonctions
- spinlock.h a virer?
- verifier que IA32_ENTRY_ADDRESS prend une pde et pte en arguments car
  le test kaneton/as/ia32/mapping a l'air de l'utiliser differemment.
- on peut fournir le boot loader en .lo pour eviter qu'ils grugent libia32

- chercher les XXX dans le code, il ne doit pas en rester

- mettre les structures d'arch dans la partie machine de _kernel

- il devrait plus y avoir de return ou ERROR_OK/KO
- ... de IA32
- ordonner les include dans architecture.h
- pas de CORE_
- chercher les XXX

- variables importantes eparpillees et non commentees:
  [handler.c]
  IA32_HANDLER_DATA_SECTION t_uint16      ia32_interrupt_ds = 0;
  IA32_HANDLER_DATA_SECTION t_uint32      ia32_interrupt_pdbr = 0;

  [context.c]
  IA32_HANDLER_DATA_SECTION t_ia32_cpu_local ia32_local_interrupt_stack = 0;
  IA32_HANDLER_DATA_SECTION t_ia32_cpu_local ia32_local_jump_stack = 0;
  IA32_HANDLER_DATA_SECTION t_ia32_cpu_local ia32_local_jump_pdbr = 0;
  IA32_HANDLER_DATA_SECTION t_ia32_cpu_local ia32_exception_code = 0;

- pourquoi les vars specifiques aux CPUs sont mises dans une section
  HANDLER?

--- EXPORT

- fini le ARCH=IA32 ce sera tjs IA32/EDUCATIONAL, changer les fichiers
- bien verifier que ca compiler/clear ie que les Makefiles sont bons

--- EVALUATION

- faire un super test et en 1 semaine faire une tranche de challenge ou ils doivent optimiser kaneton!
  -> genre lancer tous les tests a la suite sans rebooter

--- FUTURE

- changer tous les types de core en prefixant avec c_ pour core.
  t_options deviendrait ct_options, m_scheduler, cm_scheduler, i_task, ci_task
  etc.
  -> ensuite on definierait l'interface kernel qui elle definierait des
     aliases: ci_task -> i_task etc.
- le probleme d'allocation recursive (design): (i) deux objets avec le meme
  id ne devraient jamais etre ajoutes sans erreur (ii) a corriger
  fondamentalement
- pour les capabilities: (i) soit un autorise l'attenuation hierarchique,
  auquel cas, c'est tres flexible mais pas super secure car en donnant une
  cap a un gars, il peut la refiler a tout le monde (sous-attenuee ou non)
  (ii) soit on limite a un niveau et en plus on inclue l'id de la tache qui
  va recevoir la cap pour eviter qu'il ne la refile (juste inclure un id et
  autoriser l'attenuation peut etre interessant cela dit). -> en incluant
  l'id on perd en perf car il faut faire un appel par attenuation i.e on ne
  peut pas attenuer une fois et balancer a 100 mecs.
- terminer d'ecrire les cours (fs, scheduling etc.)
- super test pour departager les gens en fonction de la rapidite -> points
  bonus => 25/20

--- LIBRARY

- tout clean, re-arranger le code, le commenter, utiliser le prefixe de
  type l_ etc.
