--
 faire des screenshots pour kaneton: installation, configuration, env-dev,
 boot, into (mjpeg)

--
 axe kaneton sur le multiproc car avec les multicoeurs ca va devenir courant

--
 choses a faire (encore):

 - tester as_clone
 - faire les messages pour les event + timers
 - map_resize, {region,segment}_{split,resize,coalesce}
 - malloc qui foire...
 - {task,thread}_wait
 - thread_args
 - pb de stack dans thread_clone
 - ia32_as_reserve: ajuster les flags G des pte du kas
 - sched_update: optimiser car ca pue
 - ia32_sched_yield
 - set_array_locate : dicho desactivée
 - thread_clone: quand on clone un thread, il faut peut etre changer le
   cr3 plutot que le recopier.
 - thread_give: copier la pile dans le nouvel AS ?
 - voir pourquoi les taches de classe DRIVER et SERVICE ne fonctionnent
   pas (ca semble etre un problème de segment selectors).
 - ajouter PD_CURRENT, GDT_CURRENT, etc...
 - revoir les fonctions de PD/PT pour gerer mieux le paddr/vaddr.
 - refaite cswitch

--
 ajouter des check sur les macros via #error

--
 utiliser _CHECK_ pour activer ou non le debug

--
 faudrait implementer des regions copy-on-write pour gagner en
 performance. qui plus est, il faut de toute facon pouvoir préciser si
 un segment doit etre cloné en cas d'as_clone. par exemple, on a pas
 envie de dupliquer la GDT, l'IDT, la kstack etc. qui sont mappés
 dans chaque as.

 +stack expansion

--
 enlever QUICKSTART et expliquer ce qu'il faut sur le site: wiki students

--
 verifier que dans chaque manager il y a:

   machine_include()
   tous les machine_call()

   la variable globale correspondante au manager

--
 au lancement du core, celui-ci genere un nombre sur 64-bit.

 ce nombre va devenir son machine-id.

 de plus son node-id va etre calcule de la maniere suivante:

   node-id = hash(machine-id + 0)

 ou '+' designe la concatenation de donnees.

 plus tard, chaque tache pourra simplement calcule son node-id avec:

   node-id = hash(machine-id + task-id)

 ainsi chaque tache du systeme reparti aura un node-id unique et de plus
 les cores a leurs lancements auront un id, ce qui est requis pour la
 generation des capabilities.

--
 ce serait interessant de rajouter un ensemble 'slab' qui ne se baserait
 pas sur malloc.

 ca montrerait la possibilite du set manager et en plus on pourrait faire
 des tests de perf avec le slab.

--
 probleme de nomenclature: chiche_get(o* o) ca marche pour recuperer un
 objet mais quand ce seront des programs userland, recuperer l objet
 entier ca ne les interesse pas, c'est lourd et c est pas le but.

 donc on devrait changer pour mettre a disposition des fonctions pour
 recuperer que certaines proprietes.

 une unique fonction genre chiche_attribute(object, field)

--
 revoir le bootloader meme si c'est un detail (travail pour un nouveau venu):

  t_modules
  {
    + t_module* modules;
  }
  t_module
  {
    + void* content;
    + t_module* next;
  }

--
 il faut prevoir que tout le demarrage des services via fichier de conf
 doit pouvoir etre fait en dynamique. par exemple si mod reserve un
 segment special (CATCH) pour le service tty (console) et bien il faut
 imaginer que si on lance ce meme serveur a la main une fois le systeme
 boote, soit le systeme de lui meme (via un fichier de conf) sait quels
 sont les objets dont il herite ou alors il faut prevoir des messages style
 segment_acquire() pour acquerir un segment specifique: la memoire video.

--
 trouver un moyen de gerer un systeme d'evenements intra kernel. soit
 comme unix soit on fait differemment. sleep/wakeup

 en fait le systeme des pthreads est vraiment pas mal avec les condition
 variables ayant un mutex associe.

--
 dire dans kaneton design que un kernel c'est: des structures de donnees et
 de l'archi. dans kaneton, l'archi est separee de ce qui est independant
 de l'archi et les sturctures de donnees sont simplifiees au maximum via
 le set manager.

 mettre a jour le papier sur le design: capabilities, message, cpu etc.

--

[raisonnement a propos des objets dedies]

le kernel ne peut pas deviner a qui doivent revenir ces objets dedies. il est
donc evident qu'une assistance externe est requise: un fichier de
configuration.

ce fichier de configuration contiendra une liste des taches qui requiert
un objet dedie. les taches seront identifiees par un nom de binaire genre
'zsh' et un hash sur le code executable pour eviter tout detournement.

voici trois solutions possibles qui collent au design actuel:

1) le kernel detient le fichier de configuration. lorsqu'un X_reserve() arrive
   sur un objet, il autorise l'operation uniquement si l'objet en question
   matche un objet dedie de la liste.

   [+] cette technique est propre car le comportement des taches est identique
   peu importe que ce soit un objet normal ou dedie; la tache effectue toujours
   un X_reserve().

   [-] le probleme c'est que c'est le kernel qui doit s'occuper de ce fichier
   ce qui implique du parsing dans le kernel, une difficulte pour la mise a
   jour dynamique de cette liste etc. bref ce n'est pas tres approprie car
   le design est fait pour eviter ce genre de choses dans le kernel: parsing,
   chaines de caracteres etc.

2) rappelons que c'est le service 'mod' qui effectue tous les chargements de
   binaire ELF, a.out etc. c'est egalement ce module qui est lance en tout
   premier par le kernel. sa tache, une fois lancee, est de parser le fichier
   de configuration contenant la liste de servers a lance au boot et de
   les lancer, a l'instar de 'init' sous Unix. autrement dit, 'mod' peut
   effectuer tout ce qu'il veut avant de creer les premieres taches.

   dans cette solution, une fois 'mod' lance au boot, et avant de creer les
   taches, il va reserver tous les objets dedies de la liste et les donner
   via X_give() a la tache en question (un fois celle-ci creee et avant de
   la demarrer).

   [+] le parsing se fait dans 'mod' et pas dans le kernel ce qui est plus
   propre. la mise a jour est egalement plus simple car 'mod' reste un
   programme, c'est plus flexible: interface de mise a jour, serialisation puis
   redemarrage de 'mod' etc. bref il existe des methodes ... plus ou moins
   elegantes.

   [-] le probleme c'est que 'mod' a le droit de reserver tous les objets donc
   au niveau securite, si ce service contient une faille c'est dangereux. de
   plus, dans cette solution, l'objet est detenu par la tache sans qu'elle
   n'ai rien eu a faire. c'est un peu bizarre comme fonctionnement pusisque
   la tache n'est pas censee savoir que 'mod' va reserver tel objet pour elle.
   par exemple, le driver DMA ne reservera pas la zone DMA mais se la verra
   octroyer par defaut, un peu bizarre donc dans le fonctionnement.

3) une derniere solution, sorte de mix entre les deux solutions precedentes.

   on avait deja commence a resoudre ce probleme avec la zone DMA en ajoutant
   une fonction segment_catch(). l'idee etait que 'mod' reserve la zone DMA
   avant que les servers soient lances comme explique dans la solution
   precedente. puis il change le type de la zone reservee de
   RESERVED -> CATCHABLE. ensuite, le driver DMA faisait un appel a
   segment_catch() pour recuperer l'objet segment que lui avait pre-reserve
   'mod'.

   cette solution n'est pas terrible puisque c'est 'mod' qui fait le
   X_reserve() et 'dma' qui fait le X_catch(). 'dma' doit donc utiliser,
   suivant l'objet reserve (si il est specifique ou non) une fonction
   differente.

   pour eviter ca il faut renverser l'interface, et faire que 'mod' utilise
   une fonction pour indiquer au kernel qu'un objet ne doit etre reservable
   que par une tache particuliere, disons X_protect() et 'dma' fera un
   X_reserve() peu importe le type d'objet. le kernel va voir que l'objet
   n'est pas libre mais protege pour la tache T. si c'est T qui fait l'appel
   alors OK, l'objet est reserve.

   [+] la fonction utilisee est unique: reserve(), l'interface ne change
   donc pas. la tache n'est pas au courant que quelqu'un a pre-reserve pour
   elle.

   [-] le seul probleme c'est que 'mod' doit avoir le droit de pre-reserver des
   objets. ce n'est pas vraiment dramatique puisque 'mod' est considere comme
   un service prioritaire puisqu'il est la continuite du kernel. il effectue
   des taches kernels: loading de code etc. a la place du kernel car
   c'est plus adapte que ce soit en dehors du kernel pour des raisons de
   proprete: parsing et evolutivite: fichier de conf, format de fichiers.

en conclusion, 'mod' fait des protect() sur tous les objets dedies de la
liste du fichier de configuration, puis les taches font des reserve() dessus
comme d'habitude.

un petit mot sur l'evolutivite du systeme, plus exactement de la liste
des objets dedies. si on se rend compte que finalement une zone memoire ne
devrait etre reservee que par une tache particuliere mais que cette info
n'est pas dans le fichier de conf et bien meme si l'on recharge le fichier
de conf, une tache a tres bien pu deja reserver cette zone. donc je pense
qu'on peut dire que c'est un faux probleme et que donc l'evolutivite du
systeme sur ce point est impossible si l'on veut garantir l'ownership de
ces objets a tout instant (si on veut faire les matheux, on formule LTL
devrait suffir a le prouver).

 catch(addr, size, asid) then the asid could be able to do: reserve(addr, size)

--

 code vire du map manager (rien a faire la)

 mais on pourra le reutiliser pour la libunix, donc je garde :-)

/*
 * this function is a wrapper of mmap to map_reserve.
 */

void*			mmap(void*			start,
			     size_t			length,
			     int			prot,
			     int			flags,
			     int			fd,
			     off_t			offset)
{
  t_vaddr		addr;
  t_perms		perms = 0;

  if (flags)
    return MAP_FAILED;

  if (prot & PROT_READ)
    perms |= PERM_READ;
  if (prot & PROT_WRITE)
    perms |= PERM_WRITE;

  if (map_reserve(kasid,
		  MAP_OPT_NONE,
		  length,
		  perms,
		  &addr) != ERROR_NONE)
    return MAP_FAILED;

  return (void*)addr;
}

/*
 * this function is a wrapper to munmap.
 */

int			munmap(void*			start,
			       size_t			length)
{
  if (map_release(kasid, (t_vaddr)start) != ERROR_NONE)
    return -1;

  return 0;
}

/*
 * this is a wrapper to mremap.
 */

void*			mremap(void*			old_address,
			       size_t			old_size,
			       size_t			new_size,
			       unsigned long		flags)
{
  o_region*		o = NULL;
  t_opts		opts;
  t_vaddr		p;

  if (!(flags & MREMAP_MAYMOVE))
    {
      if (region_get(kasid, (i_region)(t_vaddr)old_address, &o) != ERROR_NONE)
	return MAP_FAILED;

      opts = o->opts;
      o->opts &= REGION_OPT_FORCE;
    }

  if (map_resize(kasid, old_address, new_size, &p) != ERROR_NONE)
    return MAP_FAILED;

  if (o)
    {
      o->opts = opts;
    }

  return (void*)p;
}

----------------------------- mycure :: todo ----------------------------------

la glue devrait contenir le fiichier de conf qui decrit les zones
prereservees a certains servers car ces zones dependent de l'archi/platform
donc glue

--

etudier le systeme de messages entre machines. regarder XDR et trouver
un compilateur a stub pour essayer de l'adapter elegamment a kaneton.

--

serveur d'emulation des interruptions linux pour pouvoir utiliser les binaires
linux sans recompile.

--

changer le systeme d'error et utiliser une pile de chaines de caracteres
comme pour les exceptions en Java par exemple. ce n'est pas a la libc
d'afficher un message mais directement au kernel. apres il faut voir
la rapidite et la memoire prise par ces messages.

---------------------------------------------

machine doit specifier:
 - les types: t_reg{8,16,32,64}
 - tous les machine_data{o_*, init, etc.}
 - ENDIAN base sur ___kaneton$endian
 - WORDSZ base sur ___kaneton$wordsz
 - PAGESZ base sur ___kaneton$pagesz

___kaneton$kernel
___kaneton (sera defini pour les applis user aussi mais sans ___kaneton$kernel)

tout ca doit etre dit dans le book kaneton.

--

expliquer l'utilisation des differents types: t_paddr, t_vsize, t_size
etc. dans core book.

--

t_behav, t_opts a renommer en complet

aucun objet ne doit etre passe en argument, toujours les id. la seule
exception c'est la fonction _get() du manager qui gere l'objet en question.
genre as_get() renvoie un o_as.

--

revoir message.h, trop le bordel.

--

virer les headers inutiles: ELF -> dans le bootloader

--

archi doit definir:

 o types.h pour la definition des types de bases t_uint* t_sint* etc..

machine doit fournir:

 o machine.h pour tout le reste

apres, le tout c'est que les headers ne doivent jamais utilises une definition
privee genre un objet ou un manager mais toujours les identifiants.

--

changer les types genre pointeurs de fonctions f_ etc.. mais aussi prefix
dependant du module etc.

--

recuperer les trucs dans conf.h: CONF_ENABLE_CHECK, CONF_MACHDEP_DEBUG,
  SERIAL, GDB_STUB, CONSOLE_FILE

CONSOLE_FILE dans kaneton/core/debug/ a gerer!

gerer TEST dans kaneton/Makefile: minimum de code, propre etc.

dans configure/critical.py checker si env.py est accessible, si non et
que variables OK alors demander de faire make!

modules -> inputs

--

preciser que les adresses de segment, region etc.. ne sont pas alignees.
par contre l'archi peut refuser un appel de fonction car une adresse
n'est pas alignee et que ca ne colle pas avec ce qu'elle veut. une autre
solution est de corriger l'adresse en fonction de l'archi

--

changer dans task.h les types CORE en KERNEL car core designe la partie
independante.

--
  au dessus du systeme de message, on pourrait construire un event-driven
  systeme: request/reply messages + one-way events

--
  ajouter un check-style au commit via les svn hooks

--
  etudier RBAC pour la security des utilisateurs et programmes dans l'OS.
  ce n'est pas lie au kernel mais a l'OS cette fois.

--
  dans le papier sur le design, rajouter le nombre de fonctions de l'ABI
  en fonction de la categorie: memoire, thread, security etc.

--
  les quads sont geres par le compilo donc si un developeur veut utilier
  un autre compilo, a lui de se demerder.
