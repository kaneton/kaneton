1) Non-Advanced Makefiles
  deja fait, genre norme EPTIA blabla les problemes que ca implique etc..

  rules, variables, dependences pour lancer d autres rules, surcharge gauche
  -command, implicit rules

  . multiple targets in a rule: $@ recoit la target matched" 	

bigoutput littleoutput : text.g
        generate text.g -$(subst output,,$@) > $@

is equivalent to

bigoutput : text.g
        generate text.g -big > bigoutput
littleoutput : text.g
        generate text.g -little > littleoutput

  . multiples rules for one target

objects = foo.o bar.o
foo.o : defs.h
bar.o : defs.h test.h
$(objects) : config.h

. advanced rules using phase one AND prerequisites chain


targets ...: target-pattern: prereq-patterns ...
        commands
        
The target-pattern and prereq-patterns say how to compute the prerequisites of each target. Each target is matched against the target-pattern to extract a part of the target name, called the stem. This stem is substituted into each of the prereq-patterns to make the prerequisite names (one from each prereq-pattern).

Each pattern normally contains the character `%' just once. When the target-pattern matches a target, the `%' can match any part of the target name; this part is called the stem. The rest of the pattern must match exactly. For example, the target `foo.o' matches the pattern `%.o', with `foo' as the stem. The targets `foo.c' and `foo.out' do not match that pattern.

The prerequisite names for each target are made by substituting the stem for the `%' in each prerequisite pattern. For example, if one prerequisite pattern is `%.c', then substitution of the stem `foo' gives the prerequisite name `foo.c'. It is legitimate to write a prerequisite pattern that does not contain `%'; then this prerequisite is the same for all targets.

`%' characters in pattern rules can be quoted with preceding backslashes (`\'). Backslashes that would otherwise quote `%' characters can be quoted with more backslashes. Backslashes that quote `%' characters or other backslashes are removed from the pattern before it is compared to file names or has a stem substituted into it. Backslashes that are not in danger of quoting `%' characters go unmolested. For example, the pattern `the\%weird\\%pattern\\' has `the%weird\' preceding the operative `%' character, and `pattern\\' following it. The final two backslashes are left alone because they cannot affect any `%' character.

Here is an example, which compiles each of `foo.o' and `bar.o' from the corresponding `.c' file:

objects = foo.o bar.o

all: $(objects)

$(objects): %.o: %.c
        $(CC) -c $(CFLAGS) $< -o $@

Here `$<' is the automatic variable that holds the name of the prerequisite and `$@' is the automatic variable that holds the name of the target; see Automatic Variables. 

$(filter %.o,$(files)): %.o: %.c
        $(CC) -c $(CFLAGS) $< -o $@
$(filter %.elc,$(files)): %.elc: %.el
        emacs -f batch-byte-compile $<

or another one:

bigoutput littleoutput : %output : text.g
        generate text.g -$* > $@

2) ...

  directives:

    .PHONY

    SUBDIRS = foo bar

    .PHONY = subdirs $(SUBDIRS)

    subdirs: $(SUBDIRS)

    $(SUBDIRS):
      $(MAKE) -C $@

  . if one prerequisity is activated, the target is launch even if the
    corresponding file is up-to-date

    foo.c:        FORCE
        echo FORCED

    FORCE:

  . directive export pour passer une var a un sous makefile

    $(MAKELEVEL) contient la profondeur de make

    $(MAKEFLAGS) contient les options de make. celle ci sont passees
      automatiquement. evidemment certaines options ne sont pas passees
      comme -C etc..

   si vous ne voulez pas passer les options alors faire:

     subsystem:
       cd subdir && $(MAKE) MAKEFLAGS= && cd ..

   -w pour afficher le directory dans lequel on entre et sort pour relancer
      make.
   -s pour l annuler = SILENT
   par default -w est active

As you can see, using `FORCE' this way has the same results as using `.PHONY: clean'.

Using `.PHONY' is more explicit and more efficient. However, other versions of make do not support `.PHONY'; thus `FORCE' appears in many makefiles. See section 4.6 Phony Targets. 

  .SUFFIXES

    .SUFFIXES: .hack .win

.SUFFIXES:            # Delete the default suffixes
.SUFFIXES: .c .o .h   # Define our suffix list

The `-r' or `--no-builtin-rules' flag causes the default list of suffixes to be empty. 

. DEFAULT RULE

%::
        echo $@

used like this:

all: foutre.o suce.o bande
        echo OK

%::
        touch $@

with .DEFAULT

.DEFAULT:
        echo $@

.PRECIOUS, .INTERMIDIATE, .SECONDARY, .DELETE_ON_ERROR sont
  utilises pour gerer des cas d erreurs et donc lancer des commandes
  dans ces cas la en fonction de la situation au moment de l erreur.

.IGNORE: ignore les erreurs d execution

.IGNORE:

bande:  suce.o
        lpo
        echo BANDE

.SILENT pour etre silencieux sur les actions

.SILENT:

bande:  suce.o
        echo BANDE

ET SUR LES CD

will create every file in prerequisites which doesnt match any rule.

  generic rules:
    $^: all prerequisities
    $@: the target name or the selected target name in the case of multiple
    $<: first prerequisite
    $?: prerequisites that have changed, that are newer than the target

`$?' is useful even in explicit rules when you wish to operate on only the prerequisites that have changed. For example, suppose that an archive named `lib' is supposed to contain copies of several object files. This rule copies just the changed object files into the archive:

lib: foo.o bar.o lose.o win.o
        ar r lib $?

    $+: same as $^ but prerequisites listed more than once are duplicated
        in the orginal order
    $*: the stem, the pattern matched %.output avec littleoutput ca donnera
          => little

automatic other variables:

    $(@D): the directory part of the target without the trailing slash
    $(@F): the file part of the target

  etc.. tres peu utilise, ce sont juste des optimisations plutot que d utiliser
    des functions, la on a direct les infos. apres il faut avoir besoin
    des ces infos pour que ce soit utile...

  includes,

  assignment:
    = deferred
    ?= deferred (conditional assignment: si non definie alors set)
    := immediate
    += deferred or immediate (on ajoute)

recursive (`='), static (`:='), appending (`+='), or conditional (`?=')

    define immediate
      deferred
    endef
For the append operator, `+=', the right-hand side is considered immediate if the variable was previously set as a simple variable (`:='), and deferred otherwise.

  ifdef, ifeq, ifndef, and ifneq

ifeq (0,${MAKELEVEL})
cur-dir   := $(shell pwd)
whoami    := $(shell whoami)
host-type := $(shell arch)
MAKE := ${MAKE} host-type=${host-type} whoami=${whoami}
endif

  immediate : immediate
	  deferred

3) prerequisities

There are actually two different types of prerequisites understood by GNU make: normal prerequisites such as described in the previous section, and order-only prerequisites. A normal prerequisite actually makes two statements: first, it imposes an order of execution of build commands: any commands necessary to build any of a target's prerequisites will be fully executed before any commands necessary to build the target. Second, it imposes a dependency relationship: if any prerequisite is newer than the target, then the target is considered out-of-date and must be rebuilt.

Normally, this is exactly what you want: if a target's prerequisite is updated, then the target should also be updated.

Occasionally, however, you have a situation where you want to impose a specific ordering on the rules to be invoked without forcing the target to be updated if one of those rules is executed. In that case, you want to define order-only prerequisites. Order-only prerequisites can be specified by placing a pipe symbol (|) in the prerequisites list: any prerequisites to the left of the pipe symbol are normal; any prerequisites to the right are order-only:

targets : normal-prerequisites | order-only-prerequisites

The normal prerequisites section may of course be empty. Also, you may still declare multiple lines of prerequisites for the same target: they are appended appropriately. Note that if you declare the same file to be both a normal and an order-only prerequisite, the normal prerequisite takes precedence (since they are a strict superset of the behavior of an order-only prerequisite). 

4) wildcard

A single file name can specify many files using wildcard characters. The wildcard characters in make are `*', `?' and `[...]', the same as in the Bourne shell. For example, `*.c' specifies a list of all the files (in the working directory) whose names end in `.c'.

The character `~' at the beginning of a file name also has special significance. If alone, or followed by a slash, it represents your home directory. For example `~/bin' expands to `/home/you/bin'. If the `~' is followed by a word, the string represents the home directory of the user named by that word. For example `~john/bin' expands to `/home/john/bin'. On systems which don't have a home directory for each user (such as MS-DOS or MS-Windows), this functionality can be simulated by setting the environment variable HOME.

Wildcard expansion happens automatically in targets, in prerequisites, and in commands (where the shell does the expansion). In other contexts, wildcard expansion happens only if you request it explicitly with the wildcard function.

The special significance of a wildcard character can be turned off by preceding it with a backslash. Thus, `foo\*bar' would refer to a specific file whose name consists of `foo', an asterisk, and `bar'.

print: *.c
        lpr -p $?
        touch print

objects = *.o

then the value of the variable objects is the actual string `*.o'. However, if you use the value of objects in a target, prerequisite or command, wildcard expansion will take place at that time. To set objects to the expansion, instead use:

objects := $(wildcard *.o)

Now here is an example of a naive way of using wildcard expansion, that does not do what you would intend. Suppose you would like to say that the executable file `foo' is made from all the object files in the directory, and you write this:

objects = *.o

foo : $(objects)
        cc -o foo $(CFLAGS) $(objects)

The value of objects is the actual string `*.o'. Wildcard expansion happens in the rule for `foo', so that each existing `.o' file becomes a prerequisite of `foo' and will be recompiled if necessary.

But what if you delete all the `.o' files? When a wildcard matches no files, it is left as it is, so then `foo' will depend on the oddly-named file `*.o'. Since no such file is likely to exist, make will give you an error saying it cannot figure out how to make `*.o'. This is not what you want!

Actually it is possible to obtain the desired result with wildcard expansion, but you need more sophisticated techniques, including the wildcard function and string substitution. See section The Function wildcard.

Microsoft operating systems (MS-DOS and MS-Windows) use backslashes to separate directories in pathnames, like so:

  c:\foo\bar\baz.c

This is equivalent to the Unix-style `c:/foo/bar/baz.c' (the `c:' part is the so-called drive letter). When make runs on these systems, it supports backslashes as well as the Unix-style forward slashes in pathnames. However, this support does not include the wildcard expansion, where backslash is a quote character. Therefore, you must use Unix-style slashes in these cases. 

5) advanced features

  target: foo.o -lcurses
    ...

  ca va chercher dans VPATH et rep courant la lib curses

Although the default set of files to be searched for is `libname.so' and `libname.a', this is customizable via the .LIBPATTERNS variable. Each word in the value of this variable is a pattern string. When a prerequisite like `-lname' is seen, make will replace the percent in each pattern in the list with name and perform the above directory searches using that library filename. If no library is found, the next word in the list will be used.

The default value for .LIBPATTERNS is "`lib%.so lib%.a'", which provides the default behavior described above.

You can turn off link library expansion completely by setting this variable to an empty value. 

. double-colon rules

suce::
        echo suce

bande suce goute::
        echo bande suce goute


soit que des : dans ce cas collision
soit que des :: dans ce cas les commandes sont executees dans chaque regles

: et :: => error

. ATTENTION les fichiers dans la directive include sont egalement considerees
  comme prerequisites

include deguste.d

deguste.d:
        echo CA BANDE

. generating dependencies

1) generer toutes les dependences dans un fichier, methode classique
   mais qui neanmoins prend du temps pour rien lorsque seulement
   un fichier source a ete modifie car on regenere tout.

   dans certains cas cette solution est plutot bonne etant donne
   que chaque fichier source depend des meme fichiers header.

2) on cree un fichier dep par fichier source pour n avoir a regenerer
   qu un fichier dep quand un fichier source est modifie.

   on utilise alors la regle suivante:

sources = foo.c bar.c

include $(sources:.c=.d)

%.d: %.c
        @set -e; rm -f $@; \
        $(CC) -M $(CPPFLAGS) $< > $@.$$$$; \
        sed 's,\($*\)\.o[ :]*,\1.o $@ : ,g' < $@.$$$$ > $@; \
        rm -f $@.$$$$

. echoing

@ vs .SILENT

-s --silent

@ plus flexible mais peut parfois engendrer des problemes lors
d appels de fonctions qui deviennent recursives ou bien appelles
a divers niveau

$(call a,BONJOUR)

define a
  @echo $(1) ; \
  $(call b,AUREVOIR)
endef

#define b
  @echo $(1)
endef

$ make all
COUCOU
BONJOUR
/bin/sh: line 1: @echo: command not found
make: *** [all] Error 127
$ 

X) Command Execution

When it is time to execute commands to update a target, they are executed by making a new subshell for each line. (In practice, make may take shortcuts that do not affect the results.)

Please note: this implies that shell commands such as cd that set variables local to each process will not affect the following command lines. (2) If you want to use cd to affect the next command, put the two on a single line with a semicolon between them. Then make will consider them a single command and pass them, together, to a shell which will execute them in sequence. For example:

foo : bar/lose
        cd bar; gobble lose > ../foo

X) errors in commands

pour tester si un rep existe (ok il y a mieux mais c est un exemple)

all:
	mkdir chiche/

ca va stopper le makefile

all:
	-mkdir chiche/

X) Recursive use of make

cd dir ; make ; cd ..

cd /dir ; make ; cd -

make -C dir

make -C /dir

X) Canned Command Sequence

target = @echo $@

define print-prerequisites
  @echo $^
endef

all:    bande
        $(target)
        $(print-prerequisites)

bande:

X) Variables Verbatim

define two-lines
echo foo
echo $(bar)
endef

OR

two-lines = echo foo; echo $(bar)


X) 6.2 Variables ??? XXX ???

x = variable1
variable2 := Hello
y = $(subst 1,2,$(x))
z = y
a := $($($(z)))

--

a_dirs := dira dirb
1_dirs := dir1 dir2

a_files := filea fileb
1_files := file1 file2

ifeq "$(use_a)" "yes"
a1 := a
else
a1 := 1
endif

ifeq "$(use_dirs)" "yes"
df := dirs
else
df := files
endif

dirs := $($(a1)_$(df))

X) override directive

ca permet de ne pas se laisser ecraser par les arguments de la ligne
de commande:

BANDE='-n'

$ make BANDE='-o'

la BANDE vaudra '-o'

avec la directive on peut dire:

override BANDE = 'n'

et aucune chance de le setter a '-o' par la ligne de commande

c est souvent utiliser pour ca par exemple

override CFLAGS += -g

make CFLAGS = -Wall

on peut egalement utiliser ca pour les defines pour etre sur que
personne ne vas l ecraser

override define foo
bar
endef

X) Target-Specific Variable Values

target ... : variable-assignment

or like this:

target ... : override variable-assignment


all:    suce
        echo $(BANDE)

suce : BANDE = carrement
suce : suce.o
        echo SUCE
        echo $(BANDE)

suce.o:
        echo SUCE.O
        echo $(BANDE)

on peut aussi utiliser cela avec les patterns, l on nomme donc le truc
Pattern-Specific Variable Values

%.o : CFLAGS = -O

X) Conditional parts

libs_for_gcc = -lgnu
normal_libs =

foo: $(objects)
ifeq ($(CC),gcc)
        $(CC) -o foo $(objects) $(libs_for_gcc)
else
        $(CC) -o foo $(objects) $(normal_libs)
endif

=>>>

libs_for_gcc = -lgnu
normal_libs =

ifeq ($(CC),gcc)
  libs=$(libs_for_gcc)
else
  libs=$(normal_libs)
endif

foo: $(objects)
        $(CC) -o foo $(objects) $(libs)

conditional-directive
text-if-true
endif

conditional-directive
text-if-true
else
text-if-false
endif

ifeq (arg1, arg2)
ifeq 'arg1' 'arg2'
ifeq "arg1" "arg2"
ifeq "arg1" 'arg2'
ifeq 'arg1' "arg2" 

meme chose avec ifneq

pour tester si une variables n est pas vide:

ifeq ($(strip $(foo)),)
text-if-empty
endif

ifdef variable-name

meme chose pour ifndef

archive:
ifneq (,$(findstring Z,$(MAKEFLAGS)))
        echo IFNEQ
else
        echo ELSE
endif

$ make MAKEFLAGS=Z

X) Functions

syntax:

$(function arguments)

or like this:

${function arguments}

-- a noter que cet exemple montre comment mettre des espaces

comma:= ,
empty:=
space:= $(empty) $(empty)
foo:= a b c
bar:= $(subst $(space),$(comma),$(foo))
# bar is now `a,b,c'.

function list for strings:

subst: substitue du texte: $(subst ee,EE,feet on the street)

patsubst: meme chose avec pattern: $(patsubst %.c,%.o,x.c.c bar.c)
          equivaut a la syntaxe simplifie: OBJECTS = $(SRCS:.c=.o)

findstring: pour trouver un truc dans une chaine: $(findstring a,a b c)

filter: filtre dans une chaine:

	sources := foo.c bar.c baz.s ugh.h
	foo: $(sources)
		cc $(filter %.c %.s,$(sources)) -o foo

etc.. ce sont les plus utilisees

function list for files:

dir: extrait le directory: $(dir src/foo.c hacks) => src/ ./

notdir: la partie non directory: $(notdir src/foo.c hacks) => foo.c hacks

basename: tout sauf le suffixe: $(basename src/foo.c src-1.0/bar hacks)
  => src/foo src-1.0/bar hacks

wildcard: $(wildcard *.c *.S *.asm)

foreach fonction:

dirs := a b c d
files := $(foreach dir,$(dirs),$(wildcard $(dir)/*))

Here text is `$(wildcard $(dir)/*)'. The first repetition finds the value `a' for dir, so it produces the same result as `$(wildcard a/*)'; the second repetition produces the result of `$(wildcard b/*)'; and the third, that of `$(wildcard c/*)'. 

the if fonction:

$(if condition,then-part[,else-part])

the call fonction: (very interesting)

$(call variable,param,param,...)

$(call suce) = $(suce)

--
reverse = $(2) $(1)

foo = $(call reverse,a,b)
--

the value fonction:

FOO = $PATH

all:
        @echo $(FOO)
        @echo $(value FOO)

The first output line would be ATH, since the "$P" would be expanded as a make variable, while the second output line would be the current value of your $PATH environment variable, since the value function avoided the expansion.

The value function is most often used in conjunction with the eval function (see section 8.8 The eval Function). 

the eval function:

very useful to generate makefile rules, makefile parts which will be
evaluated, parsed by make and integrated to this makefile:

PROGRAMS    = server client

server_OBJS = server.o server_priv.o server_access.o
server_LIBS = priv protocol

client_OBJS = client.o client_api.o client_mem.o
client_LIBS = protocol

# Everything after this is generic

.PHONY: all
all: $(PROGRAMS)

define PROGRAM_template
 $(1): $$($(1)_OBJ) $$($(1)_LIBS:%=-l%)
 ALL_OBJS   += $$($(1)_OBJS)
endef

$(foreach prog,$(PROGRAMS),$(eval $(call PROGRAM_template,$(prog))))

$(PROGRAMS):
        $(LINK.o) $^ $(LDLIBS) -o $@

clean:
        rm -f $(ALL_OBJS) $(PROGRAMS)

the origin function:

tells about the variable and not about its content. tells the nature
of the variable: undefined, default, file, automatic, override etc..

ifdef bletch
ifeq "$(origin bletch)" "environment"
bletch = barf, gag, etc.
endif
endif

the shell function:

performs a shell operation:

files := $(shell echo *.c)

functions that control make, list:

error: print a fatal error and exit

ifdef ERROR1
$(error error is $(ERROR1))
endif

ERR = $(error found an error!)

.PHONY: err
err: ; $(ERR)

warning: print a warning

X)

options:

make:
	printf = affiche les fichiers modifies


X) implicit rules

montrer, lister expliquer

expliquer aussi qu on peut les redefinir

%.o:	%.c
	...

% :: RCS/%,v
        $(CO) $(COFLAGS) $<

the old fashion was:

.c.o:	foo.h
	...


X) Default Variables, Used by Implicit Rules

AR
    Archive-maintaining program; default `ar'.

AS
    Program for doing assembly; default `as'.

CC
    Program for compiling C programs; default `cc'.

CXX
    Program for compiling C++ programs; default `g++'.

CPP
    Program for running the C preprocessor, with results to standard output; default `$(CC) -E'.

LEX
    Program to use to turn Lex grammars into C programs or Ratfor programs; default `lex'.

YACC
    Program to use to turn Yacc grammars into C programs; default `yacc'.

TEX
    Program to make TeX DVI files from TeX source; default `tex'.

TEXI2DVI
    Program to make TeX DVI files from Texinfo source; default `texi2dvi'.

RM
    Command to remove a file; default `rm -f'. 

Here is a table of variables whose values are additional arguments for the programs above. The default values for all of these is the empty string, unless otherwise noted.

ARFLAGS
    Flags to give the archive-maintaining program; default `rv'.

ASFLAGS
    Extra flags to give to the assembler (when explicitly invoked on a `.s' or `.S' file).

CFLAGS
    Extra flags to give to the C compiler.

CXXFLAGS
    Extra flags to give to the C++ compiler.

CPPFLAGS
    Extra flags to give to the C preprocessor and programs that use it (the C and Fortran compilers).

LDFLAGS
    Extra flags to give to compilers when they are supposed to invoke the linker, `ld'.

LFLAGS
    Extra flags to give to Lex.

YFLAGS
    Extra flags to give to Yacc. 

X) Defining and Redining Pattern Rules

A pattern rule looks like an ordinary rule except that a pattern rule is composed
of the character '%'.

in this case, the target is not a finite name but a pattern so it can match with
many different targets.

the prerequisites can also use a pattern.

thus, a pattern rule `%.o : %.c' says how to make any file `stem.o' from another file `stem.c'

the % matches any nonempty substring.

The substring that the `%' matches is called the stem.

`%' in a prerequisite of a pattern rule stands for the same stem that was matched by the `%' in the target.

%.o : %.c
        $(CC) -c $(CFLAGS) $(CPPFLAGS) $< -o $@

% :: RCS/%,v
        $(CO) $(COFLAGS) $<

X) The Match-anything rule

the target "%:" is called the match-anything rule.

X) Overriding Implicit Rules

You can override implicit rules just writing a rule with a identical target but
with different commands.

X) Last Resort Default Rule

There are two ways for writing a default rule.

the first one is to use the .DEFAULT directive which specify the commands to launch when
there were no matching rules.

we can also use the match-anything rule to launch default commands.

%::
	commands

the double colon makes the rule terminal, which means that its prerequisite may not be an intermediate file.








--- 1) explications des techniques
--- 2) mettre des cas concret

orthographe: prerequisite, prerequisites

--- others) parallel execution, errors handling


XXX ----------------------------------------------------------------------- XXX

soit la population P constitue de X individus a un instant T.

soit la fonction C(B) qui exprime un choix en fonction d'un bagage
ou background.

le background etant considere comme le bagage au sens general: intellectuel,
environnemental, experimental etc..

soit la fonction I(x1, x2) exprimant l'interaction de deux individus.
cette fonction modifiant le bagage de chacun des deux individus en interaction

soit B le bagage de chacun des X individus exprimable, calculable, ALORS

  soit x un individu:
