1) syntax

c preprocessor directives are of the form:

 . the character '#' for specifying a preprocessor operations
 . a directive name for the precise operation

we cannot define new directives, the directive set is fixed.

some directives require arguments.

for example the #define directive is followed by a whitespace and
requires a macro name.

2) header files

a)

header files contain c declarations and macro definitions to be used
by several source files.

you can request the use of a header file using the c preprocessor
directive #include.

note that requesting a header file to be included produced the same
result than to copy it into the c source file.

with a header file, the related declarations appear in only one place.

so the changes will only have to be made on a single header file
instead of on each source file.

b)

syntax of the include directive:

#include <file>: search the header file in a list of directories then
                 in a standard list of directories (for system headers).

  -I for the directory list
  -nostdinc for not searching in the system list

  <...> cannot contain neither wildcards nor comments.
  <...> cannot contain the > character but can contain the < character.

#include "file": search for the header file in the current working directory
                 then in system directories.

  "..." cannot contain the " character
  "..." does not accept the backslash escaped character, so:
        "chiche\n\tpresident\n" is a file containing three backslahes.

#include anythingelse: looks for a macro named anythingelse, resolve
                       the macro expansion. after all, checks if the
                       directive now matchs one of the two previous
                       syntaxes.

  #if defined(__NetBSD__) || defined(__OpenBSD__) || defined(__FreeBSD__)
    #define INCLUDE_FILE		"bsd/include.h"
  #else
    #define INCLUDE_FILE		"linux/include.h"
  #endif

  #include INCLUDE_FILE

c)

one-only included files

it often happens that a makefile includes another makefiles resulting
that a certain header is included more than once.

this fact leads to errors if the header files define structures, types etc..

but there's a way to prevent this.

the standard way to do this is:

#ifndef CHICHE_SEEN_WITH_THE_POPE
#define CHICHE_SEEN_WITH_THE_POPE

#endif /* CHICHE_SEEN_WITH_THE_POPE */

Be careful, user defines may not begin with the character _ because these
are reserved for system defines.

To avoid conflicts, the system makefiles generally begin with __.

Moreover, and still to avoid conflicts, these macros are suffixed with
some text. Indeed, otherwise, the two file generic/chiche.h and bsd/chiche.h
will generate conflicts.

The kaneton project uses a slightly different style:
 . no underscore before names
 . no suffixes
 . but instead use the relative path from the include directory as the name

for example:

  file core/include/kaneton/set.h where core/kaneton is the include dir:

    #ifndef KANETON_SET_H
      ...
    #endif

  file core/include/arch/ia32/kaneton/set.h where core/include/arch/machdep
  is the include directory:

    #ifndef IA32_KANETON_SET_H
      ...
    #endif

3) macros

a)

a macros is a sort of abbreviation which you define and then use later.

the standard convention for macro names is to use upper case.

Nevertheless, in few cases it is better to use lower case, especially
when trying to develop a kind of proxy as in the kaneton's set manager.

#define PAGESZ		4096

#define SET_SZ		PAGESZ

will result in: #define SET_SZ		4096

b)

macros with arguments are called: function-like macros.

be careful, the preprocessor only understand comma for separating arguments
so this call:

macro (array[x = y, x + 1])

result in a macro named 'macro' which takes two arguments, in this case,
'array[x = y' and 'x + 1]'.

moreover if a function-like macro takes one argument and the user
wants to pass an empty argument, he has to specify it using a
whitespace between the parenthesis: foo( )

it is also possible to use function-like macros which take zero argument
even if there is no advantage over classical macros.

think about function-like macros declarations which names must be
followed by an open parenthesis without any whitespace.

indeed if a whitespace appear between the name and the open parenthesis
the macros will be considered as a simple macros and the open parenthesis
will be the expansion:

  #define chiche(x) - 1

    chiche(3) => 3 - 1

  #define chiche (x) - 1

    chiche(3) => invalid use of macros because the macro takes no argument
    chiche => (x) - 1

4) predefined macros

the predefined macros fall into two categories: standard macros and
system macros.

a)

some interesting standard predefined macros which are very useful.

__FILE__
  the current file name: string

__LINE__
  the current line number: integer

these macros are very useful for debugging:

  fprintf(stderr, "%s:%u message here\n", __FILE__, __LINE__);

__DATE__
  the date the file was preprocessed: string `"Feb 1 1996"'

__TIME__
  same thing for the time: string `"23:59:01"'

b)

system predefined macros:

linux: for the linux system

__OpenBSD__: for the OpenBSD OS

5) stringification

the action means turning a code fragment into a string constant.

for example stringifying 'chiche(42)' results in '"chiche(42)"'

#define forward(function, args...) \
  fprintf(stderr, "calling: %s(%s)\n", #function, #args); \
  function(args);

int main()
{
  forward(bande, suce, avale);
}

$ ./main
calling: bande(suce, avale)

6) concatenation

the concatenation means joining two words into one.

when you define a macro, you request concatenation using the special
operator '##' in the macro body.

this often takes place with one constraint word and one of the macro
argument but it is also possible to apply concatenation between two
macro arguments:

#include <stdio.h>

#define str(x) #x

#define forward(function, arg) \
  str( function##arg )

int main()
{
  int bandesuce;

  printf("=> %s\n", forward(bande, suce));
}

$ ./main
=> bandesuce

now let's take a look to the most popular problem requesting concatenation:

typedef struct
{
  char *name,
  void (*function)(void);
} command;

command commands[] =
{
  { "quit", quit_command },
  { "help", help_command },
  ...
};

this array declaration can be simplified using a macro with concatenation:

#define NEW_COMMAND(name) { #name, name##_command }

command commands[] = 
{
  NEW_COMMAND(quit),
  NEW_COMMAND(help),
  ...
};

in kaneton the concatenation is widely used, first in the set manager
and then in the machine dependent interface.

let's take a look to the set manager and its interface using a trap system
to forward function calls to specific set manager: linked-list, array etc..

#define set_trap(_func_, _setid_, _args_...) \
  ...
  switch (_set_->type)
    {
      case SET_TYPE_ARRAY:
        _r_ = _func_##_array((_setid_), (_args_));
        break;
      case ...
    }
  ...

#define set_rsv(_type_, _args_...) \
  set_rsv_##_type_(_args_)

7) undefining macros

this is used to cancel a definition.

the directive used is '#undef' which is followed by the macro name to
be undefined.

#define FOO 4
x = FOO;
#undef FOO
x = FF

expands to:

x = 4;

x = FOO;

this code will not compile because FOO is now an undefined symbol.

the macro undefinition works for simple macros as for function-like macros.

8) redefining macros

redefining a macro means defining a name that is already in use as a macro.

if the macro redefined matchs the previous declaration (this case is possible
with multiple inclusions) the redefinition is simply ignored.

a macro redefinition is considered identical to its previous if every is
exactly identical excepts whitespaces which are ignored lexical symbols.

to avoid c-preprocessor warnings, prefer undefined the previous declaration
with the '#undef' directive before the macro redefinition.

9) Pitfalls

a) grouping macros arguments

think about grouping macros arguments to avoid non-wanted operations.

#define m(x, y) x + y

m(8 & 4, 5)

will be expanded to:

8 & 4 + 5 which is equal to (8 & (4 + 5))

but the result is not the one intended.

in fact, we wanted the macro to do: (8 & 4) + 5

for this we have to group the macro arguments to avoid these problems:

#define m(x, y) (x) + (y)

b) swallowing the semicolon

sometimes, it is useful to write macros which are a sequence of instructions
like this one:

#define function(f, a) \
 { \
  if (f != NULL) \
    f(a); \
 }

the strict use of this macro is:

function(listen, 42)

note that there is no semicolon at the end of the macro call.

nevertheless, users want to consider calling a macro as calling a
typical C function. for this reason, many programmers put semicolon
at the end of macro calls.

another reason is the identation which will not be correct if the
programmer do not put the semicolon.

in many cases, putting a semicolon at the end of a macro call
just result with an empty instruction and the compiler just ignore
this instruction, but think about this example:

if (opts == blabla)
  function(listen, 42);
else
  function(send, 42);

this example is not correct because it will be expanded to:

if (opts == blabla)
  {
    if (listen != NULL)
      listen(42);
  };
else
  {
    if (send != NULL)
      send(42);
  };

the problem here is the semicolon before the 'else'.

the only way to solve this problem is:

#define function(f, a) \
 do \
  { \
   if (f != NULL) \
     f(a); \
  } while (0)

so

  function(listen, 42);

will be expanded to:

  do
   {
     if (listen != NULL)
       listen(42);
   } while (0);

c) side effects

XXX


-- cpp
 1) evaluation ( { r; } )
 2) macro(, args...) second(suce, ##args)

