%%
%% copyright quintard julien
%% 
%% kaneton
%% 
%% seminar.tex
%% 
%% path          /home/mycure/kaneton/papers/seminar
%% 
%% made by mycure
%%         quintard julien   [quinta_j@epita.fr]
%% 
%% started on    Tue Jul  5 12:23:08 2005   mycure
%% last update   Sun Oct  9 14:02:21 2005   mycure
%%

%
% class
%

\documentclass[8pt]{beamer}

%
% packages
%

\usepackage{pgf,pgfarrows,pgfnodes,pgfautomata,pgfheaps,pgfshade}
\usepackage{colortbl}
\usepackage{times}
\usepackage{amsmath,amssymb}
\usepackage{graphics}
\usepackage{graphicx}
\usepackage{color}
\usepackage{xcolor}
\usepackage[english]{babel}
\usepackage{enumerate}
\usepackage[latin1]{inputenc}

%
% style
%

\usepackage{beamerthemesplit}
\setbeamercovered{dynamic}

%
% verbatim font
%

\definecolor{verbatimcolor}{rgb}{0,0.4,0}

\makeatletter
\renewcommand{\verbatim@font}
  {\ttfamily\footnotesize\color{verbatimcolor}\selectfont}
\makeatother

%
% new line
%

\newcommand{\nl}[0]{\vspace{0.4cm}}

%
% title
%

\title{kaneton}

%
% authors
%

\author
{
  Julien~Quintard\inst{1} \\
  {\tiny julien.quintard@gmail.com}
}

\institute
{
  \inst{1} kaneton distributed operating system project
}

%
% date
%

\date{\today}

%
% logos
%

\pgfdeclareimage[interpolate=true,width=34pt,height=18pt]
                {epita}{../logos/epita}
\pgfdeclareimage[interpolate=true,width=49pt,height=18pt]
                {upmc}{../logos/upmc}
\pgfdeclareimage[interpolate=true,width=25pt,height=18pt]
                {lse}{../logos/lse}

%
% table of contents at the beginning of each section
%

\AtBeginSection[]
{
  \begin{frame}<beamer>
   \frametitle{Outline}
    \tableofcontents[current]
  \end{frame}
}

%
% table of contents at the beginning of each subsection
%

\AtBeginSubsection[]
{
  \begin{frame}<beamer>
   \frametitle{Outline}
    \tableofcontents[current,currentsubsection]
  \end{frame}
}

%
% document
%

\begin{document}

%
% title frame
%

\begin{frame}
  \titlepage

  \begin{center}
    \pgfuseimage{epita} \hspace{0.1cm} \pgfuseimage{upmc} \hspace{0.1cm}
    \pgfuseimage{lse} \hspace{0.1cm}
  \end{center}
\end{frame}

%
% outline frame
%

\begin{frame}
  \frametitle{Outline}
  \tableofcontents
\end{frame}

%
% overview
%

\section{Overview}

% 1)

\begin{frame}
  \frametitle{Definition}

  ``A distributed operating system is a collection of independent
  computers that appear to the users of the system as a single operating
  system''
\end{frame}

% 2)

\begin{frame}
  \frametitle{People}

  \textbf{Authors}

  \begin{itemize}
    \item
      Julien Quintard
    \item
      Jean-Pascal Billaud
  \end{itemize}

  \nl

  \textbf{Assistants}

  \begin{itemize}
    \item
      Cedric Aubouy
    \item
      Fabien Le-Mentec
    \item
      Renaud Lienhart
  \end{itemize}

  \nl

  \textbf{Contributors}

  \begin{itemize}
    \item
      Christophe Eymard
  \end{itemize}
\end{frame}

% 3)

\begin{frame}
  \frametitle{Tools}

  The tools used to develop the kaneton distributed operating systems
  are UNIX classical tools:

  \begin{itemize}[<+->]
    \item
      gcc
    \item
      cpp
    \item
      gmake
    \item
      ld
    \item
      etc..
  \end{itemize}

  \nl

  Of course the language used is the C language.
\end{frame}

%
% goals
%

\section{Goals}

% 1)

\begin{frame}
  \frametitle{The Distributed Operating System Goals}

  \begin{itemize}[<+->]
    \item
      Highly transparent from the user point of view
    \item
      Scalable
    \item
      Able to provide an high communication abstraction
    \item
      Fault tolerant
    \item
      Able to migrate processes
    \item
      Location transparent
    \item
      Able to provide parallel programming facilities
    \item
      Neither totally centralised nor totally distributed ...
      scalable groups
    \item
      ... And maybe able to handle bizantine faults
  \end{itemize}
\end{frame}

% 2)

\begin{frame}
  \frametitle{The Microkernel Goals}

  \begin{itemize}[<+->]
    \item
      Easily portable
    \item
      Easily maintenable
    \item
      Able to run UNIX{\scriptsize \copyright} programs via
      an emulation library
    \item
      Never rewrite code already written before: LSE/OS
    \item
      Built for the distributed operating system requirements
  \end{itemize}
\end{frame}

%
% microkernel
%

\section{Microkernel}

% 1)

\begin{frame}
  \frametitle{The kaneton Microkernel}

  The kaneton operating system is composed of two parts: a
  \textbf{microkernel} and the \textbf{servers}.

  \nl

  The kaneton microkernel has four primary functionalities
  to provide:

  \begin{itemize}[<+->]
    \item
      Communication
    \item
      Memory management
    \item
      Process management
    \item
      I/O
  \end{itemize}
\end{frame}

%
% communication
%

\subsection{Communication}

% 1)

\begin{frame}
  \frametitle{Communication}

  \begin{itemize}[<+->]
    \item
      The communication abstraction used in kaneton is the messages
    \item
      Every event becomes a message including system calls, interrupts,
      signals etc..
    \item
      No group communication is provided by the microkernel
  \end{itemize}
\end{frame}

%
% memory
%

\subsection{Memory}

% 1)

\begin{frame}
  \frametitle{Memory}

  \begin{itemize}[<+->]
    \item
      An address space is composed of segments and regions
    \item
      Segments are physical memory areas while regions are virtual memory
      ones
    \item
      Segments can be accessed directly or via regions
    \item
      The use of regions does not constraint the programs to map
      segments
  \end{itemize}

  \nl

  Concepts:

  \begin{itemize}[<+->]
    \item
      Little objects linked to build more complex objects:
      as, task etc..
    \item
      Let's programs manage objects themselves
    \item
      More parallelism: the kernel is now able to create a dozen
      of address spaces and then to insert segments and regions
      into them or to migrate segments to another address space
    \item
      Easier data structure recycling
  \end{itemize}
\end{frame}

%
% objects and protections
%

\subsection{Objects And Protections}

% 1)

\begin{frame}
  \frametitle{Overview}

  A distributed operating system is based on network communications, so
  the network security is an important point.

  \nl

  Indeed, it is not conceivable to allow a process on a machine
  to allow memory on another one without security.

  \nl

  To include security while keeping good performances, distributed
  operating systems use capabilities, kinds of little cryptographic keys.
\end{frame}

% 2)

\begin{frame}
  \frametitle{Objects And Protections}

  \begin{itemize}[<+->]
    \item
      Capabitlites are used to protect objects. Permit tasks to generate
      less privileged capabilities and to give them to other tasks

      \nl

      Examples: \textit{segments manipulation and address spaces manipulation}
    \item
      A capability is composed of: object identifier, permissions,
      security check, and optional fields including location, lifetime
      etc..
    \item
      Generic capabilities versus \alert{specific} capabilities

      \nl

      Examples: \textit{file system and printers server: identifiers
        and operations}
    \item
      So, the kaneton microkernel will use specific and specialised
      capabilities
  \end{itemize}
\end{frame}

% 3)

\begin{frame}
  \frametitle{Specific Capabilities' Inherent Problems}

  \begin{itemize}[<+->]
    \item
      Capabilities built by the servers contrary to other systems:
      Amoeba etc..
    \item
      No capability unification
    \item
      So a slower mechanism for capability generation
  \end{itemize}
\end{frame}

% 4)

\begin{frame}
  \frametitle{But...}

  \begin{itemize}[<+->]
    \item
      More scalable to servers requirements: cryptography,
      capability format: without object identifier, with extended
      permissions etc..
    \item
      Moreover, capability generation is rare and generally used
      to restrict permissions
    \item
      The mechanism is performant in a normal use but can become
      slow when a program has to generate many different capabilities
  \end{itemize}
\end{frame}

% 5)

\begin{frame}
  \frametitle{Security Policies}

  The capability security check field does not garantee objects security.

  \nl

  So was introduced three security policies:

  \begin{itemize}[<+->]
    \item
      \textbf{No security}: no check field used
    \item
      \textbf{Local security}: the check field is used but the
      network communications do not use cryptography
    \item
      \textbf{Global security}: the cryptography is used to secure
      network communications
  \end{itemize}
\end{frame}

%
% set
%

\subsection{Set}

% 1)

\begin{frame}
  \frametitle{Set}

  \begin{itemize}[<+->]
    \item
      The set manager is used to organise data
    \item
      Every kernel manager use it

      \nl

      Example: \textit{Segment, Regions, Address Spaces, Tasks etc..}
    \item
      Leads to a very elegant and maintenable source code
    \item
      Optimisations are possible in the set manager and not in every
      manager using such a data structure
    \item
      Comparison with other systems: pointers. Leads to many
      programming confusions and errors
    \item
      Many different data structures provided: linked list, circular
      queue, pipe, stack, binary tree, array, b+-tree etc..
    \item
      Tools are also provided to improve performances: iterators etc..
  \end{itemize}
\end{frame}

%
% process
%

\subsection{Process}

% 1)

\begin{frame}
  \frametitle{Process}

  The kaneton kernel is composed of different entities:

  \begin{itemize}[<+->]
    \item
      \textbf{Module}: avoid dependencies after a crash
    \item
      \textbf{User}: userland applications, no system privileges
    \item
      \textbf{Service}: provide a service
    \item
      \textbf{Driver}: service which can communicate with devices
    \item
      \textbf{Kernel}: super-driver
  \end{itemize}

  \nl

  The microkernel manages tasks which are non active containers
  entities.

  \nl

  A task has an address space and one or more threads.

  \nl

  The thread is the active entity because it is scheduled.

  \nl

  ... Once again, easy data structure recycling and more parallelism.
\end{frame}

% 2)

\begin{frame}
  \frametitle{Task And Threads Properties}

  Each task has:

  \begin{itemize}[<+->]
    \item
      A \textbf{class} specifying its system privileges
    \item
      A \textbf{behaviour} specifying a priority range
    \item
      A \textbf{priority} specifying its current priority
  \end{itemize}

  \nl

  Each thread has:

  \begin{itemize}[<+->]
    \item
      A \textbf{priority} specifying its current priority
  \end{itemize}

  \nl

  These properties give the program many possibilities and
  permit it to choose its execution context.
\end{frame}

%
% processor
%

\subsection{Processor}

% 1)

\begin{frame}
  \frametitle{Processor}

  \begin{itemize}[<+->]
    \item
      Each thread can choose its processors
    \item
      This feature was directly imported from \textbf{Mach}
    \item
      This feature increases the parallelism allowing very
      specific threads with more interactive ones
  \end{itemize}
\end{frame}

%
% servers
%

\subsection{Server}

% 1)

\begin{frame}
  \frametitle{Servers}

  \begin{enumerate}
    \item
      Module Service
    \item
      Name Service
    \item
      Shared Memory Service
  \end{enumerate}
\end{frame}

% 2)

\begin{frame}
  \frametitle{Module Service}

  \begin{itemize}[<+->]
    \item
      Composed of two subparts: \textbf{mod} and \textbf{modfs}
    \item
      mod keeps track of most used modules
    \item
      modfs is a main memory file system
    \item
      Each module has a \textbf{lifetime}. The fundamental drivers
      and services modules have infinite lifetimes while user applications
      commonly have short lifetime
    \item
      The module service binds binary names to module identifiers.
      Moreover, the module service loads the binaries into the
      user applications' address spaces
    \item
      So, the kernel never has to handle strings ...
    \item
      ... resulting in a simpler kernel source code
  \end{itemize}
\end{frame}

% 3)

\begin{frame}
  \frametitle{Name Service}

  \begin{itemize}
    \item
      Composed of two subparts: \textbf{cns} and \textbf{dns}
    \item
      The name service permits applications to locate a precise server
    \item
      Concurrent executions are allowed due to the name service
    \item
      This server can decide to dispatch the work between identical servers
  \end{itemize}
\end{frame}

% 4)

\begin{frame}
  \frametitle{Shared Memory Service}

  \begin{itemize}[<+->]
    \item
      The shared memory service is divided into two subparts:
      \textbf{csm} and \textbf{dsm}
    \item
      Using the shared memory service ensures that the memory will not
      be released if some programs still are using it
    \item
      The distributed shared memory part can become a member of the
      distributed shared memory group, but this point will not be
      explained here.
  \end{itemize}
\end{frame}

%
% distributed operating system
%

\section{Distributed Operating System}

\begin{frame}
  \frametitle{The kaneton Distributed Operating System}

  \begin{itemize}[<+->]
    \item ... comming soon ...
  \end{itemize}
\end{frame}

\end{document}
