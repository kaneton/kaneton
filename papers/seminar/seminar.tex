%%
%% copyright quintard julien
%% 
%% kaneton
%% 
%% seminar.tex
%% 
%% path          /home/mycure/kaneton/papers/seminar
%% 
%% made by mycure
%%         quintard julien   [quinta_j@epita.fr]
%% 
%% started on    Tue Jul  5 12:23:08 2005   mycure
%% last update   Sun Oct 16 21:23:53 2005   mycure
%%

%
% class
%

\documentclass[8pt]{beamer}

%
% packages
%

\usepackage{pgf,pgfarrows,pgfnodes,pgfautomata,pgfheaps,pgfshade}
\usepackage{colortbl}
\usepackage{times}
\usepackage{amsmath,amssymb}
\usepackage{graphics}
\usepackage{graphicx}
\usepackage{color}
\usepackage{xcolor}
\usepackage[english]{babel}
\usepackage{enumerate}
\usepackage[latin1]{inputenc}

%
% style
%

\usepackage{beamerthemesplit}
\setbeamercovered{dynamic}

%
% verbatim font
%

\definecolor{verbatimcolor}{rgb}{0,0.4,0}

\makeatletter
\renewcommand{\verbatim@font}
  {\ttfamily\footnotesize\color{verbatimcolor}\selectfont}
\makeatother

%
% new line
%

\newcommand{\nl}[0]{\vspace{0.4cm}}

%
% title
%

\title{kaneton}

%
% authors
%

\author
{
  Julien~Quintard\inst{1} \\
  {\tiny julien.quintard@gmail.com}
}

\institute
{
  \inst{1} kaneton distributed operating system project
}

%
% date
%

\date{\today}

%
% logos
%

\pgfdeclareimage[interpolate=true,width=34pt,height=18pt]
                {epita}{../logos/epita}
\pgfdeclareimage[interpolate=true,width=49pt,height=18pt]
                {upmc}{../logos/upmc}
\pgfdeclareimage[interpolate=true,width=25pt,height=18pt]
                {lse}{../logos/lse}

%
% figures
%

\pgfdeclareimage[interpolate=true,width=233pt,height=170pt]
                {distributed-operating-system}
		{../figures/distributed-operating-system}
\pgfdeclareimage[interpolate=true,width=226pt,height=170pt]
                {servers}
		{../figures/servers}
\pgfdeclareimage[interpolate=true,width=170pt,height=170pt]
                {microkernel}
		{../figures/microkernel}

\pgfdeclareimage[interpolate=true,width=150pt,height=25pt]
                {generic-capabilities}
		{../figures/generic-capabilities}
\pgfdeclareimage[interpolate=true,width=150pt,height=75pt]
                {specific-capabilities}
		{../figures/specific-capabilities}

\pgfdeclareimage[interpolate=true,width=188pt,height=170pt]
                {sets}
		{../figures/sets}

%
% table of contents at the beginning of each section
%

\AtBeginSection[]
{
  \begin{frame}<beamer>
   \frametitle{Outline}
    \tableofcontents[current]
  \end{frame}
}

%
% table of contents at the beginning of each subsection
%

\AtBeginSubsection[]
{
  \begin{frame}<beamer>
   \frametitle{Outline}
    \tableofcontents[current,currentsubsection]
  \end{frame}
}

%
% document
%

\begin{document}

%
% title frame
%

\begin{frame}
  \titlepage

  \begin{center}
    \pgfuseimage{epita} \hspace{0.1cm} \pgfuseimage{upmc} \hspace{0.1cm}
    \pgfuseimage{lse} \hspace{0.1cm}
  \end{center}
\end{frame}

%
% outline frame
%

\begin{frame}
  \frametitle{Outline}
  \tableofcontents
\end{frame}

%
% overview
%

\section{Overview}

% 1)

\begin{frame}
  \frametitle{Definition}

  ``A distributed operating system is a collection of independent
  computers that appear to the users of the system as a single operating
  system''
\end{frame}

% 2)

\begin{frame}
  \frametitle{People}

  \textbf{Authors}

  \begin{itemize}
    \item
      Julien Quintard
    \item
      Jean-Pascal Billaud
  \end{itemize}

  \nl

  \textbf{Assistants}

  \begin{itemize}
    \item
      Cedric Aubouy
    \item
      Fabien Le-Mentec
    \item
      Renaud Lienhart
  \end{itemize}

  \nl

  \textbf{Contributors}

  \begin{itemize}
    \item
      Christophe Eymard
    \item
      Solal Jacob
  \end{itemize}
\end{frame}

% 3)

\begin{frame}
  \frametitle{Concepts}

  The concepts used by the kaneton project are:

  \begin{itemize}
    \item
      Little objects linked to build more complex objects:
      as, task etc..
    \item
      Let's programs manage objects themselves
    \item
      More parallelism: the kernel is able to create a dozen
      of address spaces and then to insert segments and regions
      into them or to migrate segments to another address space
    \item
      Easier data structure recycling
  \end{itemize}

  These concepts are mainly based on two things:

  \begin{itemize}
    \item
      Every object is identified by an 64-bit identifier and manipulated
      through the distributed system with a capability
    \item
      Every kernel manager uses a set to store data
  \end{itemize}
\end{frame}

%
% views
%

\section{Views}

% 1)

\begin{frame}
  \frametitle{Distributed Operating System}

  \begin{center}
    \pgfuseimage{distributed-operating-system}
  \end{center}
\end{frame}

% 2)

\begin{frame}
  \frametitle{Servers}

  \begin{center}
    \pgfuseimage{servers}
  \end{center}
\end{frame}

% 3)

\begin{frame}
  \frametitle{Microkernel}

  \begin{center}
    \pgfuseimage{microkernel}
  \end{center}
\end{frame}

%
% goals
%

\section{Goals}

% 1)

\begin{frame}
  \frametitle{Project Goals}

  The goals of the kaneton project were:

  \begin{itemize}[<+->]
    \item
      To build a pedagogical project
    \item
      With the clearest possible design
    \item
      Using distributed features
    \item
      Dealing with portability
    \item
      Finally, an \textbf{all easy to understand}:
      source code, design, microkernel, etc..
  \end{itemize}
\end{frame}

% 2)

\begin{frame}
  \frametitle{The Distributed Operating System Goals}

  \begin{itemize}[<+->]
    \item
      Highly transparent from the user point of view
    \item
      Scalable
    \item
      Able to provide an high communication abstraction
    \item
      Fault tolerant
    \item
      Able to migrate processes
    \item
      Location transparent
    \item
      Able to provide parallel and distributed programming facilities
    \item
      Neither totally centralised nor totally distributed ...
      scalable groups
  \end{itemize}
\end{frame}

% 3)

\begin{frame}
  \frametitle{The Microkernel Goals}

  \begin{itemize}[<+->]
    \item
      Easily portable
    \item
      Easily maintenable
    \item
      Able to run UNIX{\scriptsize \copyright} programs via
      an emulation library
    \item
      Built for the distributed operating system requirements
  \end{itemize}
\end{frame}

%
% microkernel
%

\section{Microkernel}

% 1)

\begin{frame}
  \frametitle{The kaneton Microkernel}

  The kaneton operating system is composed of two parts: a
  \textbf{microkernel} and the \textbf{servers}.

  \nl

  The kaneton microkernel has four primary functionalities
  to provide:

  \begin{itemize}[<+->]
    \item
      Communication
    \item
      Memory management
    \item
      Process management
    \item
      I/O
  \end{itemize}
\end{frame}

%
% communication
%

\subsection{Communication}

% 1)

\begin{frame}
  \frametitle{Communication}

  The communication abstraction used in kaneton is the messages.

  \nl

  Every event becomes a message including system calls, interrupts,
  signals etc..

  \nl

  No group communication is provided by the microkernel but by the distributed
  operating system.

  \nl

  This communication scheme is used to communicate with the servers
  of the machine as with the servers of the other machines, of
  the distributed system.
\end{frame}

%
% memory
%

\subsection{Memory}

% 1)

\begin{frame}
  \frametitle{Memory}

  An address space is composed of segments and regions.

  \nl

  Segments are physical memory areas while regions are virtual memory
  ones.

  \nl

  The address space object is just a container for the segment and
  the regions.

  \nl

  Segments can be accessed directly or via regions.
\end{frame}

%
% objects and protections
%

\subsection{Objects And Protections}

% 1)

\begin{frame}
  \frametitle{Overview}

  A distributed operating system is based on network communications, so
  the network security is an important point.

  \nl

  Indeed, it is not conceivable to allow a process on a machine
  to reserve an object and to manipulate it over the distributed
  system without security.

  \nl

  We needed a very ligth authentication system.

  \nl

  To include security while keeping good performances, distributed
  operating systems use capabilities, kinds of little cryptographic keys.
\end{frame}

% 2)

\begin{frame}
  \frametitle{Capabilities}

  Capabitlites are used to protect objects. Permit tasks to generate
  less privileged capabilities and to give them to other tasks.

  \nl

  Example: \textit{address spaces manipulation}

  \nl

  A capability is composed of: object identifier, permissions,
  security check, and optional fields including location, lifetime
  etc..

  \nl

  There exist two types of capabilities: generic capabilities versus
  \alert{specific} capabilities.

  \nl

  Examples: \textit{file system and printers server: identifiers
    and operations}

  \nl

  The kaneton microkernel will use specific and specialised capabilities.
\end{frame}

% 3)

\begin{frame}
  \frametitle{Generic Capabilities}

  An example of generic capabilities from the Amoeba distributed operating
  system.

  \begin{center}
    \pgfuseimage{generic-capabilities}
  \end{center}
\end{frame}

% 4)

\begin{frame}
  \frametitle{Specific Capabilities}

  Examples of specific capabilities used in kaneton.

  \begin{center}
    \pgfuseimage{specific-capabilities}
  \end{center}
\end{frame}

% 5)

\begin{frame}
  \frametitle{Specific Capabilities' Inherent Problems}

  \begin{itemize}[<+->]
    \item
      Capabilities built by the servers contrary to other systems:
      Amoeba etc..
    \item
      No capability unification
    \item
      So a slower mechanism for capability generation
  \end{itemize}

  \nl
\end{frame}

% 6)

\begin{frame}
  \frametitle{But...}

  \begin{itemize}[<+->]
    \item
      More scalable to servers requirements: cryptography,
      capability format: without object identifier, with extended
      permissions etc..
    \item
      Moreover, capability generation is seldom and generally used
      to restrict permissions
    \item
      The mechanism is performant in a normal use but can become
      slow when a program has to generate many different capabilities
  \end{itemize}
\end{frame}

% 7)

\begin{frame}
  \frametitle{Security Policies}

  The capability security check field does not garantee objects security on
  the entire distributed system.

  \nl

  So was introduced three security policies:

  \begin{itemize}[<+->]
    \item
      \textbf{No security}: no check field used
    \item
      \textbf{Local security}: the check field is used but the
      network communications do not use cryptography
    \item
      \textbf{Global security}: the cryptography is used to secure
      network communications
  \end{itemize}
\end{frame}

%
% set
%

\subsection{Set}

% 1)

\begin{frame}
  \frametitle{Overview}

  The current systems like linux, BSD, solaris etc.. generally use
  doubly linked-list data structures to organise internals data like
  tasks structures, cache structures, memory allocators etc..

  \nl

  Finally, with many pointers, the structures become very hard to understand
  and to manipulate leading to many programming errors so to kernel
  crashes.

  \nl

  We decided to adopt another way.

  \nl

  In kaneton, all the data structures are managed by the set manager.

  \nl

  Using a very simple and generic interface, the entire microkernel source
  code become very elegant, so more understandable by the students.
\end{frame}

% 2)

\begin{frame}
  \frametitle{Set}

  The set manager is used to organise data.

  \nl

  Every kernel manager use it to store its data rather than doing it
  by itself.

  \nl

  Examples: \textit{Segment, Regions, Address Spaces, Tasks etc..}

  \nl

  This organisation leads to a very elegant and maintenable source code.

  \nl

  Optimisations are possible in the set manager and not in every
  manager using such a data structure like other systems do.

  \nl

  Many different data structures are provided: linked list, circular
  queue, pipe, stack, hash tables, binary tree, array, b+-tree etc..

  \nl

  Some tools are also provided to improve performances: iterators etc..
\end{frame}

% 3)

\begin{frame}
  \frametitle{Implementation}

  The set manager needs to allocate memory. Indeed, the set manager
  is build over the malloc() function.

  \nl

  Neverthless, the malloc() function needs to allocate physical and
  virtual memory so to use the segments and regions managers.

  \nl

  But, the segments and regions managers use the set manager to store data.

  \nl

  To resolve this major problem, the malloc() function uses a survey area
  of memory used to provide fine-grained memory areas for the boot time
  of the kernel.

  \nl

  Then, the set manager uses the malloc() function to store data and all
  the kernel managers use the set manager. The kernel boot source code
  is so very beautiful contrary to other systems.

  \nl

  Moreover, the set manager has a set container to hold the set objects. This
  container is, in fact, also a set object.
\end{frame}

% 4)

\begin{frame}
  \frametitle{Figure}

  \begin{center}
    \pgfuseimage{sets}
  \end{center}
\end{frame}

%
% process
%

\subsection{Process}

% 1)

\begin{frame}
  \frametitle{Process}

  The kaneton microkernel is composed of different entities:

  \begin{itemize}
    \item
      \textbf{Module}: avoid dependencies after a crash
    \item
      \textbf{User}: userland applications, no system privileges
    \item
      \textbf{Service}: provide a service
    \item
      \textbf{Driver}: service which can communicate with devices
    \item
      \textbf{Kernel}: super-driver
  \end{itemize}

  \nl

  The microkernel manages tasks which are non active containers
  entities.

  \nl

  A task is composed of an address space and one or more threads.

  \nl

  The thread is the active scheduled entity.
\end{frame}

% 2)

\begin{frame}
  \frametitle{Task And Threads Properties}

  Each task has:

  \begin{itemize}
    \item
      A \textbf{class} specifying its system privileges
    \item
      A \textbf{behaviour} specifying a priority range
    \item
      A \textbf{priority} specifying its current priority
  \end{itemize}

  \nl

  Each thread has:

  \begin{itemize}
    \item
      A \textbf{priority} specifying its current priority
  \end{itemize}

  \nl

  These properties give the program many possibilities and
  permit it to choose its execution context.
\end{frame}

%
% processor
%

\subsection{Processor}

% 1)

\begin{frame}
  \frametitle{Processor}

  \begin{itemize}
    \item
      Each thread can choose its processors
    \item
      This feature was directly imported from \textbf{Mach}
    \item
      This feature increases the parallelism allowing very
      specific threads with more interactive ones
  \end{itemize}

  In kaneton, a task will be configured to run with X processors.

  \nl

  Then, each thread will be able to choose its processors.
\end{frame}

%
% servers
%

\subsection{Server}

% 1)

\begin{frame}
  \frametitle{Servers}

  Some examples of servers in kaneton:

  \begin{enumerate}
    \item
      Module Service
    \item
      Name Service
    \item
      Shared Memory Service
  \end{enumerate}
\end{frame}

% 2)

\begin{frame}
  \frametitle{Module Service}

  \begin{itemize}[<+->]
    \item
      Composed of two subparts: \textbf{mod} and \textbf{modfs}
    \item
      \textbf{mod} keeps track of most used modules
    \item
      \textbf{modfs} is a main memory file system
    \item
      Each module has a \textbf{lifetime}. The fundamental drivers
      and services modules have infinite lifetimes while user applications
      commonly have short lifetime
    \item
      The module service binds binary names to module identifiers.
      Moreover, the module service loads the binaries into the
      user applications' address spaces
    \item
      So, the kernel never has to handle strings ...
    \item
      ... resulting in a simpler kernel source code
  \end{itemize}
\end{frame}

% 3)

\begin{frame}
  \frametitle{Name Service}

  \begin{itemize}
    \item
      Composed of two subparts: \textbf{cns} and \textbf{dns}
    \item
      The name service permits applications to locate a precise server
    \item
      Concurrent executions are allowed due to the name service
    \item
      This server can decide to dispatch the work between identical servers
  \end{itemize}
\end{frame}

% 4)

\begin{frame}
  \frametitle{Shared Memory Service}

  \begin{itemize}[<+->]
    \item
      The shared memory service is divided into two subparts:
      \textbf{csm} and \textbf{dsm}
    \item
      Using the shared memory service ensures that the memory will not
      be released if some programs still are using it
    \item
      The distributed shared memory part can become a member of the
      distributed shared memory group, but this point will not be
      explained here but in the distributed operating system section of
      this document.
  \end{itemize}
\end{frame}

%
% distributed operating system
%

\section{Distributed Operating System}

\begin{frame}
  \frametitle{The kaneton Distributed Operating System}

  \begin{itemize}[<+->]
    \item ... comming soon ...
  \end{itemize}
\end{frame}

%
% tools
%

\section{Tools}

% 1)

\begin{frame}
  \frametitle{Tools}

  The tools used to develop the kaneton distributed operating systems
  are UNIX classical tools:

  \begin{itemize}
    \item
      gcc
    \item
      cpp
    \item
      gmake
    \item
      ld
    \item
      etc..
  \end{itemize}

  \nl

  The language used to develop kaneton is the C language.
\end{frame}

\end{document}
