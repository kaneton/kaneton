%%
%% licence       kaneton licence
%%
%% project       kaneton
%%
%% file          /home/buckman/kaneton/view/lectures/lse01/lse01.tex
%%
%% created       julien quintard   [fri dec  2 07:53:59 2005]
%% updated       matthieu bucchianeri   [sat apr 15 19:05:46 2006]
%%

%
% template
%

\input{../../templates/lecture.tex}

%
% title
%

\title{kaneton LSE internal presentation}

%
% authors
%

\author
{
  Matthieu~Bucchianeri and Renaud~Voltz\inst{1}
}

%
% figures
%

%
% document
%

\begin{document}

%
% title frame
%

\begin{frame}
  \titlepage

  \begin{center}
    \logos
  \end{center}
\end{frame}

%
% outline frame
%

\begin{frame}
  \frametitle{Outline}
  \tableofcontents
\end{frame}

%
% recalls
%

\section{Recalls}

%
% the bootloader
%

\subsection{The bootloader}

% 1)

\begin{frame}
  \frametitle{The bootloader}

  Goals:

  \nl

  \begin{itemize}[<+->]
  \item Setup a basic runtime environment for the kernel:
    \begin{itemize}[<+->]
    \item Relocate the kernel code
    \item Build the ``init'' record with all necessary information
    \item Prepare protected mode and paging for the kernel
    \item Make a basic identity mapping of necessary areas
    \item Install the kernel stack
    \item Mark prereserved segments of memory
    \end{itemize}
  \item Scheme of memory organization
  \end{itemize}

\end{frame}

%
% sets
%

\subsection{Sets}

% 1)

\begin{frame}
  \frametitle{Sets}
\end{frame}

%
% objects hierarchy
%

\subsection{Objects hierarchy}

% 1)

\begin{frame}
  \frametitle{Objects hierarchy}
\end{frame}

%
% memory management
%

\section{Memory management}

%
% summary
%

\subsection{Summary}

% 1)

\begin{frame}
  \frametitle{Summary of memory management}

  Goals:

  \nl

  \begin{itemize}[<+->]
  \item Allocate physical memory for processes
  \item Map this physical memory into a process' address space
  \item Manipulate easily address spaces
  \end{itemize}

  \nl

  Components:

  \nl

  \begin{itemize}[<+->]
  \item Address spaces (bound to a task)
  \item Segments (physical memory chunks)
  \item Regions (virtual mapping of segments)
  \end{itemize}

\end{frame}

%
% address spaces
%

\subsection{Address spaces}

% 1)

\begin{frame}
  \frametitle{Description}

  An address space:

  \nl

  \begin{itemize}[<+->]
  \item Is bound to one task only
  \item Describe a task's physical and virtual memory
  \item Is able to make translations between physical and virtual addresses
  \item Is able to clone itself
  \end{itemize}

  \nl

  To summarize:

  \nl

  \begin{itemize}[<+->]
  \item A set of segments
  \item A set of regions
  \end{itemize}

\end{frame}

% 2)

\begin{frame}
  \frametitle{Intel IA32 implementation}

  With Intel architecture, there are two main ways to implement address spaces:

  \nl

  \begin{itemize}
  \item Segmentation
  \item Paging
  \end{itemize}

\end{frame}

% 3)

\begin{frame}
  \frametitle{Intel IA32 implementation\\Segmentation}

  \begin{itemize}[<+->]
  \item Implement some kind of ``windows'' of addressable memory (with a base and a limit)
  \item Selecting a ``window'' is made via segment selector registers
  \end{itemize}

  \nl

  Pros:

  \begin{itemize}[<+->]
  \item Quick: translation is done adding the base of a segment to the linear address and checking the limit and privileges
  \end{itemize}

  Cons:

  \begin{itemize}[<+->]
  \item Code must be position independent
  \item Always have to manipulate segment selectors registers
  \item Address space is not 4 Gb large and limited to real amount of physical memory
  \item Ares are contiguous
  \end{itemize}

\end{frame}

% 4)

\begin{frame}
  \frametitle{Intel IA32 implementation\\Paging}

  \begin{itemize}[<+->]
  \item A virtual address is divided in three fields: the page directory index, the page table index and the offset
  \item Translation is done using tables: one page directory and multiple page tables
  \end{itemize}

  \nl

  Pros:

  \begin{itemize}[<+->]
  \item 4 Gb of addressable memory
  \item Only one register to change when switching address space (PDBR)
  \item Contiguous data in the address space may not be contiguous in physical memory
  \end{itemize}

  Cons:

  \begin{itemize}[<+->]
  \item More complex (page directory \& page table manipulation)
  \item A bit slower: translations need to follow links in page tables (a cache called the Translation Lookaside Buffer is used to minimize memory accesses)
  \end{itemize}

\end{frame}

% 4)

\begin{frame}
  \frametitle{Intel IA32 implementation\\Details on the ia32-virtual profile}

  For the moment, the only available solution is using the paging mecanism.

  \nl

  So an address space is represented only by its page-directory base register.
  Reserving an address space means:

  \begin{itemize}[<+->]
  \item Reserving a segment for the page directory
  \item Mapping the created page-directory to clear it
  \item Filling an internal field holding the PDBR
  \end{itemize}

  \nl

  Address space switching will be detailed later in this lecture.

\end{frame}

% 5)

\begin{frame}
  \frametitle{The special case of the kernel address space}

  The case  of the kernel address  space must be handled  in a special
  way. We must reuse the  page-directory created by the bootloader but
  we must clean everything we've mapped and that is not longer useful.

  \nl

  Additionally,  we must  ensure that  currently used  page-tables (we
  don't know  how many they  are since it  depends on kernel  code and
  modules size)  will not be  erased so we  must inject them  into the
  kernel address space.

  \nl

  And to finish,  we must add the so  called ``mirroring'' entry, used
  to access page tables.

\end{frame}

%
% segments
%

\subsection{Segments}

% 1)

\begin{frame}
  \frametitle{Description}

  A segment is a contiguous area of physical memory.

  \nl

  Segments are the entity that implements permissions (read, write and
  execute),  but this  feature is  used differently  depending  on the
  architecture.  So in  fact, with  IA32 paging,  permission  a really
  implemented in regions (later in this presentation).

\end{frame}

% 2)

\begin{frame}
  \frametitle{Operations}

  The available operations on segments are:

  \begin{itemize}[<+->]
  \item Allocation and release
  \item Setting permissions
  \item Resizing, splitting and coalescing
  \item Read, write and copy
  \item Cloning
  \end{itemize}

  \nl

  For the moment, the allocation algorithm is a simple first-fit.

\end{frame}

% 3)

\begin{frame}
  \frametitle{Prereserved segments and catcheable segments}

  There are two problems coming with segments:

  \begin{itemize}
  \item kaneton uses a bootloader, so some segments are allocated before the segment manager is ready
  \item Depending on the architecture, some segments are reserved to hardware access (like the video memory or the DMA controller)
  \end{itemize}

  \nl

  To ensure segment reserved by the bootloader are not erased, we will
  mark   some   segments   as   prereserved   into   the   \emph{init}
  structure. When  creating the  kernel address space,  these segments
  will be  injected so  the allocator will  not be able  to reallocate
  them to other processes.

\end{frame}

% 4)

\begin{frame}
  \frametitle{Catcheable segments}

  The solution  to the second problem  is to tell  the segment manager
  that some segments will be used in the future by precise managers.

  \nl

  So  we prereserve  some  segments and  we  do not  tell their  owner
  address  space.  These segments  without  bound  address spaces  are
  ``catcheable'' by other address spaces.

\end{frame}

%
% regions
%

\subsection{Regions}

% 1)

\begin{frame}
  \frametitle{Description}

  Regions are mapped memory locations.

  \nl

  A region is bound to the segment it maps and to the address space in
  which it is mapped.

\end{frame}

% 2)

\begin{frame}
  \frametitle{Operations}

  There are a very few operations on regions:

  \begin{itemize}[<+->]
  \item Allocating some space in an address space
  \item Mapping and unmapping virtual memory
  \end{itemize}

  \nl

  When  mapping some  memory,  you  can choose  to  force its  virtual
  address (for  example, when allocating memory for  the code section)
  or to  reserve some space  into the process' address  space (typical
  example is \emph{mmap}).

\end{frame}

% 3)

\begin{frame}
  \frametitle{Mapping process on IA32}

  The memory is divided into pages, each one is 4 kilo-bytes large.

  \nl

  Paging  is the mechanism  that makes  a page  in the  virtual address
  space corresponding to a page in physical memory.

  \nl

  The   translation    is   done   through    special   pages   called
  page-directories and page-tables.

  \nl

  Let's take an example.

\end{frame}

% 4)

\begin{frame}
  \frametitle{Mapping process on IA32\\The cyclic problem}

  But we need  to map the page-directory and the  page-tables to map a
  single page !

  \nl

  That's why we use the mirroring technique with the kernel address space.

\end{frame}

%
% higher level functionalities
%

\subsection{Higher-level functionalities}

% 1)

\begin{frame}
  \frametitle{The map manager}

  Reserving some memory for direct use is a bit heavy since we have to
  reserve a segment and then map a region over this segment.

  \nl

  So we introduced the map manager which is an overlay to segments and
  regions. The map manager offers  a function that allocates a segment
  and then map a region over it.

\end{frame}

% 2)

\begin{frame}
  \frametitle{malloc function}

  While segments and  region granularity is the page  (4k), the malloc
  function gives a fine-grain allocator.

  \nl

  At boot time, all memory  managers are not running, so malloc cannot
  rely on segment and  region managers during the early initialization
  stages.

  \nl

  To solve  this problem, we use  a ``survey area'':  we preallocate a
  dozen of pages  and malloc will allocate space  in these pages until
  the whole memory management mechanism is initialized.

\end{frame}

%
% integration with tasks
%

\subsection{Integration with tasks}

% 1)

\begin{frame}
  \frametitle{Address space switch}
\end{frame}

% 2)

\begin{frame}
  \frametitle{Accessing an address space from the kernel}
\end{frame}

%
% events management
%

\section{Events management}

%
% test suite
%

\section{Test suite}

%
% testing students tarballs
%

\subsection{Testing students tarballs}

% 1)

\begin{frame}
  \frametitle{Steps in testing a student tarball}
\end{frame}

%
% the test suite
%

\subsection{The test suite}

% 1)

\begin{frame}
  \frametitle{The test suite}
\end{frame}

\end{document}
