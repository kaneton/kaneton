%%
%% licence       kaneton licence
%%
%% project       kaneton
%%
%% file          /home/mycure/kaneton/view/lectures/arch-mips/arch-mips.tex
%%
%% created       julien quintard   [wed nov 23 22:07:25 2005]
%% updated       julien quintard   [thu nov 24 19:26:24 2005]
%%

%
% template
%

\input{../../templates/lecture.tex}

%
% title
%

\title{MIPS Architectures}

%
% authors
%

\author
{
  Julien~Quintard\inst{1}
}

%
% figures
%

\pgfdeclareimage[interpolate=true,width=188pt,height=97pt]
                {philosophies}
		{figures/philosophies}

\pgfdeclareimage[interpolate=true,width=166pt,height=26pt]
                {r-format}
		{figures/r-format}
\pgfdeclareimage[interpolate=true,width=166pt,height=26pt]
                {i-format}
		{figures/i-format}
\pgfdeclareimage[interpolate=true,width=166pt,height=26pt]
                {j-format}
		{figures/j-format}

\pgfdeclareimage[interpolate=true,width=166pt,height=46pt]
                {overflow-handling}
		{figures/overflow-handling}
\pgfdeclareimage[interpolate=true,width=166pt,height=46pt]
                {overflow-avoiding}
		{figures/overflow-avoiding}

\pgfdeclareimage[interpolate=true,width=270pt,height=129pt]
                {endianness}
		{figures/endianness}
\pgfdeclareimage[interpolate=true,width=82pt,height=129pt]
                {memory-layout}
		{figures/memory-layout}
\pgfdeclareimage[interpolate=true,width=270pt,height=129pt]
                {memory-access}
		{figures/memory-access}

\pgfdeclareimage[interpolate=true,width=178pt,height=79pt]
                {jump-instruction}
		{figures/jump-instruction}

\pgfdeclareimage[interpolate=true,width=163pt,height=45pt]
                {amdhal-rule}
		{figures/amdhal-rule}

%
% document
%

\begin{document}

%
% title frame
%

\begin{frame}
  \titlepage

  \begin{center}
    \logos
  \end{center}
\end{frame}

%
% outline frame
%

\begin{frame}
  \frametitle{Outline}
  \tableofcontents
\end{frame}

%
% introduction
%

\section{Introduction}

% 1)

\begin{frame}
  \frametitle{Description}

  \begin{itemize}[<+->]
    \item
      About \textbf{thirty} course hours.
    \item
      Concluded by an exam.
  \end{itemize}
\end{frame}

% 2)

\begin{frame}
  \frametitle{Contents}

  \begin{itemize}[<+->]
    \item
      External architecture.
    \item
      Pipeline.
    \item
      Compiler optimisations.
    \item
      Memory.
  \end{itemize}
\end{frame}

%
% overview
%

\section{Overview}

% 1)

\begin{frame}
  \frametitle{Introduction}

  An architecture is composed of:

  \begin{itemize}[<+->]
    \item
      Visible registers.
    \item
      Instructions set.
    \item
      Addressing.
    \item
      Interrupts/exceptions system.
  \end{itemize}
\end{frame}

% 2)

\begin{frame}
  \frametitle{Description}

  The MIPS processor is a 32-bit little-endian processor.

  \nl

  This processor provides \textbf{32 integer registers}, from R0 to R31.

  \nl

  Nevertheless two registers have special meaning:

  \begin{itemize}[<+->]
    \item
      \textbf{R0}: Trash Register: this register when read returns zero and
      writtings are ignored.
    \item
      \textbf{R31}: Link Register: this register holds the return address
      of a subprogram.
  \end{itemize}
\end{frame}

% 3)

\begin{frame}
  \frametitle{Special Registers}

  There are other special registers:

  \begin{itemize}[<+->]
    \item
      \textbf{HI and LO} are used for multiplications and division.
  \end{itemize}

  The MIPS precessor has four registers very interesting for system
  programming:

  \begin{itemize}[<+->]
    \item
      \textbf{SR}: Status Register: used to distinguish the two context
      modes: user and supervisor.
    \item
      \textbf{CAUSE}: holds the cause of the interrupt/exception.
    \item
      \textbf{EPC}: Exception Program Counter: holds the program counter
      of the instruction that caused the exception.
    \item
      \textbf{BAR}: Bad Address Register: holds the address that cause
      the memory error.
  \end{itemize}
\end{frame}

% 3)

\begin{frame}
  \frametitle{RISC}

  While inventors of RISC said:

  \nl

  \textbf{``Reduced Instruction Set Computer''}

  \nl

  Other people said that was false and that the true definition was:

  \nl

  \textbf{``Reject Important Stuff into Compiler''}

  \nl

  These notices tend to explain the real goal of this processor.
\end{frame}

% 4)

\begin{frame}[containsverbatim]
  \frametitle{RISC vs CISC}

  Let's take an example to compare the assembly language of CISC and RISC
  processors.

  \nl

  We want to perform the operation below:

  \begin{verbatim}
    int         res;
    int         a = 21;
    int         b = 42;

    res = a + b;
  \end{verbatim}

  On CISC processors:

  \begin{verbatim}
    add [res], [a], [b]
  \end{verbatim}

  On RISC processors:

  \begin{verbatim}
    Lw R4, [a]
    Lw R5, [b]
    Add R6, R4, R5
    Sw R6, [res]
  \end{verbatim}

  You can easily notice that CISC processors have only one instruction while
  RISC processors have four instructions.
\end{frame}

% 4)

\begin{frame}
  \frametitle{Brief History}

  During fifty's, CISC processors do not stop trying to provide
  more and more complex instructions to fit the high levels programming
  languages requirements.

  \nl

  RISC designers tried to do the exact opposite thing, to always stay
  near the hardware language.

  \nl

  Indeed, RISC designers thought that while a CISC instruction ran in
  for example 4 cycles, a RISC processor would be able to run the
  equivalent three instruction each taking 1 cycle.
\end{frame}

% 5)

\begin{frame}
  \frametitle{Philosophies}

  \begin{center}
    \pgfuseimage{philosophies}
  \end{center}
\end{frame}

%
% instruction formats
%

\section{Instruction Formats}

% 1)

\begin{frame}
  \frametitle{Overview}

  The MIPS processor classifies its 57 instructions into three groups.

  \begin{enumerate}[<+->]
    \item
      \textbf{R}: Register to register instructions: Register-Type.
    \item
      \textbf{I}: Memory and Branch instructions: Immediate-Type.
    \item
      \textbf{J}: Jump instructions: Jump-Type
  \end{enumerate}

  Note that a branch instruction is a conditional jump while a jump
  instruction is an uncontional jump.
\end{frame}

% 2)

\begin{frame}
  \frametitle{Register Format}

  \begin{center}
    \pgfuseimage{r-format}
  \end{center}

  \begin{itemize}[<+->]
    \item
      \textbf{OPCODE}: the operation code.
    \item
      \textbf{RS}: the source register.
    \item
      \textbf{RT}: the alternative register: source/destination.
    \item
      \textbf{RD}: the destination register.
    \item
      \textbf{SHAM}: \textbf{SH}ift \textbf{AM}ount: used by
      shift instructions.
    \item
      \textbf{FUNC}: this function field is used to extend the number
      of available opcodes. Remember that opcode is an expensive resource.
  \end{itemize}
\end{frame}

% 3)

\begin{frame}
  \frametitle{Examples}

  Let's see some examples of register to register instructions.

  \begin{itemize}[<+->]
    \item
      Add Rd, Rs, Rt
    \item
      Addu Rd, Rs, Rt
    \item
      Sllv Rd, Rt, Rs
    \item
      Srl Rd, Rt, sham
  \end{itemize}
\end{frame}

% 4)

\begin{frame}
  \frametitle{Immediate Format}

  \begin{center}
    \pgfuseimage{i-format}
  \end{center}

  \begin{itemize}[<+->]
    \item
      \textbf{OPCODE}: the operation code.
    \item
      \textbf{RS}: the source register.
    \item
      \textbf{RT}: the alternative register: source/destination.
    \item
      \textbf{IMMED}: an immediate value.
  \end{itemize}
\end{frame}

% 5)

\begin{frame}
  \frametitle{Examples}

  Let's see some examples of immediate instructions.

  \begin{itemize}[<+->]
    \item
      Addi Rd, Rs, Immed
    \item
      Addiu Rd, Rs, Immed
    \item
      Andi Rd, Rs, Immed
    \item
      Ori Rd, Rs, Immed
  \end{itemize}
\end{frame}

% 6)

\begin{frame}
  \frametitle{Jump Format}

  \begin{center}
    \pgfuseimage{j-format}
  \end{center}

  \begin{itemize}[<+->]
    \item
      \textbf{OPCODE}: the operation code.
    \item
      \textbf{IMMED}: immediate value.
  \end{itemize}
\end{frame}

% 7)

\begin{frame}
  \frametitle{Examples}

  Let's see some examples of jump instructions.

  \begin{itemize}[<+->]
    \item
      J Immed
  \end{itemize}
\end{frame}

% 8)

\begin{frame}[containsverbatim]
  \frametitle{Opcodes}

  We saw that the opcode field took 6 bits.

  \nl

  We also saw that the register-type instructions had a function field
  to extend the number of opcodes. So a value for the opcode field is
  dedicated to the use of the function extended field.

  \nl

  This specific opcode value is zerp: \textbf{000 000}

  \nl

  So the number of opcode available on the MIPS is:

  \begin{verbatim}
    opcodes =   opcode field - 1   +   function field
            =    (2 ^ 6) - 1       +     (2 ^ 6)
            =        63            +       64

            =   127
  \end{verbatim}
\end{frame}

%
% instructions
%

\section{Instructions}

% 1)

\begin{frame}
  \frametitle{Arithmetic and Logic instructions}

  We will see how the processor interprets different instructions.

  \nl

  The processor also divides the instructions into two subcategories:
  the arithmetic instructions and the logic instructions.

  \nl

  Briefly, the arithmetic instructions handles overflow while logic
  one do not.

  \nl

  The MIPS processor is composed of \textbf{57 instructions}:

  \begin{itemize}[<+->]
    \item
      \textbf{33} arithmetic and logic register-type instructions.
    \item
      \textbf{12} branch instructions.
    \item
      \textbf{7} memory access instructions.
    \item
      \textbf{5} system instructions.
  \end{itemize}

  \nl

  MIPS instructions are coded on 32-bit.
\end{frame}

% 2)

\begin{frame}
  \frametitle{Overflow Avoiding}

  Let's take the \textbf{Andi Rt, Rs, Immed} immediate-type
  instruction as example.

  \nl

  Not that overflow is ignored with logic instructions and with
  specific unsigned instructions (\textbf{u} suffixed) like:
  Addiu, Srl, Subu etc..

  \nl

  So in the case of the \textbf{Andi} instruction which is a logic instruction,
  the immediate will be interpreted as an unsigned value.

  \nl

  The 16-bit immediate value will be expanded to a 32-bit one just
  filling the 16 higher bits with zeros.

  \begin{center}
    \pgfuseimage{overflow-avoiding}
  \end{center}
\end{frame}

% 3)

\begin{frame}
  \frametitle{Overflow Handling}

  Let's take the \textbf{Addi Rt, Rs, Immed} immediate-type
  instruction as an example of a arithmetic one.

  \nl

  The non-presence of the \textbf{u} suffix introduces the overflow
  handling. This means that the immediate value will be considered
  as a signed value.

  \nl

  So, the signed value will be expanded as a 32-bit value taking care
  to report the sign bit.

  \begin{center}
    \pgfuseimage{overflow-handling}
  \end{center}
\end{frame}

% 4)

\begin{frame}[containsverbatim]
  \frametitle{Immediate Limitations}

  Let's see a common problem due to the immediate field limitations.

  \nl

  How to move the 32-bit value \textbf{0x87654321} into the R1 register.

  \begin{verbatim}
    Addi R1, R0, 0x8765
    Sll R1, R1, 16
    Addi R1, R1, 0x4321
  \end{verbatim}

  This operation being very useful, the designers of the MIPS processor
  decided to add a new instruction named \textbf{Lui} which do
  exactly the:

  \begin{itemize}
    \item
      Add Rn, R0, Immed
      Sll Rn, Rn, 16
  \end{itemize}
\end{frame}

% 5)

\begin{frame}[containsverbatim]
  \frametitle{Another Problem}

  Let's take a closer look to the sequence of these three instructions:

  \begin{verbatim}
    Addi R1, R0, 0x4567
    Sll R1, R1, 16
    Addi R1, R1, 0x89ab
  \end{verbatim}

  This sequence seems correct but it is not. Remember that the arithmetic
  operations handle the overflow. In other terms, the operands of
  arithmetic operations are considered as signed integers.

  \nl

  The value \textbf{0x89ab} is equivalent to the binary value:
  \textbf{1000100110101011}.

  \nl

  You can notive that the higher bit is set so this number will be considered
  as a signed integer.

  \nl

  The solution is simply to prefere a logic operation:

  \begin{verbatim}
    Addi R1, R0, 0x4567
    Sll R1, R1, 16
    Ori R1, R1, 0x89ab
  \end{verbatim}
\end{frame}

% 6)

\begin{frame}
  \frametitle{Memory Access}

  Memory accesses can be made for bytes, half-words and words.

  \nl

  The MIPS processor always aligns the data to the right of the registers.

  \begin{center}
    \pgfuseimage{memory-access}
  \end{center}
\end{frame}

% 7)

\begin{frame}[containsverbatim]
  \frametitle{Examples}

  These are other examples of memory instructions.

  \begin{verbatim}
    Lh Rt, Immed(Rs)
    Lhu Rt, Immed(Rs)
    Lw Rt, Immed(Rs)
    Sbu Rt, Immed(Rs)
    Sw Rt, Immed(Rs)
  \end{verbatim}
\end{frame}

% 8)

\begin{frame}
  \frametitle{Jump Instructions}

  Remember that we call branch instructions the conditional jumps
  and the jump instructions the unconditional ones.

  \nl

  Let's take the example of the \textbf{J} instruction. Remember that
  this instruction is of jump-type so is composed of 6 bits of opcode
  and 26 bits of immediate value.

  \begin{center}
    \pgfuseimage{jump-instruction}
  \end{center}

  This alignment system permit to access 256 Mb while each memory segment
  has a 256 Mb size.
\end{frame}

% 9)

\begin{frame}[containsverbatim]
  \frametitle{Examples}

  Let's see other jump instructions:

  \begin{verbatim}
    Jr Rs
    Jal Immed
    Jalr Rs
  \end{verbatim}

  To return from a subprogram we just has to do:

  \begin{verbatim}
    Jr R31
  \end{verbatim}
\end{frame}

% 10)

\begin{frame}[containsverbatim]
  \frametitle{Branch Instructions}

  Let's take as example the instruction: \textbf{Beq Rs, Rt, Label}.

  \begin{enumerate}
    \item
      \textbf{Rs == Rt}: the next instruction address will be the label.
    \item
      \textbf{Rs != Rt}: the next instruction address is simply the following
      so the current instruction address plus four bytes.
  \end{enumerate}

  In the case of a successful branch, the new instruction address calculated
  like this:

  \begin{verbatim}
    address = branch address + 4 + (Immediate >> 2)
  \end{verbatim}

  You can notice that the immediate will be interpreted as a signed value.

  \nl

  This is useful to permit forward an backward jumps.
\end{frame}

% 11)

\begin{frame}[containsverbatim]
  \frametitle{Examples}

  Let's see some examples of branch instructions.

  \begin{verbatim}
    Bne Rs, Rt, Immed
    Bltz Rs, Immed
    Blez Rs, Immed
    Bgtz Rs, Immed
    Bgez Rs, Immed
  \end{verbatim}
\end{frame}

% 12)

\begin{frame}
  \frametitle{Designers Choices}

  We saw the different type and instructions of the MIPS processor. But
  why the designers decided to provide this instruction but not this one?

  \nl

  First of all, the instructions set is not build without reflexion
  but on statistics, rules and logic:

  \begin{itemize}[<+->]
    \item
      \textbf{MIX}
    \item
      \textbf{Amdhal Rule}
  \end{itemize}
\end{frame}

% 13)

\begin{frame}[containsverbatim]
  \frametitle{MIX}

  The MIXs are kind of statistics made by researchers and companies.

  \nl

  The MIXs classify, sort the instructions by their use frequency.

  \nl

  For example the instruction \textbf{Strlen Rd, Rs} which computes
  the length of the string located at \textbf{Rs} and store the result
  into \textbf{Rd} may be used for example 1 percent of the execution
  time of a process.

  \nl

  In this case, if the designers decide to not implement this instruction
  what will they lose?

  \nl

  Consider that this instruction running in two one cycle can be replaced
  by for example two other instructions each running in one cycle.

  \begin{verbatim}
    loss =   cycles loss   *   use frequency
         =      50%       *       1%

         =   0.005

         =   0.5%
  \end{verbatim}

  The MIXs can help to detect instructions with very low use frequencies, so
  the designers can decide not to include these instructions in the
  processor's instructions set.
\end{frame}

% 14)

\begin{frame}[containsverbatim]
  \frametitle{Amdhal Rule}

  The Amdhal Rule says:

  \nl

  \textbf{``The real benefit depends on the cost.''}

  \nl

  Let's take a well-known analogy:

  \begin{center}
    \pgfuseimage{amdhal-rule}
  \end{center}

  To conclude:

  \begin{verbatim}
    real earning = earning * use frequency
  \end{verbatim}
\end{frame}

% 15)

\begin{frame}[containsverbatim]
  \frametitle{RISC Performance Rules}

  The two characteristics which make a processor performant are:

  \begin{itemize}[<+->]
    \item
      number of cycles per instruction
    \item
      clock frequency
  \end{itemize}

  So the processor performance can be computed as below:

  \begin{verbatim}
    performance =   frequency   /   number of cyles per instruction

                =      F        /        CPI
  \end{verbatim}

  We will try to build a CPI equals to 1 leading to a coherent and peformant
  RISC processor.
\end{frame}

% 16)

\begin{frame}
  \frametitle{Questions}

  Any question?

  \begin{itemize}[<+->]
    \item
      Why the \textbf{Subi} instruction does not exist?
    \item
      Why the \textbf{Jr} instruction is a register-type instruction
      while its goal is to perform a jump?
    \item
      Why the \textbf{Nori} instruction does not exist?
    \item
      Why the \textbf{Sll} instruction is a register-type instruction
      while it uses an immediate?
  \end{itemize}

  The answers are:

  \begin{itemize}[<+->]
    \item
      Opcode is a very expensive resource.
    \item
      Most instructions are useless because the designed operation can be
      made with another instruction.
    \item
      \textbf{MIXs} are used to design the instruction set with these
      two rules.
  \end{itemize}
\end{frame}

%
% addressing
%

\section{Addressing}

% 1)

\begin{frame}
  \frametitle{Overview}

  The MIPS processor does not have any virtual memory in its basic
  realisation.

  \nl

  More complex versions do have but we will only study basic ones to
  avoid complex pipelines.

  \nl

  Addresses are represented by 32-bit integers.

  \nl

  The memory accesses must be aligned, meaning that the object's address
  (byte, half-word, word) must always be a multiple of the object size.

  \nl

  For example an half-word must always be accessed on an address multiple
  of two.
\end{frame}

% 2)

\begin{frame}
  \frametitle{Endianness}

  The MIPS RISC processor uses the little-endian memory organisation.

  \begin{center}
    \pgfuseimage{endianness}
  \end{center}
\end{frame}

% 3)

\begin{frame}
  \frametitle{Memory Layout}

  The memory is segmented to divise the address space into two segments.

  \begin{center}
    \pgfuseimage{memory-layout}
  \end{center}
\end{frame}

%
% pipeline
%

\section{Pipeline}

% 1)

\begin{frame}
  \frametitle{Execution Context}

  We will study in the section the different instructions from another
  point of view to extract a generic execution context.

  \nl

  Then, having an execution context, we will be able to study the pipeline
  and each instruction in it.

\end{frame}

% 2)

\begin{frame}
  \frametitle{Add Rd, Rs, Rt}

  \begin{enumerate}[<+->]
    \item
      Reads the instruction.
    \item
      Decodes the operands.
    \item
      Extracts the operands: \textbf{Rs}, \textbf{Rt}
    \item
      Performs the operation: \textbf{+}.
    \item
      
    \item
      Writes the result: \textbf{Rd}
    \item
      Computes the next instruction address.
  \end{enumerate}
\end{frame}

% 3)

\begin{frame}
  \frametitle{Lw Rt, Immed(Rs)}

  \begin{enumerate}[<+->]
    \item
      Reads the instruction.
    \item
      Decodes the operands.
    \item
      Extracts the operands: \textbf{Immed}, \textbf{Rt}
    \item
      Performs the operation: \textbf{+}.
    \item
      Memory access: read.
    \item
      Writes the result: \textbf{Rd}
    \item
      Computes the next instruction address.
  \end{enumerate}
\end{frame}

% 2)

\begin{frame}
  \frametitle{Sw Rt, I(Rs)}

  \begin{enumerate}[<+->]
    \item
      Reads the instruction.
    \item
      Decodes the operands.
    \item
      Extracts the operands: \textbf{Immed}, \textbf{Rt}
    \item
      Performs the operation: \textbf{+}.
    \item
      Memory access: write.
    \item

    \item
      Computes the next instruction address.
  \end{enumerate}
\end{frame}

% 2)

\begin{frame}
  \frametitle{Jr Rs}

  \begin{enumerate}[<+->]
    \item
      Reads the instruction.
    \item
      Decodes the operands.
    \item
      Extracts the operands: \textbf{Rs}
    \item

    \item
      
    \item

    \item
      Computes the next instruction address.
  \end{enumerate}
\end{frame}

%
% bibliography
%

\section{Bibliography}

\begin{thebibliography}{3}

  \bibitem{Howto}
    GNU C Preprocessor Howto

  \bibitem{Queue}
    Queue.h
    \newblock /usr/include/sys/queue.h
    \newblock A linked-list manager using macros
\end{thebibliography}

\end{document}
