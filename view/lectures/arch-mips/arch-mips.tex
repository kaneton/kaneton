%%
%% licence       kaneton licence
%%
%% project       kaneton
%%
%% file          /home/mycure/kaneton/view/lectures/arch-mips/arch-mips.tex
%%
%% created       julien quintard   [wed nov 23 22:07:25 2005]
%% updated       julien quintard   [sat nov 26 22:09:41 2005]
%%

%
% template
%

\input{../../templates/lecture.tex}

%
% title
%

\title{MIPS Architectures}

%
% authors
%

\author
{
  Julien~Quintard\inst{1}
}

%
% figures
%

\pgfdeclareimage[interpolate=true,width=188pt,height=97pt]
                {philosophies}
		{figures/philosophies}

\pgfdeclareimage[interpolate=true,width=166pt,height=26pt]
                {r-format}
		{figures/r-format}
\pgfdeclareimage[interpolate=true,width=166pt,height=26pt]
                {i-format}
		{figures/i-format}
\pgfdeclareimage[interpolate=true,width=166pt,height=26pt]
                {j-format}
		{figures/j-format}

\pgfdeclareimage[interpolate=true,width=166pt,height=46pt]
                {overflow-handling}
		{figures/overflow-handling}
\pgfdeclareimage[interpolate=true,width=166pt,height=46pt]
                {overflow-avoiding}
		{figures/overflow-avoiding}

\pgfdeclareimage[interpolate=true,width=270pt,height=129pt]
                {endianness}
		{figures/endianness}
\pgfdeclareimage[interpolate=true,width=82pt,height=129pt]
                {memory-layout}
		{figures/memory-layout}
\pgfdeclareimage[interpolate=true,width=270pt,height=129pt]
                {memory-access}
		{figures/memory-access}

\pgfdeclareimage[interpolate=true,width=178pt,height=79pt]
                {jump-instruction}
		{figures/jump-instruction}

\pgfdeclareimage[interpolate=true,width=163pt,height=45pt]
                {amdhal-rule}
		{figures/amdhal-rule}

\pgfdeclareimage[interpolate=true,width=163pt,height=92pt]
                {pipeline-overview}
		{figures/pipeline-overview}
\pgfdeclareimage[interpolate=true,width=196pt,height=90pt]
                {pipeline-balancing}
		{figures/pipeline-balancing}
\pgfdeclareimage[interpolate=true,width=172pt,height=105pt]
                {moore-law}
		{figures/moore-law}
\pgfdeclareimage[interpolate=true,width=224pt,height=135pt]
                {pipeline-views}
		{figures/pipeline-views}
\pgfdeclareimage[interpolate=true,width=156pt,height=180pt]
                {detailed-pipeline}
		{figures/detailed-pipeline}
\pgfdeclareimage[interpolate=true,width=56pt,height=68pt]
                {next-instruction-stream}
		{figures/next-instruction-stream}
\pgfdeclareimage[interpolate=true,width=75pt,height=144pt]
                {decode-branch}
		{figures/decode-branch}
\pgfdeclareimage[interpolate=true,width=247pt,height=91pt]
                {decode-multiplexer}
		{figures/decode-multiplexer}
\pgfdeclareimage[interpolate=true,width=157pt,height=86pt]
                {comparison-decode-execute-1}
		{figures/comparison-decode-execute-1}
\pgfdeclareimage[interpolate=true,width=139pt,height=116pt]
                {comparison-decode-execute-2}
		{figures/comparison-decode-execute-2}
\pgfdeclareimage[interpolate=true,width=103pt,height=121pt]
                {comparison-decode-execute-3}
		{figures/comparison-decode-execute-3}
\pgfdeclareimage[interpolate=true,width=75pt,height=144pt]
                {decode-stage}
		{figures/decode-stage}

%
% document
%

\begin{document}

%
% title frame
%

\begin{frame}
  \titlepage

  \begin{center}
    \logos
  \end{center}
\end{frame}

%
% outline frame
%

\begin{frame}
  \frametitle{Outline}
  \tableofcontents
\end{frame}

%
% introduction
%

\section{Introduction}

% 1)

\begin{frame}
  \frametitle{Description}

  \begin{itemize}[<+->]
    \item
      About \textbf{thirty} course hours.
    \item
      Concluded by an exam.
  \end{itemize}
\end{frame}

% 2)

\begin{frame}
  \frametitle{Contents}

  \begin{itemize}[<+->]
    \item
      External architecture.
    \item
      Pipeline.
    \item
      Compiler optimisations.
    \item
      Memory.
  \end{itemize}
\end{frame}

%
% history
%

XXX

%
% overview
%

\section{Overview}

% 1)

\begin{frame}
  \frametitle{Introduction}

  An architecture is composed of:

  \begin{itemize}[<+->]
    \item
      Visible registers.
    \item
      Instructions set.
    \item
      Addressing.
    \item
      Interrupts/exceptions system.
  \end{itemize}
\end{frame}

% 2)

\begin{frame}
  \frametitle{Description}

  The MIPS processor is a 32-bit little-endian processor.

  \nl

  This processor provides \textbf{32 integer registers}, from R0 to R31.

  \nl

  Nevertheless two registers have special meaning:

  \begin{itemize}[<+->]
    \item
      \textbf{R0}: Trash Register: this register when read returns zero and
      writtings are ignored.
    \item
      \textbf{R31}: Link Register: this register holds the return address
      of a subprogram.
  \end{itemize}
\end{frame}

% 3)

\begin{frame}
  \frametitle{Special Registers}

  There are other special registers:

  \begin{itemize}[<+->]
    \item
      \textbf{HI and LO} are used for multiplications and division.
  \end{itemize}

  The MIPS precessor has four registers very interesting for system
  programming:

  \begin{itemize}[<+->]
    \item
      \textbf{SR}: Status Register: used to distinguish the two context
      modes: user and supervisor.
    \item
      \textbf{CAUSE}: holds the cause of the interrupt/exception.
    \item
      \textbf{EPC}: Exception Program Counter: holds the program counter
      of the instruction that caused the exception.
    \item
      \textbf{BAR}: Bad Address Register: holds the address that cause
      the memory error.
  \end{itemize}
\end{frame}

% 3)

\begin{frame}
  \frametitle{RISC}

  While inventors of RISC said:

  \nl

  \textbf{``Reduced Instruction Set Computer''}

  \nl

  Other people said that was false and that the true definition was:

  \nl

  \textbf{``Reject Important Stuff into Compiler''}

  \nl

  These notices tend to explain the real goal of this processor.
\end{frame}

% 4)

\begin{frame}[containsverbatim]
  \frametitle{RISC vs CISC}

  Let's take an example to compare the assembly language of CISC and RISC
  processors.

  \nl

  We want to perform the operation below:

  \begin{verbatim}
    int         res;
    int         a = 21;
    int         b = 42;

    res = a + b;
  \end{verbatim}

  On CISC processors:

  \begin{verbatim}
    add [res], [a], [b]
  \end{verbatim}

  On RISC processors:

  \begin{verbatim}
    Lw R4, [a]
    Lw R5, [b]
    Add R6, R4, R5
    Sw R6, [res]
  \end{verbatim}

  You can easily notice that CISC processors have only one instruction while
  RISC processors have four instructions.
\end{frame}

% 4)

\begin{frame}
  \frametitle{Position of Assembly from High Level Languages}

  During fifty's, CISC processors do not stop trying to provide
  more and more complex instructions to fit the high levels programming
  languages requirements.

  \nl

  RISC designers tried to do the exact opposite thing, to always stay
  near the hardware language.

  \nl

  Indeed, RISC designers thought that while a CISC instruction ran in
  for example 4 cycles, a RISC processor would be able to run the
  equivalent three instruction each taking 1 cycle.
\end{frame}

% 5)

\begin{frame}
  \frametitle{Philosophies}

  \begin{center}
    \pgfuseimage{philosophies}
  \end{center}
\end{frame}

%
% instruction formats
%

\section{Instruction Formats}

% 1)

\begin{frame}
  \frametitle{Overview}

  The MIPS processor classifies its 57 instructions into three groups.

  \begin{enumerate}[<+->]
    \item
      \textbf{R}: Register to register instructions: Register-Type.
    \item
      \textbf{I}: Memory and Branch instructions: Immediate-Type.
    \item
      \textbf{J}: Jump instructions: Jump-Type
  \end{enumerate}

  Note that a branch instruction is a conditional jump while a jump
  instruction is an uncontional jump.
\end{frame}

% 2)

\begin{frame}
  \frametitle{Register Format}

  \begin{center}
    \pgfuseimage{r-format}
  \end{center}

  \begin{itemize}[<+->]
    \item
      \textbf{OPCODE}: the operation code.
    \item
      \textbf{RS}: the source register.
    \item
      \textbf{RT}: the alternative register: source/destination.
    \item
      \textbf{RD}: the destination register.
    \item
      \textbf{SHAM}: \textbf{SH}ift \textbf{AM}ount: used by
      shift instructions.
    \item
      \textbf{FUNC}: this function field is used to extend the number
      of available opcodes. Remember that opcode is an expensive resource.
  \end{itemize}
\end{frame}

% 3)

\begin{frame}
  \frametitle{Examples}

  Let's see some examples of register to register instructions.

  \begin{itemize}[<+->]
    \item
      Add Rd, Rs, Rt
    \item
      Addu Rd, Rs, Rt
    \item
      Sllv Rd, Rt, Rs
    \item
      Srl Rd, Rt, sham
  \end{itemize}
\end{frame}

% 4)

\begin{frame}
  \frametitle{Immediate Format}

  \begin{center}
    \pgfuseimage{i-format}
  \end{center}

  \begin{itemize}[<+->]
    \item
      \textbf{OPCODE}: the operation code.
    \item
      \textbf{RS}: the source register.
    \item
      \textbf{RT}: the alternative register: source/destination.
    \item
      \textbf{IMMED}: an immediate value.
  \end{itemize}
\end{frame}

% 5)

\begin{frame}
  \frametitle{Examples}

  Let's see some examples of immediate instructions.

  \begin{itemize}[<+->]
    \item
      Addi Rd, Rs, Immed
    \item
      Addiu Rd, Rs, Immed
    \item
      Andi Rd, Rs, Immed
    \item
      Ori Rd, Rs, Immed
  \end{itemize}
\end{frame}

% 6)

\begin{frame}
  \frametitle{Jump Format}

  \begin{center}
    \pgfuseimage{j-format}
  \end{center}

  \begin{itemize}[<+->]
    \item
      \textbf{OPCODE}: the operation code.
    \item
      \textbf{IMMED}: immediate value.
  \end{itemize}
\end{frame}

% 7)

\begin{frame}
  \frametitle{Examples}

  Let's see some examples of jump instructions.

  \begin{itemize}[<+->]
    \item
      J Immed
  \end{itemize}
\end{frame}

% 8)

\begin{frame}[containsverbatim]
  \frametitle{Opcodes}

  We saw that the opcode field took 6 bits.

  \nl

  We also saw that the register-type instructions had a function field
  to extend the number of opcodes. So a value for the opcode field is
  dedicated to the use of the function extended field.

  \nl

  This specific opcode value is zerp: \textbf{000 000}

  \nl

  So the number of opcode available on the MIPS is:

  \begin{verbatim}
    opcodes =   opcode field - 1   +   function field
            =    (2 ^ 6) - 1       +     (2 ^ 6)
            =        63            +       64

            =   127
  \end{verbatim}
\end{frame}

%
% 9)
%

\begin{frame}[containsverbatim]
  \frametitle{int \textbf{strlen}(const char* string);}

  \begin{verbatim}
          Lw R5, 0(R29)                 ; R5 <- string

          Addi R3, R5, 1                ; R3 <- string + 1

    Loop: Lb R4, 0(R5)                  ; R4 <- *string
          Addiu R5, R5, 1               ; R5 <- string++
          Bne R4, R0, loop              ; while (*string != 0)

          Sub R2, R5, R3                ; R2 <- R5 - R3

          Jr R31                        ; return
  \end{verbatim}

  \textbf{Result}: 2 + N * 3 + 3 + 2 cycles
\end{frame}

%
% instructions
%

\section{Instructions}

% 1)

\begin{frame}
  \frametitle{Arithmetic and Logic instructions}

  We will see how the processor interprets different instructions.

  \nl

  The processor also divides the instructions into two subcategories:
  the arithmetic instructions and the logic instructions.

  \nl

  Briefly, the arithmetic instructions handles overflow while logic
  one do not.

  \nl

  The MIPS processor is composed of \textbf{57 instructions}:

  \begin{itemize}[<+->]
    \item
      \textbf{33} arithmetic and logic register-type instructions.
    \item
      \textbf{12} branch instructions.
    \item
      \textbf{7} memory access instructions.
    \item
      \textbf{5} system instructions.
  \end{itemize}

  \nl

  MIPS instructions are coded on 32-bit.
\end{frame}

% 2)

\begin{frame}
  \frametitle{Overflow Avoiding}

  Let's take the \textbf{Andi Rt, Rs, Immed} immediate-type
  instruction as example.

  \nl

  Not that overflow is ignored with logic instructions and with
  specific unsigned instructions (\textbf{u} suffixed) like:
  Addiu, Srl, Subu etc..

  \nl

  So in the case of the \textbf{Andi} instruction which is a logic instruction,
  the immediate will be interpreted as an unsigned value.

  \nl

  The 16-bit immediate value will be expanded to a 32-bit one just
  filling the 16 higher bits with zeros.

  \begin{center}
    \pgfuseimage{overflow-avoiding}
  \end{center}
\end{frame}

% 3)

\begin{frame}
  \frametitle{Overflow Handling}

  Let's take the \textbf{Addi Rt, Rs, Immed} immediate-type
  instruction as an example of a arithmetic one.

  \nl

  The non-presence of the \textbf{u} suffix introduces the overflow
  handling. This means that the immediate value will be considered
  as a signed value.

  \nl

  So, the signed value will be expanded as a 32-bit value taking care
  to report the sign bit.

  \begin{center}
    \pgfuseimage{overflow-handling}
  \end{center}
\end{frame}

% 4)

\begin{frame}[containsverbatim]
  \frametitle{Immediate Limitations}

  Let's see a common problem due to the immediate field limitations.

  \nl

  How to move the 32-bit value \textbf{0x87654321} into the R1 register.

  \begin{verbatim}
    Addi R1, R0, 0x8765
    Sll R1, R1, 16
    Addi R1, R1, 0x4321
  \end{verbatim}

  This operation being very useful, the designers of the MIPS processor
  decided to add a new instruction named \textbf{Lui} which do
  exactly the:

  \begin{itemize}
    \item
      Add Rn, R0, Immed
    \item
      Sll Rn, Rn, 16
  \end{itemize}
\end{frame}

% 5)

\begin{frame}[containsverbatim]
  \frametitle{Another Problem}

  Let's take a closer look to the sequence of these three instructions:

  \begin{verbatim}
    Addi R1, R0, 0x4567
    Sll R1, R1, 16
    Addi R1, R1, 0x89ab
  \end{verbatim}

  This sequence seems correct but it is not. Remember that the arithmetic
  operations handle the overflow.

  \nl

  The value \textbf{0x89ab} is equivalent to the binary value:
  \textbf{1000100110101011}.

  \nl

  You can notive that the higher bit is set so this number will be considered
  as a signed integer.

  \nl

  The solution is simply to prefere a logic operation:

  \begin{verbatim}
    Addi R1, R0, 0x4567
    Sll R1, R1, 16
    Ori R1, R1, 0x89ab
  \end{verbatim}
\end{frame}

% 6)

\begin{frame}
  \frametitle{Memory Access}

  Memory accesses can be made for bytes, half-words and words.

  \nl

  The MIPS processor always aligns the data to the right of the registers.

  \begin{center}
    \pgfuseimage{memory-access}
  \end{center}
\end{frame}

% 7)

\begin{frame}[containsverbatim]
  \frametitle{Examples}

  These are other examples of memory instructions.

  \begin{verbatim}
    Lh Rt, Immed(Rs)
    Lhu Rt, Immed(Rs)
    Lw Rt, Immed(Rs)
    Sbu Rt, Immed(Rs)
    Sw Rt, Immed(Rs)
  \end{verbatim}
\end{frame}

% 8)

\begin{frame}
  \frametitle{Jump Instructions}

  Remember that we call branch instructions the conditional jumps
  and the jump instructions the unconditional ones.

  \nl

  Let's take the example of the \textbf{J} instruction. Remember that
  this instruction is of jump-type so is composed of 6 bits of opcode
  and 26 bits of immediate value.

  \begin{center}
    \pgfuseimage{jump-instruction}
  \end{center}

  This alignment system permit to access 256 Mb while each memory segment
  has a 256 Mb size.
\end{frame}

% 9)

\begin{frame}[containsverbatim]
  \frametitle{Examples}

  Let's see other jump instructions:

  \begin{verbatim}
    Jr Rs
    Jal Immed
    Jalr Rs
  \end{verbatim}

  To return from a subprogram we just has to do:

  \begin{verbatim}
    Jr R31
  \end{verbatim}
\end{frame}

% 10)

\begin{frame}[containsverbatim]
  \frametitle{Branch Instructions}

  Let's take as example the instruction: \textbf{Beq Rs, Rt, Label}.

  \begin{enumerate}
    \item
      \textbf{Rs == Rt}: the next instruction address will be the label.
    \item
      \textbf{Rs != Rt}: the next instruction address is simply the following
      so the current instruction address plus four bytes.
  \end{enumerate}

  In the case of a successful branch, the new instruction address calculated
  like this:

  \begin{verbatim}
    address = branch address + 4 + (Immediate >> 2)
  \end{verbatim}

  You can notice that the immediate will be interpreted as a signed value.

  \nl

  This is useful to permit forward an backward jumps.
\end{frame}

% 11)

\begin{frame}[containsverbatim]
  \frametitle{Examples}

  Let's see some examples of branch instructions.

  \begin{verbatim}
    Bne Rs, Rt, Immed
    Bltz Rs, Immed
    Blez Rs, Immed
    Bgtz Rs, Immed
    Bgez Rs, Immed
  \end{verbatim}
\end{frame}

% 12)

\begin{frame}
  \frametitle{Designers Choices}

  We saw the different type and instructions of the MIPS processor. But
  why the designers decided to provide this instruction but not this one?

  \nl

  First of all, the instructions set is not build without reflexion
  but on statistics, rules and logic:

  \begin{itemize}[<+->]
    \item
      \textbf{MIX}
    \item
      \textbf{Amdhal Rule}
  \end{itemize}
\end{frame}

% 13)

\begin{frame}[containsverbatim]
  \frametitle{MIX}

  The MIXs are kind of statistics made by researchers and companies.

  \nl

  The MIXs classify, sort the instructions by their use frequency.

  \nl

  For example the instruction \textbf{Strlen Rd, Rs} which computes
  the length of the string located at \textbf{Rs} and store the result
  into \textbf{Rd} may be used for example 1 percent of the execution
  time of a process.

  \nl

  In this case, if the designers decide to not implement this instruction
  what will they lose?

  \nl

  Consider that this instruction running in two one cycle can be replaced
  by for example two other instructions each running in one cycle.

  \begin{verbatim}
    loss =   cycles loss   *   use frequency
         =      50%       *       1%

         =   0.005
         =   0.5%
  \end{verbatim}

  The MIXs can help to detect instructions with very low use frequencies, so
  the designers can decide not to include these instructions in the
  processor's instructions set.
\end{frame}

% 14)

\begin{frame}[containsverbatim]
  \frametitle{Amdhal Rule}

  The Amdhal Rule says:

  \nl

  \textbf{``The real benefit depends on the cost.''}

  \nl

  Let's take a well-known analogy:

  \begin{center}
    \pgfuseimage{amdhal-rule}
  \end{center}

  To conclude:

  \begin{verbatim}
    real earning = earning * use frequency
  \end{verbatim}
\end{frame}

% 15)

\begin{frame}[containsverbatim]
  \frametitle{RISC Performance Rules}

  The two characteristics which make a processor performant are:

  \begin{itemize}[<+->]
    \item
      number of cycles per instruction
    \item
      clock frequency
  \end{itemize}

  So the processor performance can be computed as below:

  \begin{verbatim}
    performance =   frequency   /   number of cyles per instruction

                =      F        /        CPI
  \end{verbatim}

  We will try to build a CPI equals to 1 leading to a coherent and peformant
  RISC processor.
\end{frame}

% 16)

\begin{frame}
  \frametitle{Questions}

  Any question?

  \begin{itemize}[<+->]
    \item
      Why the \textbf{Subi} instruction does not exist?
    \item
      Why the \textbf{Jr} instruction is a register-type instruction
      while its goal is to perform a jump?
    \item
      Why the \textbf{Nori} instruction does not exist?
    \item
      Why the \textbf{Sll} instruction is a register-type instruction
      while it uses an immediate?
  \end{itemize}

  The answers are:

  \begin{itemize}[<+->]
    \item
      Opcode is a very expensive resource.
    \item
      Most instructions are useless because the designed operation can be
      made with another instruction.
    \item
      \textbf{MIXs} are used to design the instruction set with these
      two rules.
  \end{itemize}
\end{frame}

%
% 17)
%

\begin{frame}[containsverbatim]
  \frametitle{void \textbf{vector}(int* a, int* b, int *c, unsigned int size);}

  \begin{verbatim}
          Lw R3, 0(R29)                 ; R3 <- a
          Lw R4, 4(R29)                 ; R4 <- b
          Lw R5, 8(R29)                 ; R5 <- c
          Lw R6, 12(R29)                ; R6 <- size

          Sll R6, R6, 2                 ; R6 <- size * 4
          Add R7, R5, R6                ; R7 <- R5 + size * 4

    Loop: Lw R13, 0(R3)                 ; R13 <- *a
          Lw R14, 0(R4)                 ; R14 <- *b

          Add R15, R13, R14             ; R15 <- *a + *b
          Sll R15, R15, 1               ; R15 <- (*a + *b) * 2
          Add R15, R15, R14             ; R15 <- (*a + *b) * 2 + *b

          Sw R15, 0(R5)                 ; *c <- R15

          Addi R3, R3, 4                ; a <- a + 1
          Addi R4, R4, 4                ; b <- b + 1
          Addi R5, R5, 4                ; c <- c + 1

          Bne R5, R7, loop              ; while (R5 != R7)

          Jr R31                        ; return
  \end{verbatim}

  \textbf{Result}: 6 + N * 10 + 10 + 1 cycles
\end{frame}

%
% addressing
%

\section{Addressing}

% 1)

\begin{frame}
  \frametitle{Overview}

  The MIPS processor does not have any virtual memory in its basic
  realisation.

  \nl

  More complex versions do have but we will only study basic ones to
  avoid complex pipelines.

  \nl

  Addresses are represented by 32-bit integers.

  \nl

  The memory accesses must be aligned, meaning that the object's address
  (byte, half-word, word) must always be a multiple of the object size.

  \nl

  For example an half-word must always be accessed on an address multiple
  of two.
\end{frame}

% 2)

\begin{frame}
  \frametitle{Endianness}

  The MIPS RISC processor uses the little-endian memory organisation.

  \begin{center}
    \pgfuseimage{endianness}
  \end{center}
\end{frame}

% 3)

\begin{frame}
  \frametitle{Memory Layout}

  The memory is segmented to divise the address space into two segments.

  \begin{center}
    \pgfuseimage{memory-layout}
  \end{center}
\end{frame}

%
% pipeline
%

\section{Pipeline}

% 1)

\begin{frame}
  \frametitle{Execution Context}

  We will study in the section the different instructions from another
  point of view to extract a generic execution context.

  \nl

  Then, having an execution context, we will be able to study the pipeline
  and each instruction in it to find and solve some problems.
\end{frame}

% 2)

\begin{frame}
  \frametitle{Add Rd, Rs, Rt}

  \begin{enumerate}[<+->]
    \item
      Reads the instruction.
    \item
      Decodes the operands.
    \item
      Extracts the operands: \textbf{Rs}, \textbf{Rt}
    \item
      Performs the operation: \textbf{+}.
    \item
      
    \item
      Writes the result: \textbf{Rd}
    \item
      Computes the next instruction address.
  \end{enumerate}
\end{frame}

% 3)

\begin{frame}
  \frametitle{Lw Rt, Immed(Rs)}

  \begin{enumerate}[<+->]
    \item
      Reads the instruction.
    \item
      Decodes the operands.
    \item
      Extracts the operands: \textbf{Immed}, \textbf{Rt}
    \item
      Performs the operation: \textbf{+}.
    \item
      Memory access: read.
    \item
      Writes the result: \textbf{Rd}
    \item
      Computes the next instruction address.
  \end{enumerate}
\end{frame}

% 4)

\begin{frame}
  \frametitle{Sw Rt, I(Rs)}

  \begin{enumerate}[<+->]
    \item
      Reads the instruction.
    \item
      Decodes the operands.
    \item
      Extracts the operands: \textbf{Immed}, \textbf{Rt}
    \item
      Performs the operation: \textbf{+}.
    \item
      Memory access: write.
    \item

    \item
      Computes the next instruction address.
  \end{enumerate}
\end{frame}

% 5)

\begin{frame}
  \frametitle{Jr Rs}

  \begin{enumerate}[<+->]
    \item
      Reads the instruction.
    \item
      Decodes the operands.
    \item
      Extracts the operands: \textbf{Rs}
    \item

    \item
      
    \item

    \item
      Computes the next instruction address.
  \end{enumerate}
\end{frame}

% 6)

\begin{frame}
  \frametitle{Goal}

  The goal of a processor designer is to choose:

  \begin{itemize}[<+->]
    \item
      the instructions set.
    \item
      the execution context.
  \end{itemize}

  We saw that any MIPS instruction could be described with a simple
  seven stages execution context.
\end{frame}

% 7)

\begin{frame}
  \frametitle{Pipeline Overview}

  Let's see the stages dependencies to try to build a pipeline.

  \nl

  Pipeline technique was directly imported from hydrocarbure industry,
  using tops to separate stages.

  \begin{center}
    \pgfuseimage{pipeline-overview}
  \end{center}

  \nl

  We successfully built a pipeline with a CPI equals to 1 but
  limiting the frequency so this is not a good solution because the
  performance will not be good enough.
\end{frame}

% 8)

\begin{frame}
  \frametitle{Example}

  Let's take an example of pipeline which execute an instruction per 100 ns:
  \textbf{1 instruction / 100 ns = 10 Mhz}.

  \nl

  If we introduce in this pipeline a top to cut the pipeline in two stages,
  the instruction will be executed for example in 105 ns due to the overhead:
  \textbf{2 instruction / 105 ns = 20 Mhz}.

  \nl

  This is the beauty of the pipeline processors. More stages, more frequency
  but with more problems we will see later.

  \begin{itemize}
    \item
      \textbf{Latency}: 105 ns = 2 cycles
    \item
      \textbf{Frequency}: 1 instruction / 50 ns = 20 Mhz
    \item
      \textbf{CPI}: 1
  \end{itemize}

\end{frame}

% 9)

\begin{frame}
  \frametitle{Explanations}

  Rather than making one cyle for the entire pipeline, we will
  calibrate the clock on stages to be able to get out an instruction
  of the pipeline per cycle.

  \nl

  The tops used by the processor pipelines are registers.

  \nl

  At each clock, each register pushs its contents into the pipeline,
  to the right.

  \nl

  The stages of the pipeline \alert{must} be balanced to not slow
  down the entire pipeline.

  \nl

  Moreover a bad balancing may lead to loss of data because when the clock
  will occur the data will not be stored into the destination register yet.
\end{frame}

% 10)

\begin{frame}
  \frametitle{Balancing}

  Let's take a look to a bad balancing and it consequencies.

  \begin{center}
    \pgfuseimage{pipeline-balancing}
  \end{center}

  Be careful, tops cutting has nothing to do with execution context.

  \nl

  The rules are:

  \begin{itemize}[<+->]
    \item
      The pipeline stages must be balanced.
    \item
      The frequency must always be balanced on the largest stage.
  \end{itemize}
\end{frame}

% 11)

\begin{frame}
  \frametitle{Pipeline}

  The designers of the MIPS processor decided to cut the pipeline as
  shown below.

  \nl

  This is the real MIPS pipeline from 1980.

  \begin{enumerate}
    \item
      \textbf{IFC}: Instruction Fetch: the instruction is read from the
      memory
    \item
      \textbf{DEC}: Instruction Decode: the operands are decoded and
      extracted while the next instruction address is computed.
    \item
      \textbf{EXE}: Execute: an operation is performed.
    \item
      \textbf{MEM}: Memory: a data memory access is made.
    \item
      \textbf{WBK}: Write Back: the result is stored into a destination
      register.
  \end{enumerate}
\end{frame}

% 12)

\begin{frame}
  \frametitle{Moore Law}

  The remaining question is: what is the largest stage in this pipeline.

  \nl

  The Moore Law shows that processors frequency will grow exponentially,
  but what is the memory evolution?

  \begin{center}
    \pgfuseimage{moore-law}
  \end{center}
\end{frame}

% 13)

\begin{frame}
  \frametitle{Largest Stage}

  So the largest pipeline stages will be IFC and MEM which do memory
  accesses.

  \nl

  Note that such a pipeline will not be possible nowadays because of the
  Moore law. The difference between the processor and memory speed
  is constantly inscreasing.

  \nl

  For example, a good idea for a modern processor would be to cut the
  MEM stage into three sub-stages.
\end{frame}

% 14)

\begin{frame}
  \frametitle{Pipeline Views}

  We can watch a pipeline from to different views:

  \begin{center}
    \pgfuseimage{pipeline-views}
  \end{center}

  \begin{itemize}
    \item
      The first describes an instruction state.
    \item
      The second describes the pipeline state.
  \end{itemize}
\end{frame}

% 15)

\begin{frame}
  \frametitle{Hardware}

  We saw that the pipeline technique leads to very good performances because
  an instruction gets out every cycle.

  \nl

  Nevertheless this performance does not come without problems.

  \nl

  First of all, the hardware must be duplicated because a hardware must
  be specific to a stage to avoid overwrittings.

  \nl

  In other words stages are composed of inputs and outputs registers.

  \nl

  This is for the same reason that there are two distinct memory threads
  to access memory instructions and memory data because the IFC and MEM
  stages have to access memory at the same time:

  \begin{itemize}[<+->]
    \item
      \textbf{Instruction-Access}: location of the memory instruction.
    \item
      \textbf{Instruction}: instruction.
    \item
      \textbf{Data-Access}: location of the memory object.
    \item
      \textbf{Data}: object.
  \end{itemize}
\end{frame}

% 16)

\begin{frame}
  \frametitle{Pipeline Rules}

  These are the rules to follow to build a correct pipeline:

  \begin{enumerate}[<+->]
    \item
      Stages must be balanced.
    \item
      Stages must be separated by registers.
    \item
      Hardware must be specificly used by a stage and never by another.
  \end{enumerate}

  \nl

  Notice that registers largely compose a processor.
\end{frame}

% 17)

\begin{frame}
  \frametitle{Detailed Pipeline}

  \begin{center}
    \pgfuseimage{detailed-pipeline}
  \end{center}
\end{frame}

% 18)

\begin{frame}
  \frametitle{Exercices}

  Make the detailed pipeline for these instructions:

  \begin{itemize}[<+->]
    \item
      \textbf{Sllv Rd, Rs, Rt}: nothing special
    \item
      \textbf{Lw Rd, Immed(Rs)}: multiplexer: RES or memory data into DATA.
  \end{itemize}
\end{frame}

% 19)

\begin{frame}
  \frametitle{Next Instruction Address}

  Let's take a closer look to the next instruction address computation.

  \nl

  The next instruction is computed in the DEC stage. So between
  the time the instruction gets in the pipeline and its next instruction
  address computation, one instruction was added to the pipeline.

  \begin{center}
    \pgfuseimage{next-instruction-stream}
  \end{center}

  \nl

  When performing a branch the pipeline will contain an unwanted
  instruction.

  \nl

  This unwanted instruction is called \textbf{delay slot}.
\end{frame}

% 20)

\begin{frame}
  \frametitle{Delay Slot}

  There are two solutions to solve the delay slot problem:

  \begin{itemize}[<+->]
    \item
      Just do not touch to this instruction which will be executed
      in the pipeline.
    \item
      Cancel, remove this instruction from the pipeline.
  \end{itemize}
\end{frame}

% 21)

\begin{frame}
  \frametitle{Solution}

  The solution is to reject important stuff into the compiler.

  \nl

  Researchs made showed that the compiler is able to fill one delay
  slot in 75 percent of cases and to fill two delay slots in only
  5 percent of cases. After that there is no chance to fill the delay
  slots.

  \nl

  After that, if a compiler is not able to fill the delay slots
  with useful instructions it will inserts a NOP instruction to avoid
  problems.

  \nl

  Question: \textbf{What are the consequences if we put the next
    instruction address computation into the EXE stage?}
\end{frame}

% 22)

\begin{frame}
  \frametitle{Next Instruction Address Computation}

  Let's review the next instruction address formula:

  \nl

  There are two cases:

  \begin{itemize}[<+->]
    \item
      \textbf{Rs == Rt}: target address = branch address + 4 + Immed * 4
    \item
      \textbf{Rs != Rt}: target address = next instruction address
  \end{itemize}

  \nl

  First of all, the part of the formula: \textbf{branch address + 4}
  was already computed between the IFC stage and the DEC stage because
  the previous instruction computed the next instruction address.
\end{frame}

% 23)

\begin{frame}
  \frametitle{DEC stage}

  We saw that the DEC stage had to decode and extract operands while
  computing the next instruction address.

  \begin{center}
    \pgfuseimage{decode-branch}
  \end{center}
\end{frame}

% 24)

\begin{frame}
  \frametitle{Very Bad Balancing}

  We can notice that the stages balancing is absolutly not respected.

  \nl

  Indeed, while the EXE stage performs an addition, the DEC stage performs:

  \begin{itemize}[<+->]
    \item
      \textbf{Multiplication}: Immed * 4
    \item
      \textbf{Comparison}
    \item
      \textbf{Multiplexer}
    \item
      \textbf{Addition}: Multiplixer result + instruction address
  \end{itemize}

  \nl

  So we have to find solutions to balance this stage with others.
\end{frame}

% 25)

\begin{frame}
  \frametitle{Multiplication Solution}

  First of all, we can handle the multiplication \textbf{Immed * 4}
  in a more quickly way.

  \nl

  In fact, this muliplication operation will takes exactly zero time
  to compute.

  \nl

  This solution is to add an hardware just to perform a multiplexing
  between a multiplication by four and the number four.

  \begin{center}
    \pgfuseimage{decode-multiplexer}
  \end{center}
\end{frame}

% 26)

\begin{frame}
  \frametitle{Still Problem}

  We success to optimise the multiplication so let's now compare the
  two stages DEC and EXE.

  \begin{center}
    \pgfuseimage{comparison-decode-execute-1}
  \end{center}
\end{frame}

% 27)

\begin{frame}
  \frametitle{Parallel Computations}

  We could parallelise the computations for the addition and the
  other stuff and then perform the multiplexing.

  \begin{center}
    \pgfuseimage{comparison-decode-execute-2}
  \end{center}
\end{frame}

% 28)

\begin{frame}
  \frametitle{Instruction Formats' Beauty}

  You must had noticed that the different instruction formats all placed
  the source register and the alternative register at the same offsets.

  \nl

  The result effect is that we are not longer forced to wait the decode
  operations because the can directly extract the operands to perform
  the comparison.

  \begin{center}
    \pgfuseimage{comparison-decode-execute-3}
  \end{center}

  The result is almost perfect.
\end{frame}

% 29)

\begin{frame}
  \frametitle{Strutural Problem Resolved}

  Let's see the DEC stage in its final state.

  \begin{center}
    \pgfuseimage{decode-stage}
  \end{center}
\end{frame}

% 30)

\begin{frame}[containsverbatim]
  \frametitle{But...}

  Is there any other problem?

  \nl

  Think about this sequence of instructions:

  \begin{verbatim}
          Beq R0, R0, here

    here: Beq R1, R1, anywhere
  \end{verbatim}

  \nl

  MIPS architecture specification tells that two following branchs are
  not allowed.
\end{frame}

% 31)

\begin{frame}[containsverbatim]
  \frametitle{Exercice}

  \textbf{Bltzal Rs, Label}: Branch if Less Than Zero And Link

  \nl

  This instruction computes the next instruction address and stores
  the \textbf{current address + 4} into the R31 register.

  \nl

  Note that the caller must save the R31 register on the stack before
  making any call to subprograms.

  \nl

  \begin{verbatim}
    Sw R31, X(R29)
    Branch
    Lw R31, X(29)
  \end{verbatim}
\end{frame}

%
% dependencies
%

\section{Dependencies}

% 1)

\begin{frame}
  \frametitle{Overview}

  We will see in this section that there are other inherent pipeline
  problems.

  \nl

  We will try to solve them while respecting the RISC spirit but
  this will not be always possible.
\end{frame}

% 2)

\begin{frame}
  \frametitle{XXX}

  XXX
\end{frame}

%
% optimisations
%

%
% bibliography
%

\section{Bibliography}

\begin{thebibliography}{3}

  \bibitem{Howto}
    GNU C Preprocessor Howto

  \bibitem{Queue}
    Queue.h
    \newblock /usr/include/sys/queue.h
    \newblock A linked-list manager using macros
\end{thebibliography}

\end{document}
