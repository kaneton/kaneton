%%
%% licence       kaneton licence
%%
%% project       kaneton
%%
%% file          /home/mycure/kaneton/view/lectures/seminar/seminar.tex
%%
%% created       julien quintard   [fri dec  2 07:53:59 2005]
%% updated       julien quintard   [wed feb 22 13:55:33 2006]
%%

%
% template
%

\input{../../templates/lecture.tex}

%
% title
%

\title{kaneton}

%
% authors
%

\author
{
  Julien~Quintard\inst{1}
}

%
% figures
%

\pgfdeclareimage[interpolate=true,width=223pt,height=162pt]
                {distributed-operating-system}
		{figures/distributed-operating-system}
\pgfdeclareimage[interpolate=true,width=216pt,height=162pt]
                {servers}
		{figures/servers}
\pgfdeclareimage[interpolate=true,width=160pt,height=160pt]
                {microkernel}
		{figures/microkernel}

\pgfdeclareimage[interpolate=true,width=150pt,height=25pt]
                {generic-capabilities}
		{figures/generic-capabilities}
\pgfdeclareimage[interpolate=true,width=171pt,height=75pt]
                {specific-capabilities}
		{figures/specific-capabilities}

\pgfdeclareimage[interpolate=true,width=177pt,height=160pt]
                {sets}
		{figures/sets}

\pgfdeclareimage[interpolate=true,width=126pt,height=133pt]
                {hierarchy}
		{figures/hierarchy}

% 10 frames for a microkernel example

\pgfdeclareimage[interpolate=true,width=290pt,height=165pt]
                {microkernel_example_01}
		{figures/microkernel_example_01}
\pgfdeclareimage[interpolate=true,width=290pt,height=165pt]
                {microkernel_example_02}
		{figures/microkernel_example_02}
\pgfdeclareimage[interpolate=true,width=290pt,height=165pt]
                {microkernel_example_03}
		{figures/microkernel_example_03}
\pgfdeclareimage[interpolate=true,width=290pt,height=165pt]
                {microkernel_example_04}
		{figures/microkernel_example_04}
\pgfdeclareimage[interpolate=true,width=290pt,height=165pt]
                {microkernel_example_05}
		{figures/microkernel_example_05}
\pgfdeclareimage[interpolate=true,width=290pt,height=165pt]
                {microkernel_example_06}
		{figures/microkernel_example_06}
\pgfdeclareimage[interpolate=true,width=290pt,height=165pt]
                {microkernel_example_07}
		{figures/microkernel_example_07}
\pgfdeclareimage[interpolate=true,width=290pt,height=165pt]
                {microkernel_example_08}
		{figures/microkernel_example_08}
\pgfdeclareimage[interpolate=true,width=290pt,height=165pt]
                {microkernel_example_09}
		{figures/microkernel_example_09}
\pgfdeclareimage[interpolate=true,width=290pt,height=165pt]
                {microkernel_example_10}
		{figures/microkernel_example_10}

%
% document
%

\begin{document}

%
% title frame
%

\begin{frame}
  \titlepage

  \begin{center}
    \logos
  \end{center}
\end{frame}

%
% outline frame
%

\begin{frame}
  \frametitle{Outline}
  \tableofcontents
\end{frame}

%
% overview
%

\section{Overview}

% 1)

\begin{frame}
  \frametitle{Description}

  kaneton is a pedagogic microkernel developed by students of the
  EPITA System, Network and Security specialisation.

  \nl

  The goal of this microkernel is to be understandable by everyone
  interested in operating systems internals.
\end{frame}

% 2)

\begin{frame}
  \frametitle{People}

  \textbf{Authors}

  \begin{itemize}
    \item
      Julien Quintard
    \item
      Jean-Pascal Billaud
  \end{itemize}

  \nl

  \textbf{Assistants}

  \begin{itemize}
    \item
      Cedric Aubouy
    \item
      Renaud Lienhart
  \end{itemize}

  \nl

  \textbf{Contributors}

  \begin{itemize}
    \item
      Christophe Eymard
    \item
      Solal Jacob
    \item
      Fabien Le-Mentec
  \end{itemize}
\end{frame}

% 3)

\begin{frame}
  \frametitle{Courses}

  The SRS kaneton project comes with four courses:

  \begin{itemize}[<+->]
    \item
      MIPS architecture.
    \item
      IA-32 architecture.
    \item
      kaneton design and implementation.
    \item
      Kernels generalities.
  \end{itemize}
\end{frame}

% 4)

\begin{frame}
  \frametitle{Reference}

  The kaneton people also try to develop a kaneton microkernel reference.

  \nl

  This presentation is intended to explain the kaneton microkernel
  design.
\end{frame}

%
% views
%

\section{Views}

% 1)

\begin{frame}
  \frametitle{Distributed Operating System}

  \begin{center}
    \pgfuseimage{distributed-operating-system}
  \end{center}
\end{frame}

% 2)

\begin{frame}
  \frametitle{Servers}

  \begin{center}
    \pgfuseimage{servers}
  \end{center}
\end{frame}

% 3)

\begin{frame}
  \frametitle{Microkernel}

  \begin{center}
    \pgfuseimage{microkernel}
  \end{center}
\end{frame}

% 4) the microkernel example in 10 frames

\begin{frame}
  \frametitle{Microkernel example}

  \begin{center}
    \pgfuseimage{microkernel_example_01}
  \end{center}
\end{frame}

\begin{frame}
  \frametitle{Microkernel example}

  \begin{center}
    \pgfuseimage{microkernel_example_02}
  \end{center}
\end{frame}

\begin{frame}
  \frametitle{Microkernel example}

  \begin{center}
    \pgfuseimage{microkernel_example_03}
  \end{center}
\end{frame}

\begin{frame}
  \frametitle{Microkernel example}

  \begin{center}
    \pgfuseimage{microkernel_example_04}
  \end{center}
\end{frame}

\begin{frame}
  \frametitle{Microkernel example}

  \begin{center}
    \pgfuseimage{microkernel_example_05}
  \end{center}
\end{frame}

\begin{frame}
  \frametitle{Microkernel example}

  \begin{center}
    \pgfuseimage{microkernel_example_06}
  \end{center}
\end{frame}

\begin{frame}
  \frametitle{Microkernel example}

  \begin{center}
    \pgfuseimage{microkernel_example_07}
  \end{center}
\end{frame}

\begin{frame}
  \frametitle{Microkernel example}

  \begin{center}
    \pgfuseimage{microkernel_example_08}
  \end{center}
\end{frame}

\begin{frame}
  \frametitle{Microkernel example}

  \begin{center}
    \pgfuseimage{microkernel_example_09}
  \end{center}
\end{frame}

\begin{frame}
  \frametitle{Microkernel example}

  \begin{center}
    \pgfuseimage{microkernel_example_10}
  \end{center}
\end{frame}


%
% goals
%

\section{Goals}

% 1)

\begin{frame}
  \frametitle{Project Goals}

  The goals of the kaneton project were:

  \begin{itemize}[<+->]
    \item
      To build a pedagogical project.
    \item
      With the clearest possible design.
    \item
      Able to fit distributed operating systems requirements.
    \item
      Dealing with portability.
    \item
      Easily maintainable.
    \item
      Able to run UNIX{\scriptsize \copyright} programs via
      an emulation library.
    \item
      Finally, an \textbf{all easy to understand}: source code, design,
      etc..
  \end{itemize}
\end{frame}

%
% microkernel
%

\section{Microkernel}

% 1)

\begin{frame}
  \frametitle{The kaneton Microkernel}

  The kaneton operating system is composed of two parts: a
  \textbf{microkernel} and the \textbf{servers}.

  \nl

  The kaneton microkernel has four primary functionalities
  to provide:

  \begin{itemize}[<+->]
    \item
      Communication.
    \item
      Memory management.
    \item
      Process management.
    \item
      I/O.
  \end{itemize}

  \nl

  Nevertheless, the kaneton microkernel implementation is very different
  from the other kernels such BSD, Linux, KOS, etc..
\end{frame}

%
% communication
%

\subsection{Communication}

% 1)

\begin{frame}
  \frametitle{Communication}

  The communication abstraction used in kaneton is the message.

  \nl

  Every event becomes a message including system calls, interrupts,
  signals etc..

  \nl

  No group communication is provided by the microkernel but by the distributed
  operating system.

  \nl

  This communication scheme is used to communicate with the servers
  of the machine as with the servers of the other machines, of
  the distributed system.

  \nl

  We will not detail the implementation here.
\end{frame}

%
% memory
%

\subsection{Memory}

% 1)

\begin{frame}
  \frametitle{Memory}

  \textbf{A distributed operating system needs to name every
    distributed object.}

  \nl

  An address space is composed of segments and regions.

  \nl

  Segments are physical memory areas while regions are virtual memory
  ones.

  \nl

  The address space object is just a container for the segment and
  the regions.

  \nl

  Segments can be accessed directly or via regions.
\end{frame}

%
% objects and protections
%

\subsection{Objects And Protections}

% 1)

\begin{frame}
  \frametitle{Overview}

  A distributed operating system is based on network communications, so
  the network security is crucial.

  \nl

  Indeed, it is not conceivable to allow a process on a machine
  to reserve an object and to manipulate it over the distributed
  system without security.

  \nl

  We needed a very light authentication system.

  \nl

  To include security while keeping good performances, distributed
  operating systems use capabilities, kinds of little cryptographic keys.
\end{frame}

% 2)

\begin{frame}
  \frametitle{Capabilities}

  Capabitlites are used to protect objects, permitting tasks to generate
  less privileged capabilities and to give them to other tasks.

  \nl

  Example: \textit{address spaces manipulation}

  \nl

  A capability is composed of: object identifier, permissions,
  security check, and optional fields including location, lifetime
  etc..

  \nl

  There exist two types of capabilities: generic capabilities and
  \alert{specific} capabilities.

  \nl

  Examples: \textit{file system and printers server: identifiers
    and operations}

  \nl

  The kaneton microkernel will use specific and specialised capabilities.
\end{frame}

% 3)

\begin{frame}
  \frametitle{Generic Capabilities}

  An example of generic capability from the Amoeba distributed operating
  system.

  \nl

  \begin{center}
    \pgfuseimage{generic-capabilities}
  \end{center}
\end{frame}

% 4)

\begin{frame}
  \frametitle{Specific Capabilities}

  Examples of specific capabilities used in kaneton.

  \begin{center}
    \pgfuseimage{specific-capabilities}
  \end{center}
\end{frame}

% 5)

\begin{frame}
  \frametitle{Specific Capabilities' Inherent Problems}

  \begin{itemize}[<+->]
    \item
      Capabilities are built by the servers contrary to other systems:
      Amoeba etc..
    \item
      No capability unification.
    \item
      So a slower mechanism for capability generation.
  \end{itemize}
\end{frame}

% 6)

\begin{frame}
  \frametitle{But...}

  \begin{itemize}[<+->]
    \item
      More scalable to servers requirements: cryptography,
      capability format: without object identifier, with extended
      permissions etc..
    \item
      Moreover, capability generation is seldom and generally used
      to restrict permissions.
    \item
      The mechanism is performant in a normal use but can become
      slow when a program has to generate many different capabilities.
  \end{itemize}
\end{frame}

% 7)

\begin{frame}
  \frametitle{Security Policies}

  The capability security check field does not guarantee objects security on
  the entire distributed system.

  \nl

  So was introduced three security policies:

  \begin{itemize}[<+->]
    \item
      \textbf{No security}: no check field used.
    \item
      \textbf{Local security}: the check field is used but the
      network communications do not use cryptography.
    \item
      \textbf{Global security}: the cryptography is used to secure
      network communications.
  \end{itemize}
\end{frame}

%
% set
%

\subsection{Set}

% 1)

\begin{frame}
  \frametitle{Overview}

  The current systems like linux, BSD, solaris etc.. generally use
  double linked-list, hash tables, trees etc.. data structures to
  organise internals data like tasks structures, cache structures,
  memory allocators etc..

  \nl

  Finally, with many pointers, the structures become very hard to understand
  and to manipulate leading to many programming errors and then to kernel
  crashes.

  \nl

  We decided to adopt another way.

  \nl

  In kaneton, all the data structures are managed by the set manager.

  \nl

  Using a very simple and generic interface, the entire microkernel source
  code become very elegant, so more understandable by the students.
\end{frame}

% 2)

\begin{frame}
  \frametitle{Set}

  The set manager is used to organise data.

  \nl

  Every kernel manager use it to store its data rather than doing it
  by itself.

  \nl

  Examples: \textit{segments, regions, address spaces, tasks etc..}

  \nl

  This organisation leads to a very elegant and maintainable source code.

  \nl

  Optimisations are possible in the set manager \alert{but} not in every
  manager using such a data structure like other systems do.

  \nl

  Many different data structures will be provided: linked list, circular
  queue, pipe, stack, hash tables, binary tree, array, b+-tree etc..

  \nl

  Moreover, it will be so easy to change the data structure used by a manager
  to perform some benchmarks.
\end{frame}

% 3)

\begin{frame}
  \frametitle{Implementation}

  The set manager needs to allocate memory. Indeed, the set manager
  is build over the malloc() function.

  \nl

  Nevertheless, the malloc() function needs to allocate physical and
  virtual memory so to use the segment and region managers. But, the
  segment and region managers use the set manager to store data.

  \nl

  To resolve this major problem, the malloc() function uses a survey area
  of memory used to provide fine-grained memory areas for the kernel
  boot time.

  \nl

  Then, the set manager uses the malloc() function to store data and
  every kernel manager uses the set manager. The kernel boot source code
  is so very beautiful contrary to other systems.

  \nl

  Moreover, the set manager has a set container to hold the set objects. This
  container is, in fact, also a set object.
\end{frame}

% 4)

\begin{frame}
  \frametitle{Figure}

  \begin{center}
    \pgfuseimage{sets}
  \end{center}
\end{frame}

%
% process
%

\subsection{Process}

% 1)

\begin{frame}
  \frametitle{Process}

  The kaneton microkernel is composed of different entities:

  \begin{itemize}
    \item
      \textbf{Module}: avoid dependencies after a crash.
    \item
      \textbf{Program}: userland applications, no system privileges.
    \item
      \textbf{Service}: provide a service.
    \item
      \textbf{Driver}: service which can communicate with hardware devices.
    \item
      \textbf{Core}: kind of super-driver.
  \end{itemize}

  \nl

  The microkernel manages tasks which are non active containers
  entities.

  \nl

  A task is composed of an address space and one or more threads.

  \nl

  The thread is the active scheduled entity.
\end{frame}

% 2)

\begin{frame}
  \frametitle{Task And Threads Properties}

  Each task has:

  \begin{itemize}
    \item
      A \textbf{class} specifying its system privileges.
    \item
      A \textbf{behaviour} specifying a priority range.
    \item
      A \textbf{priority} specifying its current priority.
  \end{itemize}

  \nl

  Each thread has:

  \begin{itemize}
    \item
      A \textbf{priority} specifying its current priority.
  \end{itemize}

  \nl

  These properties give the program many possibilities and
  permit it to choose its execution context.
\end{frame}

%
% processor
%

\subsection{Processor}

% 1)

\begin{frame}
  \frametitle{Processor}

  \begin{itemize}
    \item
      Each thread can choose its processors.
    \item
      This feature was directly imported from \textbf{Mach}.
    \item
      This feature increases the parallelism allowing very
      specific threads with more interactive ones.
  \end{itemize}

  \nl

  In kaneton, a binary will be configured to run with X processors.

  \nl

  Then, each thread will be able to choose its processors.
\end{frame}

%
% statistic
%

\subsection{Statistic}

% 1)

\begin{frame}
  \frametitle{Statistics}

  The kaneton kernel includes a stats manager which performs statistics
  on different managers.

  \nl

  Indeed, this manager collects information on functions used by each
  manager.

  \nl

  Whenever a function is called, the stats manager knows it and updates
  its statistics including:

  \begin{itemize}[<+->]
    \item
      Number of function calls.
    \item
      Number of errors in function called.
    \item
      How much time passed in functions.
  \end{itemize}

  \nl

  Via these statistics we will be able to optimise some critical managers
  and/or functions.
\end{frame}

%
% server
%

\subsection{Server}

% 1)

\begin{frame}
  \frametitle{Servers}

  Some examples of servers in kaneton:

  \begin{enumerate}[<+->]
    \item
      Module Service.
    \item
      Shared Memory Service.
  \end{enumerate}
\end{frame}

% 2)

\begin{frame}
  \frametitle{Module Service}

  The module service is used to store very used binaries to be able to
  launch a server which just crashed without any dependency to other servers.

  \nl

  The best example is the IDE driver.

  \nl

  \begin{itemize}[<+->]
    \item
      Composed of two subparts: \textbf{mod} and \textbf{modfs}.
    \item
      \textbf{mod} keeps track of most used modules.
    \item
      \textbf{modfs} is a main memory file system.
    \item
      Each module has a \textbf{lifetime}. The fundamental drivers
      and services modules have infinite lifetimes while user applications
      commonly have short lifetimes.
    \item
      The module service binds binary names to module identifiers.
      Moreover, the module service loads the binaries into the
      user applications' address spaces.
    \item
      So, the kernel never has to handle strings ...
    \item
      ... resulting in a simpler kernel source code
  \end{itemize}
\end{frame}

% 3)

\begin{frame}
  \frametitle{Shared Memory Service}

  The shared memory service is used to provide shared memory between tasks.

  \nl

  \begin{itemize}[<+->]
    \item
      The shared memory service is divided into two subparts:
      \textbf{csm} and \textbf{dsm}.
    \item
      This service must be used to share memory rather than giving a
      direct segment capability to another task.
    \item
      Using the shared memory service ensures that the memory will not
      be released if some programs are still using it.
    \item
      The distributed shared memory part can become a member of the
      distributed shared memory group, but this point will not be
      explained here.
  \end{itemize}
\end{frame}

%
% concepts
%

\section{Concepts}

% 1)

\begin{frame}
  \frametitle{Concepts}

  The concepts used by the kaneton microkernel are:

  \begin{itemize}[<+->]
    \item
      Little objects linked to build more complex objects:
      as, task etc..
    \item
      Let's programs manage objects themselves.
    \item
      More parallelism: the kernel is able to create a dozen
      of address spaces and then to insert segments and regions
      into them or to migrate segments to another address space.
    \item
      Easier data structure recycling.
  \end{itemize}

  These concepts are mainly based on two things:

  \begin{itemize}[<+->]
    \item
      Every object is identified by an 64-bit identifier and manipulated
      through the distributed system with a capability.
    \item
      Every kernel manager uses a set to store data.
  \end{itemize}
\end{frame}

% 2)

\begin{frame}
  \frametitle{Hierarchy}

  \begin{center}
    \pgfuseimage{hierarchy}
  \end{center}
\end{frame}

%
% machine dependent
%

\section{Machine Dependent}

% 1)

\begin{frame}
  \frametitle{Overview}

  The portability in kernels can be implemented through three different
  ways:

  \begin{itemize}[<+->]
    \item
      Let the machine dependent source code define for example the memory
      manager for its architecture so it can optimise every data structures
      for this architecture.

      \nl

      The major problem is the non-dependent code redundancy
      in each architecture.
    \item
      Define a generic interface in which each architecture must fill in.
      Then, the kernel code just calls machine-dependent source code
      to perform some specific operations like: flush\_tlb(),
      new\_page\_directory() etc..

      \nl

      This system seems ugly but is better than the previous. Nevertheless
      some architectures may not fit in this interface.
    \item
      The last consists in calling the machine-dependent code everytime
      it may be needed by the architecture to perform modifications on
      architecture data structures etc..

      \nl

      The problem is that some problems may occur when the architecture
      needs to perform operations and is not allowed to.
  \end{itemize}
\end{frame}

% 2)

\begin{frame}
  \frametitle{kaneton}

  We decided to adopt the last solution because it provides a powerful
  abstraction to low-level programming.

  \nl

  In fact, rather than calling the machine dependent code to build
  a new page directory and link it to a task structure, the kaneton
  microkernel calls the machine dependent code every time an
  object is created or modified.

  \nl

  For example, when an address space object is created, the machine
  dependent code is called. Then the architecture performs the operations
  needed like building a new page directory and linking it to the
  new address space just created etc..

  \nl

  This system is experimental but seems to be correct. Nevertheless some
  problems may happen...

  \nl

  Theoritically, this system is the best because there is no redundancy
  and there are no constraints for the machine-dependent code.
\end{frame}

%
% check
%

\section{Check}

% 1)

\begin{frame}
  \frametitle{Overview}

  Each  developer can validate his modifications running unitary/regression
  tests on the kaneton microkernel.

  \nl

  We wanted a validation system based on a real execution environment,
  so we wanted to test the kernel running on real computer.

  \nl

  Our system uses the serial device to communicate with the microkernel. Then
  some microkernel regression tests functions are run and the result
  is returned via the serial device communication protocol.

  \nl

  The check script compares the result with the one expected and alerts
  the developer if something bad happened.
\end{frame}

% 2)

\begin{frame}
  \frametitle{Tests}

  This system permits kaneton developers to test:

  \begin{itemize}[<+->]
    \item
      The C library.
    \item
      Every kernel manager including: segment, region, as, task, thread
      etc.. and the famous set manager.
  \end{itemize}
\end{frame}

%
% tools
%

\section{Tools}

% 1)

\begin{frame}
  \frametitle{Tools}

  The tools used to develop the kaneton microkernel are UNIX classical tools:

  \begin{itemize}
    \item
      gcc
    \item
      cpp
    \item
      gmake
    \item
      bash
    \item
      ld
    \item
      sed
    \item
      python
    \item
      emulators: bochs, qemu, gxemul etc..
    \item
      etc..
  \end{itemize}

  \nl

  The language used to develop kaneton is the C language.
\end{frame}

%
% state
%

\section{State}

% 1)

\begin{frame}
  \frametitle{State: \textbf{\today}}

  The development of the microkernel is far from being finished.

  \nl

  Indeed, the goal was to design a powerful portable microkernel, and this
  takes much time.

  \nl

  The parts developed are listed below:

  \begin{itemize}[<+->]
    \item
      \textbf{bootstrap}: ia32
    \item
      \textbf{bootloader}: ia32
    \item
      \textbf{id manager}
    \item
      \textbf{set manager}: linked-list, array, balanced+ tree
    \item
      \textbf{as manager}: +ia32
    \item
      \textbf{segment manager}
    \item
      \textbf{region manager}: +ia32 \textit{[30\%]}
    \item
      \textbf{stats manager}
    \item
      \textbf{debug manager}
    \item
      \textbf{task manager}: \textit{[10\%]}
  \end{itemize}
\end{frame}

% 2)

\begin{frame}
  \frametitle{Recruitment}

  The first goal of the kaneton project is to permit students to
  learn complex low-level programming and operating system concepts.

  \nl

  Recruiting futur maintainers is important first to give courses
  and then to develop the project.

  \nl

  The students wanting to work on the kaneton project should be aware
  that this project takes much time. Moreover, the selected students
  must work on this project during about \textbf{two years}.

  \nl

  The first year, the students will \textbf{learn} the basis of the low-level
  programming, kernel development, kaneton design etc.. and
  \textbf{participate} to the kaneton design and development through
  the different subprojects listed below.

  \nl

  The second year, the students will have to \textbf{give courses} and
  \textbf{develop some important parts} of the kaneton reference while
  \textbf{maintaining} the different tools around the project.
\end{frame}

% 3)

\begin{frame}
  \frametitle{Futur Works}

  The maintainers of the kaneton project want to build a stable version
  of the microkernel before developing anything else.

  \nl

  So the futur works are:

  \begin{itemize}[<+->]
    \item
      To validate the portability system through other architectures:
      sparc, mips, powerpc, intel etc..

      \nl

      Also develop very special architecture to explore different ways
      like optimisations: ia32-virtual, ia32-segment, ia32-optimised etc..
    \item
      To increase the set types.
    \item
      To design the event interface.
    \item
      To design and maintain the kaneton building system with the
      makefile and shell interfaces.
    \item
      To design a powerful naming scheme allowing concurrent
      servers executions while permitting to name every system object:
      segment, as, task, id etc.. like the research distributed operating
      system Sprite from Berkeley did.
    \item
      To design a complete device manager.
  \end{itemize}
\end{frame}

% 4)

\begin{frame}
  \frametitle{Recruitment}

  We need \textbf{two} students to contribute for about two years to
  the kaneton project. These two students will work at the EPITA Computer
  System Laboratory.

  \nl

  Moreover, we can recruit two other contributors from outside any laboratory.

  \nl

  Needless to say, this is a very important decision for you, for us,
  and for the EPITA SRS specialisation.
\end{frame}

\end{document}
