%%
%% copyright     (c) julien quintard
%%
%% project       kaneton
%%
%% file          /home/mycure/kaneton/view/lectures/advanced-makefiles/advanced-makefiles.tex
%%
%% created       julien quintard   [sat nov 19 17:45:53 2005]
%% updated       julien quintard   [sun dec 25 23:21:31 2005]
%%

%
% template
%

\input{../../templates/lecture.tex}

%
% title
%

\title{Advanced Makefiles}

%
% authors
%

\author
{
  Julien~Quintard\inst{1}
}

%
% document
%

\begin{document}

%
% title frame
%

\begin{frame}
  \titlepage

  \begin{center}
    \logos
  \end{center}
\end{frame}

%
% outline frame
%

\begin{frame}
  \frametitle{Outline}
  \tableofcontents
\end{frame}

%
% overview
%

\section{Overview}

% 1)

\begin{frame}
  \frametitle{Definition}

  The \textbf{makefiles} are used to always compile only the files
  that need to be compiled, in other words, only the source files which
  have changed.

  \nl

  So a makefile defines \textbf{rules} which indicates \textbf{make}
  which file to compile, in which case a file must be rebuilt etc..
\end{frame}

%
% basic makefiles
%

\section{Basic Makefiles}

% 1)

\begin{frame}
  \frametitle{Overview}

  We will se in this section how to build a basic makefile, what is the
  makefile syntax etc..

  \nl

  Then we will briefly introduce some tips.

  \nl

  Finally we will analyse the limitations of these basic makefiles to
  introduce new techniques in the next sections.
\end{frame}

% 2)

\begin{frame}[containsverbatim]
  \frametitle{Syntax}

  As an introduction, let's take a look to the makefile syntax:

  \begin{verbatim}
    target1:        dependency11 dependency21
            command11
            command21

    target2:        dependency21 dependency22 dependency23 dependency24
            command21
  \end{verbatim}
\end{frame}

%
% introduction
%

\subsection{Introduction}

% 1)

\begin{frame}[containsverbatim]
  \frametitle{Example}

  The best way to introduce makefile is to take an example:

  \begin{columns}

    \begin{column}{6cm}
      \begin{verbatim}
        all:    chiche.o main.o
                gcc -o binary chiche.o main.o

        clean:
                rm -f binary chiche.o main.o
      \end{verbatim}
    \end{column}

    \begin{column}{6cm}

      \begin{verbatim}
        $ make
        cc    -c -o chiche.o chiche.c
        cc    -c -o main.o main.c
        gcc -o binary chiche.o main.o
        $ make clean
        rm -f binary chiche.o main.o
        $ 
      \end{verbatim}
    \end{column}

  \end{columns}
\end{frame}

% 2)

\begin{frame}
  \frametitle{Questions}

  \begin{enumerate}
    \item
      what does this makefile do?
    \item
      why do not just writing a shell script by hand?
    \item
      what are the problems of this makefile: redundancy, extensibility etc..
  \end{enumerate}
\end{frame}

% 3)

\begin{frame}[containsverbatim]
  \frametitle{Variables}

  You previously noticed the redundancy present in our example.

  \nl

  The best and only way to resolve this design problem is to use variables.

  \nl

  \begin{verbatim}
    BIN         =       binary
    OBJS        =       chiche.o main.o

    all:    $(OBJS)
            gcc -o $(BIN) $(OBJS)

    clean:
            rm -f $(BIN) $(OBJS)
  \end{verbatim}
\end{frame}

% 4)

\begin{frame}
  \frametitle{Default Variables}

  The make system uses default variables to define for example the C compiler,
  the remove binary, the assembly compiler etc..

  \nl

  Let's take a look to this non-exhaustive list:

  \begin{itemize}
    \item
      \textbf{AR}: archive-maintaining program, default \textit{ar}
    \item
      \textbf{AS}: program for doing assembly, default \textit{as}
    \item
      \textbf{CC}: program for compiling C programs, default \textit{cc}
    \item
      \textbf{CXX}: program for comping C++ programs, default \textit{g++}
    \item
      \textbf{CPP}: program for running C preprocessor, default
      \textit{\$(CC) -E}
    \item
      \textbf{LEX}: program to use to turn Lex grammars into C programs,
      default \textit{lex}
    \item
      \textbf{YACC}: program to use to turn Yacc grammars into C programs,
      default \textit{yacc}
    \item
      \textbf{TEX}: program to make TeX DVI files from TeX source, default
      \textit{tex}.
    \item
      \textbf{TEXI2DVI}: program to make TeX DVI files from Texinfo source,
      default \textit{texi2dvi}
    \item
      \textbf{RM}: command to remove a file, default \textit{rm -f}
    \item
      etc..
  \end{itemize}
\end{frame}

% 5)

\begin{frame}
  \frametitle{Default Variables}

  Now the list of the flags variables:

  \begin{itemize}
    \item
      \textbf{ARFLAGS}: flags to give the archive-maintaining program,
      default \textit{rv}
    \item
      \textbf{ASFLAGS}: extra flags to give to the assembler
    \item
      \textbf{CFLAGS}: extra flags to give to the C compiler
    \item
      \textbf{CXXFLAGS}: extra flags to give to the C++ compiler
    \item
      \textbf{CPPFLAGS}: extra flags to give to the C preprocessor
    \item
      \textbf{LDFLAGS}: extra flags to give to compilers when they are
      supposed to invoke the linker
    \item
      \textbf{LFLAGS}: extra flags to give to Lex
    \item
      \textbf{YFLAGS}: extra flags to give to Yacc
    \item
      etc..
  \end{itemize}
\end{frame}

% 6)

\begin{frame}[containsverbatim]
  \frametitle{Example}

  Finally, our example can now be written like this:

  \begin{verbatim}
    BIN         =       binary
    OBJS        =       chiche.o main.o

    all:    $(OBJS)
            $(CC) $(CFLAGS) -o $(BIN) $(OBJS)

    clean:
            $(RM) $(BIN) $(OBJS)
  \end{verbatim}
\end{frame}

% 7)

\begin{frame}[containsverbatim]
  \frametitle{Limitations}

  Let's analyse the limitations of this makefile.

  \begin{verbatim}
    $ cat main.c
    #include ``chiche.h''

    [...]
    $ 
  \end{verbatim}

  Then if the programmer modifies the header file, the \textbf{main} object
  file will not be rebuilt; this is a serious limitation.

  \nl

  The solution is to build a rule for each object file which depends of
  the header file, if needed.

  \nl

  There are many limitations we will explore during this lecture:
  redundancy, header file dependencies, phony targets, echoing etc..
\end{frame}

% 8)

\begin{frame}[containsverbatim]
  \frametitle{Example}

  \begin{verbatim}
    BIN         =       binary
    OBJS        =       chiche.o main.o

    all:    $(OBJS)
            $(CC) $(CFLAGS) -o $(BIN) $(OBJS)

    clean:
            $(RM) $(BIN) $(OBJS)

    main.o: main.c chiche.h
            $(CC) $(CFLAGS) -c main.c -o main.o
  \end{verbatim}

  Are there some other limitations now?
\end{frame}

%
% first tips
%

\subsection{First Tips}

% 1)

\begin{frame}[containsverbatim]
  \frametitle{Command Execution}

  Each command in a rule is launched as a new subshell.

  \nl

  Of cours make internals try to optimise.

  \nl

  This detail implies that shell commands such as \textit{cd} that set
  variables local to each process will not affect the following makefile
  commands.

  \nl

  If the programmer wants to use commands which affect the following one, he
  has to put these commands on the same line.

  \begin{verbatim}
    foo:    bar
            cd bar ; echo 1 > log ; cd ..

    bar:
            cd bar ;    \
            make ;      \
            cd ..
  \end{verbatim}
\end{frame}

% 2)

\begin{frame}[containsverbatim]
  \frametitle{Errors in Commands}

  Let's analyse how make handles the errors in commands.

  \nl

  Let's take a rule:

  \begin{columns}

    \begin{column}{6cm}
      \begin{verbatim}
        [...]

        build:
          mywc -l log

          echo OK
      \end{verbatim}
    \end{column}

    \begin{column}{6cm}
      \begin{verbatim}
        $ make build
        mywc -l log
        make: mywc: Command not found
        make: *** [build] Error 127
        $ 
      \end{verbatim}
    \end{column}

  \end{columns}
\end{frame}

% 3)

\begin{frame}[containsverbatim]
  \frametitle{Solution}

  The solution of this problem is to use a special operator: \textbf{-}.

  \begin{columns}

    \begin{column}{6cm}
      \begin{verbatim}
        [...]

        build:
          -mywc -l log

          echo OK
      \end{verbatim}
    \end{column}

    \begin{column}{6cm}
      \begin{verbatim}
        $ make build
        mywc -l log
        make: mywc: Command not found
        make: [build] Error 127 (ignored)
        echo OK
        OK
        $ 
      \end{verbatim}
    \end{column}

  \end{columns}

  \nl

  This feature is especially useful with the \textbf{include} directive
  for example to not generate errors because the file to include will
  be \textbf{generated} soon.
\end{frame}

% 4)

\begin{frame}[containsverbatim]
  \frametitle{Recursive Use of Make}

  Sometimes its is useful to ask another makefile to compile the sources.

  \nl

  Indeed, the correct convention is to compile the source located in
  the current working directory: first because its sounds good and then
  to avoid name conflicts.

  \nl

  Otherwise, for example, \textit{src/chiche.c} and \textit{generic/chiche.c}
  will generate a file called \textit{obj/chiche.o}.

  \nl

  As briefly seen before, it is better to explore the hierarchy calling
  make in each subdirectory, then each makefile either build a binary, library
  or anything else or recursively calls the makefiles of its subdirectories.

  \nl

  There are two ways to use make recursively:

  \begin{columns}

    \begin{column}{6cm}
      \begin{verbatim}
        all:
                cd src ;    \
                make ;      \
                cd ..
      \end{verbatim}
    \end{column}

    \begin{column}{6cm}
      \begin{verbatim}
        all:
                make -C src
      \end{verbatim}
    \end{column}
  \end{columns}
\end{frame}

%
% complete makefiles
%

\section{Complete Makefiles}

% 1)

\begin{frame}
  \frametitle{Overview}

  We saw earlier that basic makefiles as the examples taken had
  many limitations.

  \nl

  In this section, we will try to fix these problems to build powerful
  makefiles.
\end{frame}

%
% directives
%

\subsection{Directives}

% 1)

\begin{frame}
  \frametitle{Overview}

  The directives are used to parameterise the entire makefile.

  \nl

  Let's see the most powerful directives.

  \begin{itemize}[<+->]
    \item
      \textbf{.PHONY}
    \item
      \textbf{.SUFFIXES}
    \item
      \textbf{.DEFAULT}
    \item
      \textbf{.IGNORE}
    \item
      \textbf{.SILENT}
    \item
      \textbf{export}
    \item
      \textbf{include}
    \item
      others..
  \end{itemize}
\end{frame}

% 2)

\begin{frame}
  \frametitle{\textbf{.PHONY}}

  The \textbf{.PHONY} directive is used to specify gmake the list of the
  rules to force.

  \nl

  In other words, these rules will always be remade.
\end{frame}

% 3)

\begin{frame}[containsverbatim]
  \frametitle{Example}

  \begin{columns}{2}

    \begin{column}{6cm}
      \begin{verbatim}
        chiche:
                @echo ``chiche''

        clean:
                rm *~
      \end{verbatim}
    \end{column}

    \begin{column}{6cm}
      \begin{verbatim}
	$ make chiche
        chiche
        $ touch chiche
        $ make
        XXX
        $ 
      \end{verbatim}
    \end{column}

  \end{columns}
\end{frame}

\subsection{Default Rule}

%%%\frame{Overview}
%%%\frame{.DEFAULT}
%%%\frame{%: ou %::}

\subsection{Automatic Variables}

%%%\frame{Overview}
%%%\frame{$^}
%%%\frame{etc..}

\subsection{Assignments}

%%%\frame{Overview}
%%%\frame{=}
%%%\frame{?=}
%%%\frame{etc..}

\subsection{Conditionals}

%%%\frame{Overview}
%%%\frame{ifeq}
%%%\frame{etc..}

\subsection{Wildcard}

%%%\frame{Overview}
%%%\frame{etc..}

%
% complex makefiles
%

\section{Advanced Makefiles}

\subsection{Double-colon Rules}

%%%\frame{Overview}
%%%\frame{etc..}

\subsection{Generating Dependencies}

%%%\frame{Overview}
%%%\frame{etc..}

\subsection{Echoing}

%%%\frame{Overview}
%%%\frame{etc..}

\subsection{Defining Variables}

%%%\frame{Canned Command Sequence}
%%%\frame{Variables Verbatim}
%%%\frame{Variable Evaluation}
%%%\frame{Override Directive}

\subsection{Target-Specific Variable Values}

%%%\frame{Overview}

\subsection{Functions}

%%%\frame{Overview}

\section{Advanced Topics}

\section{Case Study}

%
% bibliography
%

\section{Bibliography}

\begin{thebibliography}{3}
  \bibitem{Howto}
    GNU Make Documentation
\end{thebibliography}

\end{document}

--

\subsection{Multiples Targets}
\subsection{Multiples Rules}
\subsection{Chain of Compilation}
\subsection{Prerequisites} *

--

%%%\frame{Implicit Rules}