%
% ---------- header -----------------------------------------------------------
%
% project       kaneton
%
% license       kaneton
%
% file          /home/mycure/kane.../kernels/prerequisites/prerequisites.tex
%
% created       julien quintard   [wed may 16 19:28:59 2007]
% updated       julien quintard   [wed may 16 19:29:16 2007]
%

%
% figures
%

% bsd

\pgfdeclareimage[interpolate=true,width=157pt,height=120pt]
                {bsd}
		{figures/bsd}

% kaneton

\pgfdeclareimage[interpolate=true,width=145pt,height=120pt]
                {kaneton}
		{figures/kaneton}

% lseos

\pgfdeclareimage[interpolate=true,width=174pt,height=120pt]
                {lseos}
		{figures/lseos}

% hexo

\pgfdeclareimage[interpolate=true,width=176pt,height=120pt]
                {hexo}
		{figures/hexo}

% nt

\pgfdeclareimage[interpolate=true,width=194pt,height=120pt]
                {nt}
		{figures/nt}

% k

\pgfdeclareimage[interpolate=true,width=151pt,height=120pt]
                {k}
		{figures/k}

% basic architecture

\pgfdeclareimage[interpolate=true,width=158pt,height=150pt]
                {arch-basic}
		{figures/arch-basic}

% memory access

\pgfdeclareimage[interpolate=true,width=240pt,height=200pt]
                {memory-access-step1}
		{figures/memory-access-step1}
\pgfdeclareimage[interpolate=true,width=240pt,height=200pt]
                {memory-access-step2}
		{figures/memory-access-step2}
\pgfdeclareimage[interpolate=true,width=240pt,height=200pt]
                {memory-access-step3}
		{figures/memory-access-step3}
\pgfdeclareimage[interpolate=true,width=240pt,height=200pt]
                {memory-access-step4}
		{figures/memory-access-step4}
\pgfdeclareimage[interpolate=true,width=300pt,height=110pt]
                {memory-controller}
		{figures/mem}

% io

\pgfdeclareimage[interpolate=true,width=261pt,height=180pt]
                {io-step1}
		{figures/io-step1}
\pgfdeclareimage[interpolate=true,width=261pt,height=180pt]
                {io-step2}
		{figures/io-step2}
\pgfdeclareimage[interpolate=true,width=261pt,height=180pt]
                {io-step3}
		{figures/io-step3}

% memory mapped io

\pgfdeclareimage[interpolate=true,width=200pt,height=180pt]
                {mc9as}
		{figures/mc9as}

% irq reception

\pgfdeclareimage[interpolate=true,width=225pt,height=180pt]
                {irq-step1}
		{figures/irq-step1}
\pgfdeclareimage[interpolate=true,width=225pt,height=180pt]
                {irq-step2}
		{figures/irq-step2}
\pgfdeclareimage[interpolate=true,width=225pt,height=180pt]
                {irq-step3}
		{figures/irq-step3}
\pgfdeclareimage[interpolate=true,width=225pt,height=180pt]
                {irq-step4}
		{figures/irq-step4}

% bus lock

\pgfdeclareimage[interpolate=true,width=270pt,height=150pt]
                {bus-lock-step1}
		{figures/bus-lock-step1}
\pgfdeclareimage[interpolate=true,width=270pt,height=150pt]
                {bus-lock-step2}
		{figures/bus-lock-step2}
\pgfdeclareimage[interpolate=true,width=270pt,height=150pt]
                {bus-lock-step3}
		{figures/bus-lock-step3}
\pgfdeclareimage[interpolate=true,width=270pt,height=150pt]
                {bus-lock-step4}
		{figures/bus-lock-step4}

% dma

\pgfdeclareimage[interpolate=true,width=300pt,height=120pt]
                {dma-step1}
		{figures/dma-step1}
\pgfdeclareimage[interpolate=true,width=300pt,height=120pt]
                {dma-step2}
		{figures/dma-step2}
\pgfdeclareimage[interpolate=true,width=300pt,height=120pt]
                {dma-step3}
		{figures/dma-step3}

% pipeline

\pgfdeclareimage[interpolate=true,width=300pt,height=141pt]
                {pipeline}
		{figures/pipeline}

% rob

\pgfdeclareimage[interpolate=true,width=307pt,height=180pt]
                {rob}
		{figures/rob}

% caches

\pgfdeclareimage[interpolate=true,width=244pt,height=180pt]
                {cache}
		{figures/cache}
\pgfdeclareimage[interpolate=true,width=244pt,height=180pt]
                {cache-step1}
		{figures/cache-step1}
\pgfdeclareimage[interpolate=true,width=244pt,height=180pt]
                {cache-step2}
		{figures/cache-step2}
\pgfdeclareimage[interpolate=true,width=244pt,height=180pt]
                {cache-step3}
		{figures/cache-step3}
\pgfdeclareimage[interpolate=true,width=244pt,height=180pt]
                {cache-step4}
		{figures/cache-step4}
\pgfdeclareimage[interpolate=true,width=244pt,height=180pt]
                {cache-step5}
		{figures/cache-step5}

% misaligned access

\pgfdeclareimage[interpolate=true,width=300pt,height=150pt]
                {unaligned-step1}
		{figures/unaligned-step1}
\pgfdeclareimage[interpolate=true,width=300pt,height=150pt]
                {unaligned-step2}
		{figures/unaligned-step2}
\pgfdeclareimage[interpolate=true,width=300pt,height=150pt]
                {unaligned-step3}
		{figures/unaligned-step3}
\pgfdeclareimage[interpolate=true,width=300pt,height=150pt]
                {unaligned-step4}
		{figures/unaligned-step4}


% mmu

\pgfdeclareimage[interpolate=true,width=211pt,height=80pt]
                {mmu}
		{figures/mmu}

% event

\pgfdeclareimage[interpolate=true,width=270pt,height=150pt]
                {event-step1}
		{figures/event-step1}
\pgfdeclareimage[interpolate=true,width=270pt,height=150pt]
                {event-step2}
		{figures/event-step2}
\pgfdeclareimage[interpolate=true,width=270pt,height=150pt]
                {event-step3}
		{figures/event-step3}

% ipi

\pgfdeclareimage[interpolate=true,width=276pt,height=120pt]
                {ipi-step1}
		{figures/ipi-step1}
\pgfdeclareimage[interpolate=true,width=276pt,height=120pt]
                {ipi-step2}
		{figures/ipi-step2}
\pgfdeclareimage[interpolate=true,width=276pt,height=120pt]
                {ipi-step3}
		{figures/ipi-step3}

% cpu

\pgfdeclareimage[interpolate=true,width=293pt,height=100pt]
                {cpu}
		{figures/cpu}

% program loading

\pgfdeclareimage[interpolate=true,width=261pt,height=180pt]
                {elf}
		{figures/elf}

% syscall

\pgfdeclareimage[interpolate=true,width=200pt,height=160pt]
                {syscall}
		{figures/syscall}



%
% introduction to kernels
%

\section{Introduction to kernels}

%
% roles of a kernel
%

\subsection{Roles of a kernel}

% -)

\begin{frame}
  \frametitle{Goals}

  The kernel is the central part of an operating system. The kernel is
  the entity offering abstraction of the hardware to the applications,
  including:

  \begin{itemize}
  \item
    Memory management
  \item
    Process management
  \item
    I/Os and events (both leading to drivers)
  \item
    Inter-Process Communication
  \end{itemize}

  In addition, the kernel must ensure the security of the resources.

  \-

  The final goal of a kernel is to run user programs, to enable them
  to interact with hardware and between each others, what constitues
  an operating system.

\end{frame}

% -)

\begin{frame}
  \frametitle{A good kernel is\ldots}

  \begin{itemize}
  \item
    Fast. Performances are critical.
  \item
    Reliable. When a kernel crashes, the whole machine does.
  \item
    Maintainable. Other developers must be able to write their own
    drivers or services.
  \item
    Fault tolerant. Either in terms of hardware faults and software
    faults.
  \item
    Secure.
  \item
    Portable. To work on different hardware with less possible porting
    effort.
  \end{itemize}

\end{frame}

% -)

\begin{frame}
  \frametitle{Kernel-space \& User-land}

  Kernel-space is the execution environment of the kernel. All
  operations are permitted. Hardware can be accessed and
  controlled. Microprocessor internal stuctures and control registers
  too. The kernel can access all the tasks address spaces.

  \-

  User-land is the environment of classical programs, with many
  restrictions. Hardware access is forbidden. Configuration facilities
  are denied. A program can only access its own address space.

  \-

  The more code you have in kernel-space, the more risks of crashes you
  have.

\end{frame}

%
% monolithic kernels
%

\subsection{Monolithic kernels}

%
% monolithic kernels
%

\begin{frame}
  \frametitle{Monolithic kernels}

  Monolithic kernels includes everything into the kernel, even
  drivers, filesystems, networking\ldots

  \-

  \emph{This approach well known as ``The Big Mess''. The structure is
  that there is no structure.} -- Tanenbaum

  \-

  Pros:

  \begin{itemize}
  \item
    High performances: only function calls
  \end{itemize}

  \-

  Cons:

  \begin{itemize}
  \item
    Dangerous: one bug in a non-critical service may lead the system
    to crash
  \item
    Not easy to understand and maintain
  \end{itemize}

\end{frame}

%
% bsd
%

\begin{frame}
  \frametitle{Example: BSD}

  4.4BSD kernel include all functionnalities in kernel-land: from
    process management to network layer, through filesystems.

  \begin{center}
    \pgfuseimage{bsd}
  \end{center}

  The kernel is about 200.000 lines long.

\end{frame}

%
% microkernels
%

\subsection{Micro-kernels}

%
% microkernels
%

\begin{frame}
  \frametitle{Micro-kernels}

  In micro-kernels, only the critical functionnalities are running in
  kernels-space. The other services are running as user programs
  (having extended privileges).

  \-

  Pros:

  \begin{itemize}
  \item
    Small amount of code in kernel-space: less bugs and risks of
    crashes
  \item
    Clearest design, easy to understand
  \item
    Services can be started and stopped: reduce system load, run
    concurrent services\ldots
  \end{itemize}

  \-

  Cons:

  \begin{itemize}
  \item
    Lots of IPC: slower performances
  \end{itemize}

\end{frame}

%
% kaneton
%

\begin{frame}
  \frametitle{Example: kaneton}

  kaneton provide a dozen of critical managers: memory, process,
  I/O\ldots{} Only these functionnalities are running in kernel-land.

  \begin{center}
    \pgfuseimage{kaneton}
  \end{center}

  Advanced functionnalities (filesystems, network\ldots) are provided
  by services in userland. IPC are omnipresent.

\end{frame}

%
% nanokernels
%

\subsection{Nano-kernels}

%
% nanokernels
%

\begin{frame}
  \frametitle{Nano-kernels}

  The only difference with micro-kernels is that more and more
  services are pushed out of kernel-space. The kernel code is then
  reduced.

\end{frame}

%
% lse/os
%

\begin{frame}
  \frametitle{Example: LSE/OS}

  LSE/OS has a nano-kernel conception to keep the code as tiny as
  possible, preventing bugs into the kernel leading to global crashed
  of the system. Only the core is running in kernel-land.

  \begin{center}
    \pgfuseimage{lseos}
  \end{center}

  LSE/OS pushes out of the kernel the timer and interrupt controller
  modules and offers minimal services for task and memory management.

\end{frame}

%
% exokernels
%

\subsection{Exo-kernels}

%
% exokernels
%

\begin{frame}
  \frametitle{Exo-kernels}

  Exo-kernels is a very young class of kernel, still under research
  effort. Principles:

  \begin{itemize}
  \item
    A few abstraction as possible
  \item
    Abstractions are libraries
  \item
    Build other abstractions on existing one
  \item
    Programs use directly these abstractions for performances
  \end{itemize}

  \-

  No commercial operating systems are based on exo-kernel.

  \-

  Pros:

  \begin{itemize}
  \item
    Fully customizable, by adding and removing unnecessary libraries
  \item
    Good performances: function calls like in monolithic kernels
  \item
    Clear design: modules are libraries
  \end{itemize}

\end{frame}

%
% hexo
%

\begin{frame}
  \frametitle{Example: HEXO}

  HEXO is a massively parallel heterogeneous multiprocessor
  exo-kernel.

  \begin{center}
    \pgfuseimage{hexo}
  \end{center}

  HEXO is build over two abstractions : CPU-specific and
  Platform-specific. Higher level abstractions can be wrote easily
  over HEXO's primitives.

\end{frame}

%
% hybrid kernels
%

\subsection{Hybrid kernels}

%
% hybrid kernels
%

\begin{frame}
  \frametitle{Hybrid kernels}

  The hybrid kernels relies on all the previously studied kernel
  models.

  \begin{itemize}
  \item
    Structure similar to micro-kernels, with services
  \item
    Most of the code is running in kernel-land to improve performance,
    like in monolithic kernels
  \end{itemize}

  This class of kernels is considered as ``marketing argument'' by
  many people, because there is no great innovation.

  \-

  Pros:

  \begin{itemize}
  \item
    All in kernel-space: less IPCs, better performances
  \item
    Micro-kernel design: clear and easy to maintain
  \end{itemize}

  \-

  Cons:

  \begin{itemize}
  \item
    Risks of crashes like with monolithic designs
  \end{itemize}

\end{frame}

%
% windows nt
%

\begin{frame}
  \frametitle{Example: Windows NT}

  \begin{center}
    \pgfuseimage{nt}
  \end{center}

  The NT kernel is a mix of exo-kernels (HAL), micro-kernels
  (services) and monolithic kernels (everything in kernel-land). On
  Windows NT, it is fun to notice that even the GUI services are part
  of the kernel.

\end{frame}

%
% specific kernels
%

\subsection{Specific kernels}

%
% specific kernels
%

\begin{frame}
  \frametitle{Specific kernels}

  Specific kernels are dedicated to specific domains and applications.

  \begin{itemize}
  \item
    Some of the classical functionnalities are not provided
  \item
    Important drivers are directly included into the kernel
  \item
    No portability
  \item
    Reduced set of system calls
  \item
    Non-standard API (specific API)
  \end{itemize}

  \-

  For example, the operating system of a washing machine does not need
  virtual memory, scheduler or filesystems.

\end{frame}

%
% k
%

\begin{frame}
  \frametitle{Example: K}

  K is a specific kernel providing a reduced set of functionnality. K
  is intended to run small games.

  \begin{center}
    \pgfuseimage{k}
  \end{center}

  K does not provide some classical functionnalities such as virtual
  memory or process management, but is provides some main functions
  for its specific domain like video or sound drivers.

\end{frame}

%
% recalls of prerequisites
%

\section{Recalls of prerequisites}

%
% basic architectures
%

\subsection{Basic architectures}

% -)

\begin{frame}
  \frametitle{Minimal components and buses}

  \begin{center}
    \pgfuseimage{arch-basic}
  \end{center}

\end{frame}

% -)

\begin{frame}
  \frametitle{Memory accesses}

  \begin{center}
    \pgfuseimage{memory-access-step1}
  \end{center}

\end{frame}

% -)

\begin{frame}
  \frametitle{Memory accesses}

  \begin{center}
    \pgfuseimage{memory-access-step2}
  \end{center}

\end{frame}

% -)

\begin{frame}
  \frametitle{Memory accesses}

  \begin{center}
    \pgfuseimage{memory-access-step3}
  \end{center}

\end{frame}

% -)

\begin{frame}
  \frametitle{Memory accesses}

  \begin{center}
    \pgfuseimage{memory-access-step4}
  \end{center}

\end{frame}

% -)

\begin{frame}
  \frametitle{Memory controller}

  \begin{center}
    \pgfuseimage{memory-controller}
  \end{center}

\end{frame}

% -)

\begin{frame}
  \frametitle{Misaligned memory access}

  \begin{center}
    \pgfuseimage{unaligned-step1}
  \end{center}

\end{frame}

% -)

\begin{frame}
  \frametitle{Misaligned memory access}

  \begin{center}
    \pgfuseimage{unaligned-step2}
  \end{center}

\end{frame}

% -)

\begin{frame}
  \frametitle{Misaligned memory access}

  \begin{center}
    \pgfuseimage{unaligned-step3}
  \end{center}

\end{frame}

% -)

\begin{frame}
  \frametitle{Misaligned memory access}

  \begin{center}
    \pgfuseimage{unaligned-step4}
  \end{center}

\end{frame}

% -)

\begin{frame}
  \frametitle{I/Os}

  \begin{center}
    \pgfuseimage{io-step1}
  \end{center}

\end{frame}

% -)

\begin{frame}
  \frametitle{I/Os}

  \begin{center}
    \pgfuseimage{io-step2}
  \end{center}

\end{frame}

% -)

\begin{frame}
  \frametitle{I/Os}

  \begin{center}
    \pgfuseimage{io-step3}
  \end{center}

\end{frame}

% -)

\begin{frame}
  \frametitle{Memory-mapped I/Os}

  Sometimes, the CPU does not offers I/O specific signals. In this
  cases, devices are considered like memory blocks.

  \-

  The \textbf{IORQ} signal is replaced by \textbf{MEMRQ}.

\end{frame}

% -)

\begin{frame}
  \frametitle{MC9S12NE64 memory map}

  \begin{center}
    \pgfuseimage{mc9as}
  \end{center}

\end{frame}

% -)

\begin{frame}
  \frametitle{IRQ reception}

  \begin{center}
    \pgfuseimage{irq-step1}
  \end{center}

\end{frame}

% -)

\begin{frame}
  \frametitle{IRQ reception}

  \begin{center}
    \pgfuseimage{irq-step2}
  \end{center}

\end{frame}

% -)

\begin{frame}
  \frametitle{IRQ reception}

  \begin{center}
    \pgfuseimage{irq-step3}
  \end{center}

\end{frame}

% -)

\begin{frame}
  \frametitle{IRQ reception}

  \begin{center}
    \pgfuseimage{irq-step4}
  \end{center}

\end{frame}

% -)

\begin{frame}
  \frametitle{Bus locking}

  \begin{center}
    \pgfuseimage{bus-lock-step1}
  \end{center}

\end{frame}

% -)

\begin{frame}
  \frametitle{Bus locking}

  \begin{center}
    \pgfuseimage{bus-lock-step2}
  \end{center}

\end{frame}

% -)

\begin{frame}
  \frametitle{Bus locking}

  \begin{center}
    \pgfuseimage{bus-lock-step3}
  \end{center}

\end{frame}

% -)

\begin{frame}
  \frametitle{Bus locking}

  \begin{center}
    \pgfuseimage{bus-lock-step4}
  \end{center}

\end{frame}

% -)

\begin{frame}
  \frametitle{Direct Memory Access (DMA) / Bus mastering}

  \begin{center}
    \pgfuseimage{dma-step1}
  \end{center}

\end{frame}

% -)

\begin{frame}
  \frametitle{Direct Memory Access (DMA) / Bus mastering}

  \begin{center}
    \pgfuseimage{dma-step2}
  \end{center}

\end{frame}

% -)

\begin{frame}
  \frametitle{Direct Memory Access (DMA) / Bus mastering}

  \begin{center}
    \pgfuseimage{dma-step3}
  \end{center}

\end{frame}

% -)

\begin{frame}
  \frametitle{Direct Memory Access (DMA) / Bus mastering}

  Bus mastering is the same principle except it concerns even devices
  with memory transfers and devices with devices transfers.

\end{frame}

% -)

\begin{frame}
  \frametitle{Example of a bus: ISA}

  \begin{itemize}
  \item
    By IBM in 1981
  \item
    8-bit at 4 MHz, then 16-bit at 8 MHz and EISA 32-bit at 8 MHz
  \end{itemize}

  \-

  We focus on the 16-bit ISA bus.

  \begin{itemize}
  \item
    16-bit I/Os
  \item
    IRQ lines (1, 3, 4, 5, 6, 7, 10, 11, 12, 13 \& 14)
  \item
    DMA channels (1, 2, 3, 5, 6 \& 7), restricted to 24-bit addresses
  \end{itemize}

\end{frame}

% -)

\begin{frame}
  \frametitle{Example of a bus: ISA}

  \begin{itemize}
  \item
    \textbf{D}: data bus
  \item
    \textbf{A}: address bus
  \item
    \textbf{IOW}, \textbf{IOR}: control signals
  \item
    \textbf{IRQx}: IRQ lines
  \item
    \textbf{DRQx}: request for DMA access
  \item
    \textbf{DACKx}: acknowledgment of DMA access
  \item
    \textbf{MASTER}: bus granted
  \item
    \textbf{TC}: bus holding
  \end{itemize}

\end{frame}

% -)

\begin{frame}
  \frametitle{Devices}

  Basically, a device provides:

  \begin{itemize}
  \item
    Configuration Registers, used to program the behavior of the device
  \item
    Control Registers, to trigger actions
  \item
    Status Registers, for reading the state of the device
  \item
    Data Registers, to send/receive data from the device (alternative
    to DMA, often used for little amount of data)
  \end{itemize}

  \-

  Access to these registers is made via PIOs or memory-mapped I/Os.

\end{frame}

% -)

\begin{frame}
  \frametitle{Example of a device: network card}

  A basic network device has:

  \begin{itemize}
  \item
    Configuration registers for sender and receiver modules, to enable
    broadcast packets reception for example, or automatic computation
    of Ethernet checksum for outgoing packets
  \item
    Control registers, to ask for sending a packet
  \item
    Status registers, to check for packets waiting in the receive
    ring, also for get error reasons when sending packets
  \item
    Data registers, for exemple a set of registers that contains the
    MAC address of the board, and in worst cases, data registers used
    when sending/receiving packets
  \end{itemize}

  \-

  \begin{itemize}
  \item
    One IRQ line, to interrupt the CPU on packet receiving or sending error
  \item
    One or two DMA channels for packet transfers between the NIC and
    the system RAM
  \end{itemize}

\end{frame}

%
% microprocessor's internals
%

\subsection{Microprocessor's internals}

% -)

\begin{frame}
  \frametitle{General description}

  \emph{A central processing unit (CPU), or sometimes simply
  processor, is the component in a digital computer that interprets
  computer program instructions and processes data.} -- Wikipedia

  \-

  A few important concepts:

  \begin{itemize}
  \item
    In-order execution: instructions are executed in the order of the
    program. Older microprocessors, but Sun's UltraSPARC is still
    using this design.
  \item
    Out-of-order execution: instructions can be rescheduled by the
    microprocessor (dynamic dataflow, speculative execution\ldots)
  \item
    Superscalar engine: multiple executions can be executed in the same cycle.
  \item
    Multithread core: multiple instructions from different instruction
    streams can be executed at the same time.
  \item
    Multicore: the same microprocessor includes multiple execution
    units, pipelines, pipelines\ldots{} Everything is duplicated (like
    with multiprocessor) except the caches.
  \end{itemize}

\end{frame}

% -)

\begin{frame}
  \frametitle{Program processing}

  \begin{itemize}
  \item
    CISC: many instructions, with side-effects, multiple memory
    accesses, few registers\ldots
  \item
    RISC: only essential instructions, other functions can be built
    using multiple instructions, lots of registers
  \end{itemize}

  \-

  Flynn's classification:

  \begin{itemize}
  \item
    SISD: classical uniprocessor
  \item
    SIMD: through extended instruction set
  \item
    MISD: redundant computation for example
  \item
    MIMD: multiprocessor
  \end{itemize}

\end{frame}

% -)

\begin{frame}
  \frametitle{Reserved registers and ABI}

  Few registers are reserved, either by the microprocessor itself or
  by some specifications used by compilers.

  \begin{itemize}
  \item
    Stack and Frame Pointer
  \item
    Return Value
  \item
    Return Address
  \item
    Global Storage Area
  \end{itemize}

  Example on SPARC V8 :

  \begin{center}
  \begin{tabular}{|c|c|c|}
    \hline
    Register & Description & Imposed by \\
    \hline
    g1 & global storage area & ABI \\
    \hline
    i0 & value to return & CPU \\
    \hline
    o0 & value returned & CPU \\
    \hline
    i6 & frame pointer & ABI \\
    \hline
    o6 & stack pointer & ABI \\
    \hline
    o7 & return address & CPU \\
    \hline
  \end{tabular}
  \end{center}

\end{frame}

% -)

\begin{frame}
  \frametitle{Reserved registers and ABI}

  Some registers are considered caller-save or callee-save, meaning
  they can or cannot be modified by inside functions. These rules
  depends on calling conventions.

  \-

  Example on x86 :

  \begin{center}
  \begin{tabular}{|c|c|c|}
    \hline
    Register & Is \\
    \hline
    EAX, ECX, EDX & Caller-save \\
    \hline
    EBX, ESI, EDI, ESP, EBP & Callee-save \\
    \hline
  \end{tabular}
  \end{center}

\end{frame}

% -)

\begin{frame}
  \frametitle{Execution units}

  A microprocessor is made of several execution units that can issue a
  given operation using specified operands.

  \begin{itemize}
  \item
    Arithmetic and Logic Unit (ALU), performs additions, multiplications, shifts\ldots
  \item
    Load/Store Unit, performs memory accesses
  \item
    Floating Point Unit (FPU), performs IEEE 754 operations
  \item
    Extensions, including SIMD Units
  \end{itemize}

  There can be one or more unit of each type. If there are only one
  adder and the CPU is able to execute two instructions at a time,
  these instructions cannot be both additions.

\end{frame}

% -)

\begin{frame}
  \frametitle{Very simple microprocessor}

  \begin{center}
    \pgfuseimage{cpu}
  \end{center}

  This is a one bus architecture.

\end{frame}

% -)

\begin{frame}[containsverbatim]
  \frametitle{Microcode}

  On such microprocessors, instructions are programmed into the CPU
  using micro-instructions.

  \-

  With previous microprocessor, here is the microcode for an addition
  of a register R1 and a memory operand at address R2, with result in
  R1.

  \begin{verbatim}
R2 -> @
read
wait for memory operation
D -> X
R1 -> Y
add
R -> R1
  \end{verbatim}

\end{frame}

% -)

\begin{frame}
  \frametitle{Introduction to pipelines}

  \begin{center}
    \pgfuseimage{pipeline}
  \end{center}

\end{frame}

% -)

\begin{frame}
  \frametitle{Introduction to Re-Ordering Buffer (ROB)}

  \begin{center}
    \pgfuseimage{rob}
  \end{center}

\end{frame}

% -)

\begin{frame}
  \frametitle{Memory Management Unit}

  The role of a MMU is to process ``logical'' addresses used in
  programs into ``physical'' addresses that can be accessed in RAM.

  \-

  \begin{center}
    \pgfuseimage{mmu}
  \end{center}

  Multiple kind of translation rules can be used depending on the
  processors abilities. Error and privilege checking can be used.

\end{frame}

% -)

\begin{frame}
  \frametitle{Caches}

  \begin{center}
    \pgfuseimage{cache}
  \end{center}

\end{frame}

% -)

\begin{frame}
  \frametitle{Caches}

  \begin{center}
    \pgfuseimage{cache-step1}
  \end{center}

\end{frame}

% -)

\begin{frame}
  \frametitle{Caches}

  \begin{center}
    \pgfuseimage{cache-step2}
  \end{center}

\end{frame}

% -)

\begin{frame}
  \frametitle{Caches}

  \begin{center}
    \pgfuseimage{cache-step3}
  \end{center}

\end{frame}

% -)

\begin{frame}
  \frametitle{Caches}

  \begin{center}
    \pgfuseimage{cache-step4}
  \end{center}

\end{frame}

% -)

\begin{frame}
  \frametitle{Caches}

  \begin{center}
    \pgfuseimage{cache-step5}
  \end{center}

\end{frame}

% -)

\begin{frame}
  \frametitle{Running modes}

  A microprocessor can operates in multiple modes :

  \begin{itemize}
  \item
    Kernel mode, or Privileged mode or Supervisor mode : the one used by the kernel
  \item
    User mode : to run applications
  \end{itemize}

  There can be extended mode, depending on microprocessor's
  specifications :

  \begin{itemize}
  \item
    Error recovery : to avoid crash when critical error occurs
  \item
    Halt mode : the microprocessor is executing nothing, waiting for external interrupts
  \item
    \ldots
  \end{itemize}

\end{frame}

% -)

\begin{frame}
  \frametitle{Exceptions, IRQ and soft-interrupts}

  \begin{center}
    \pgfuseimage{event-step1}
  \end{center}

\end{frame}

% -)

\begin{frame}
  \frametitle{Exceptions, IRQ and soft-interrupts}

  \begin{center}
    \pgfuseimage{event-step2}
  \end{center}

\end{frame}

% -)

\begin{frame}
  \frametitle{Exceptions, IRQ and soft-interrupts}

  \begin{center}
    \pgfuseimage{event-step3}
  \end{center}

\end{frame}

% -)

\begin{frame}
  \frametitle{Inter-Processor Interrupts (IPI)}

  \begin{center}
    \pgfuseimage{ipi-step1}
  \end{center}

\end{frame}

% -)

\begin{frame}
  \frametitle{Inter-Processor Interrupts (IPI)}

  \begin{center}
    \pgfuseimage{ipi-step2}
  \end{center}

\end{frame}

% -)

\begin{frame}
  \frametitle{Inter-Processor Interrupts (IPI)}

  \begin{center}
    \pgfuseimage{ipi-step3}
  \end{center}

\end{frame}

% -)

\begin{frame}
  \frametitle{Bus snooping}

  Notice that for the previous problem (cache consistency), some
  microprocessors use \textbf{bus snooping} to keep the caches
  consistent.

\end{frame}

%
% operating systems
%

\subsection{Operating systems}

% -)

\begin{frame}
  \frametitle{Program loading}

  \begin{center}
    \pgfuseimage{elf}
  \end{center}

\end{frame}

% -)

\begin{frame}
  \frametitle{System calls}

  \begin{center}
    \pgfuseimage{syscall}
  \end{center}

\end{frame}
