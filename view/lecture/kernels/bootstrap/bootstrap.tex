%
% ---------- header -----------------------------------------------------------
%
% project       kaneton
%
% license       kaneton
%
% file          /home/mycure/kane.../lecture/kernels/bootstrap/bootstrap.tex
%
% created       julien quintard   [wed may 16 19:06:48 2007]
% updated       julien quintard   [wed may 16 19:09:27 2007]
%

%
% figures
%

%
%\pgfdeclareimage[interpolate=true,width=188pt,height=97pt]
%                {sample}
%		{figures/sample}

% openboot

\pgfdeclareimage[interpolate=true,width=232pt,height=140pt]
                {devtree}
		{figures/devtree}
\pgfdeclareimage[interpolate=true,width=222pt,height=180pt]
                {ofw}
		{figures/ofw}

%
% Processor hard reset
%

\begin{frame}
  \frametitle{Processor initialization}

  At power-up, the processor performs a hardware initialization which sets its registers in a known state.

  \-

  \begin{itemize}
  \item general purpose registers
  \item status registers (operating mode)
  \item caches invalidation
  \item program counter
  \end{itemize}

  \-

  After this hardware reset, an optional Built-In Self-Test (BIST) may be also performed.

  \-

  At this point, the processor fetches an executes the first instruction from the {\em PC} register. This instruction is the BIOS entry point (the BIOS is mapped in memory).

  \-

  SCHEMA (man 3 Intel figure 9-3)

\end{frame}

%
%
%

\begin{frame}
  \frametitle{The BIOS}

  BIOS stands for Basic Input Output System.

  \-

  It is a program stored in a motherboard EPROM and whose role is to:
  \begin{itemize}
  \item Set the basic hardware devices in a known state.
  \item Provide standard routines to support basic operations on boot devices.
  \end{itemize}

  \-

  The BIOS is mapped in memory within a fixed addresses range. Within this range, the BIOS entry point matches the initial {\em PC} value. Thus, the BIOS is automatically executed by the processor at boot-on.

\end{frame}

%
%
%

\begin{frame}
  \frametitle{BIOS interrupts}

  To deal with the hardware, the BIOS provides a set of basic routines to:

  \begin{itemize}
  \item read/write disk sectors
  \item display characters on screen
  \item control keyboard inputs
  \item perform a warm boot
  \end{itemize}

  \-

  These routines are directly called by the BIOS itself, or by other programs, using software interrupts.

  \-

  The BIOS installs an interrupt vector in which every entry contains a pointer to a BIOS routine. Then the processor uses this table to determine which routine to call when a program raise an exception.

  \-

  Parameters are passed through the registers.

\end{frame}

%
%
%

\begin{frame}
  \frametitle{BIOS boot sequence}

  \begin{enumerate}

  \item The BIOS installs its interrupt vector in RAM

  \-

  \item The BIOS first performs the POST (Power-On Self Test) to ensure that vital hardware is present and works properly.

  \-

  \item Then, the BIOS initializes the boot devices, ie all the devices which may be needed to launch the kernel. This includes:

  \-

  \begin{itemize}
  \item input devices (keyboard)
  \item output devices (graphic card)
  \item storage media (hard disk, floppy, usb key\ldots)
  \item network devices (for PXE boot)
  \end{itemize}

  \-

  \item Finally, if everthing is ok, the BIOS choses a boot device and charges the bootloader to load the kernel
  \end{enumerate}

\end{frame}

%
%
%

\begin{frame}
  \frametitle{Vocabulary}

  \begin{description}
  \item {\bf Bootloader}\\
  Program which loads the kernel.

  \nl

  \item {\bf Boostrap}\\
  Procedure while which the kernel is booted.

  \nl

  \item {\bf Bootsector}\\
  Memory area in which the bootloader is stored.
  \end{description}

\end{frame}

%
%
%

\begin{frame}
  \frametitle{BIOS limits}

  {\bf Question:} Why the BIOS does not manage the bootstrap by itself ?

  \-

  \begin{enumerate}
  \item The bootloader is system specific and particularly depends on:

  \begin{itemize}
  \item the device from which to boot
  \item the filesystem installed on the boot device
  \item the kernel binary format
  \end{itemize}

  The BIOS cannot support all binary formats on all filesystems.

  \-

  \item The BIOS cannot find out what the kernel needs to start up.

  \-

  \item The BIOS is not easily updatable since it is written in an EPROM.

  \end{enumerate}

  \-

  For these reasons, the BIOS does not transfer control to the kernel by itself. Instead, it executes a dedicated program whose role is to find the kernel, load it in memory, and execute it. Such a program is called a {\bf bootloader}.



\end{frame}

%
%
%

\begin{frame}
  \frametitle{The bootloader location}

  Depending on the architectures, the bootloader can be either a firmware (seen as a BIOS extension), or a normal program:

  \-

  \begin{itemize}
  \item Sparc, PowerPC, Motorola and Mips provide a firmware : their BIOS just have to jump on the firmware which is stored in an EPROM. This firmware supports advanced features to load the kernel by itself.

  \-

  \item Intel lets developers program their own bootloader. The bootloader must be found in a fixed location on a boot device (usually in the first sector of a disk). Prior to be executed, the bootloader must be loaded in RAM by the BIOS.
  \end{itemize}

  \-

  SCHEMA

\end{frame}

%
%
%

\begin{frame}
  \frametitle{The bootloader tasks}

  In both cases (firmware or program), the bootloader uses the BIOS interrupts to achieve its final goal : run the kernel. This task consists in the following steps:

  \-

  \begin{enumerate}
  \item Load the kernel and everything it needs in RAM
  \item Provide the kernel with the information it needs to work correctly
  \item Install a favorable execution environment
  \item Transfer execution to the kernel
  \end{enumerate}

\end{frame}

%
%
%

%
% sun's openboot
%

\begin{frame}
  \frametitle{OpenBoot (Sun)}

  OpenBoot (or OpenFirmware) is the software embedded in all Sun's
  SPARC based stations.

  \-

  OpenBoot offers many services (as the BIOS does) necessary to the
  bootup phase. For example:

  \begin{itemize}
  \item
    Device-tree exploration (\emph{sibling}, \emph{child},
    \emph{getprop}\ldots)
  \item
    Device I/O (\emph{open}, \emph{read}, \emph{write}\ldots)
  \item
    MMU (\emph{map\_phys}, \emph{unmap\_phys}, \emph{itlb\_load},
    \emph{dtlb\_load}\ldots)
  \item
    Environment (boot path, boot device, boot arguments\ldots)
  \item
    Time (\emph{milliseconds})
  \end{itemize}

  \-

  All these functionnalities make OpenBoot a tiny OS. In addition,
  OpenBoot is able to run bytecode scripts (in Forth language), to
  load ELF files from disk or network (TFTP) and to debug programs
  (disassembly, registers dump, calls trace\ldots).

\end{frame}

% -)

\begin{frame}
  \frametitle{OpenBoot device-tree example}

  \begin{center}
  \pgfuseimage{devtree}
  \end{center}

\end{frame}

% -)

\begin{frame}
  \frametitle{OpenBoot call}

  Calling OpenBoot is as simple as jumping to the so-called
  \emph{firmware entry-point} (given in register \%g7 at boot time)
  with a structure in first argument (register \%o0). This structure is
  as follow:

  \begin{itemize}
  \item
    A pointer to a string indicating the name of the function to call.
  \item
    The number of arguments \emph{N}
  \item
    The number of return values \emph{M}
  \item
    \emph{N} 64-bit arguments
  \item
    \emph{M} 64-bit slots for results
  \end{itemize}

\end{frame}

% -)

\begin{frame}
  \frametitle{OpenBoot example}

  \begin{center}
  \pgfuseimage{ofw}
  \end{center}

\end{frame}

%
% sgi's arc
%

\begin{frame}
  \frametitle{ARCS (SGI)}

  ARCS is the firmware used in all SGI MIPS-based stations. ARCS has
  also been used on a few Pentium-based stations, in replacement of
  the traditional BIOS.

  \-

  ARCS offers:

  \begin{itemize}
  \item
    Device-tree functions (\emph{GetPeer}, \emph{GetChild},
    \emph{GetComponent}\ldots)
  \item
    Device I/O (\emph{open}, \emph{read}, \emph{write}\ldots)
  \item
    Filesystem supports, FAT and ISO9660 (\emph{mount}, \emph{open},
    \emph{read}\ldots)
  \item
    Environment variables
  \item
    Time (\emph{GetTime})
  \end{itemize}

  \-

  ARCS is also able to load ELF files, from disk or network.

\end{frame}

% -)

\begin{frame}
  \frametitle{ARCS System Parameter Block}

  The System Parameter Block (SPB) is a structure filed by ARCS before
  giving the hand to the boot program. The block contains notably the
  Firmware Vector, which is an array of function pointers. Calling
  ARCS is as simple as calling the wanted function from this vector.

\end{frame}

% -)

\begin{frame}
  \frametitle{Bootstraping on IA-32 architecture}

  Booting a kernel under IA-32 is much more pedagogical because Intel architecture does not provide any firmware. Thus, all the work has to be done by the kernel developer.

\end{frame}

%
%
%

\begin{frame}
\frametitle{Loading the kernel}



  {\bf Questions:}


  \begin{enumerate}
  \item {\bf Where to find the kernel ?}\\
  The kernel is a binary file located in a filesystem which is hosted on a hardware device.\\
  Generally, accesses to the hardware devices are performed by the BIOS calls. However, the bootloader has to support the filesystem.

  \-

  \item {\bf How to load the kernel ?}\\
  With the BIOS interrupts

  \-

  \item {\bf Where to load the kernel ?}\\
  The kernel is linked to be executed at a fixed location. If it is not loaded at the right address, the first derefence will probably fail.\\
  The address at which the kernel must be loaded is either statically defined in the bootloader, or found in the kernel binary.
  \end{enumerate}

\end{frame}

%
%
%

\begin{frame}
  \frametitle{Providing system information}

  To boot correctly, a kernel may need to get some information from the system or from the user:

  \begin{itemize}
  \item RAM size, boot device
  \item boot options (graphic mode, root partition \ldots)
  \item modules information
  \end{itemize}

  \-

  The bootloader can pass information through to ways:

  \begin{itemize}
  \item the microprocessor registers
  \item an info structure written in memory. Most often, the structure base address is stored in a register. In some specific cases, this structure can also be found with a magic number.
  \end{itemize}

\end{frame}

%
%
%

\begin{frame}
  \frametitle{Preparing the kernel environment}

  {\bf Microprocessor operating mode}

  \-

  Architecture-dependent code is completly obsolete on a microprocessor for which it has not been written. In the same way, it will not work if the microprocessor is not set in the right operating mode.

  \-

  The bootloader has to turn the processor into the appropriated operating mode before transfering execution to the kernel.

  If this mode requires data structures to be initialized, it also will have to fill it.

\end{frame}

%
%
%

\begin{frame}
  \frametitle{IA-32 example}

  When the IA-32 microprocessor first starts, it initializes itself in {\em real mode} which is the default operating mode since 1969.

  \begin{itemize}
  \item 16-bit instruction set
  \item 20-bit address space (1MB)
  \item Segmented memory
  \end{itemize}

  \-

  Modern kernels all expect to run in protected mode:
  \begin{itemize}
  \item 32-bit instruction set
  \item 32-bit address space (4GB)
  \item	Protection (memory protection, privilege levels)
  \item Advanced memory management facilities (pagination)
  \item Multitasking facilities
  \end{itemize}

\end{frame}

%
%
%

\begin{frame}
  \frametitle{Jumping to the kernel}

  If the bootloader has not been statically informed, it will get useful data in the kernel binary headers. In this case obviously, the bootloader has to support the kernel binary format.

  \-

  Among the needed information, the bootloader needs to find:

  \begin{itemize}
  \item the segments (.text, .data, .bss) loading addresses
  \item the kernel size
  \item the kernel entry point
  \end{itemize}

  \-

  The bootloader finally uses these information to:

  \begin{enumerate}
  \item relocate the kernel if needed
  \item install the system stack
  \item jump to the kernel
  \end{enumerate}

\end{frame}

%
%
%

\begin{frame}
  \frametitle{Bootloader designs}

  \begin{itemize}
  \item {\bf Single stage bootloader}\\
  The whole bootloader is contained in the 512-bytes bootsector. Such a bootloader is limited by its size and cannot provide many options. This kind of bootloader is most often kernel-specific.

  \-

  \item {\bf Two-stages bootloader}\\
  This bootloader is divided in two stages. The first stage, whose only role is to load the second stage, is contained within the bootsector. The second stage is the actual bootloader. The main advantage of this kind of bootloader is to avoid the 512-bytes limitation of the bootsector. Thus, the bootloader can offer advanced features like multiboot, filesystems and binaries support, netboot \ldots

  \-

  \item {\bf Mixed bootloader}\\
  To avoid the 512-byte barrier, the bootloader can be split in two parts, where the first half (512 bytes) can load the rest. This can be achieved by inserting a '512-bytes' break in the ASM code, making sure the rest of the loader is put after the bootsector.
  \end{itemize}


\end{frame}

%
%
%

\begin{frame}
  \frametitle{Multiboot standard}


  Multiboot standard specifies an interface between a boot loader and a operating system.

  \-

  It ains at unifying kernel boot procedures in order to easily allow multiple OSes to coexist on the same machine.

  \-

  Multiboot specifications impose :

  \begin{itemize}
  \item an OS image format
  \item Machine state
  \item Boot information format
  \end{itemize}

\end{frame}

%
%
%

\begin{frame}
  \frametitle{Multiboot header}
  kernel image must :

  \begin{itemize}
  \item be an ordinary 32-bit executable file in the standard format for that particular operating system
  \item contain an additional header called Multiboot header. The Multiboot header must be contained completely within the first 8192 bytes of the OS image, and must be longword (32-bit) aligned.
  \end{itemize}

  \begin{tabular}{|l|l|l|l|l|}
  \hline
  Offset & Type & Field & Description & NameNote\\\hline\hline
  0 & u32 & magic & multiboot magic & required\\\hline
  4 & u32 & flags & flags & required\\\hline
  8 & u32 & checksum & checksum & required\\\hline
  12 & u32 & header\_addr & multiboot header addr & if flags[16] is set\\\hline
  16 & u32 & load\_addr & .text physical addr & if flags[16] is set\\\hline
  20 & u32 & load\_end\_addr & .data end & if flags[16] is set\\\hline
  24 & u32 & bss\_end\_addr & .bss physical end & if flags[16] is set\\\hline
  28 & u32 & entry\_addr & entry point physical addr & if flags[16] is set\\\hline
  32 & u32 & mode\_type  & graphic mode & if flags[2] is set\\\hline
  36 & u32 & width & number of columns & if flags[2] is set\\\hline
  40 & u32 & height & number of lines & if flags[2] is set\\\hline
  44 & u32 & depth & depth & if flags[2] is set\\\hline
  \end{tabular}

\end{frame}

%
%
%

\begin{frame}
  \frametitle{Chainloading}

  Another way to boot multiple systems on the same machine is to use {\em chainloading}.

  \-

  This method consists in booting the system indirectly. This involves asking the bootloader of system A to boot the bootloader of system B and let the system B booted by its bootloader.

  \-

  Any operating system becomes chainloadable if it has a bootloader inside its root partition.

  \-

  As Windows requires to be installed on an active partition, it always installs its bootloader in the root partition. Thus, Windows is often booted via chainloading.

\end{frame}

%
% elf and ld-script
%

% -)

\begin{frame}
  \frametitle{Introduction to ELF}

  \textbf{Executable and Linkable Format} is a widely used file format
  for executables, object code and shared libraries.

  \-

  An ELF file is made of:

  \begin{itemize}
  \item
    Segments: used at runtime when loading the executable to memory.
  \item
    Sections: at linking time and for relocations.
  \end{itemize}

\end{frame}

% -)

\begin{frame}
  \frametitle{Introduction to ELF}

  ELF segments are described using \textbf{program headers} with:

  \begin{itemize}
  \item
    Offset and size of data to load from file
  \item
    Virtual address where to load the segment
  \item
    Physical address where to load the segment (only for architecture
    that supports it)
  \item
    Total size in memory (greater or equal to data size, ex: BSS)
  \item
    Access rights (R-W-X)
  \end{itemize}

  \-

  ELF sections are described with \textbf{section headers} including:

  \begin{itemize}
  \item
    Section name (.text, .bss\ldots)
  \item
    Flags (allocated, writable\ldots)
  \item
    Address where to load/allocate
  \item
    Offset and size of data to load from file
  \end{itemize}

\end{frame}

% -)

\begin{frame}[containsverbatim]
  \frametitle{Customizing ELF: ld scripts (basics)}

  Customizing sections is made using the \textbf{SECTIONS} block:

  \begin{verbatim}
SECTIONS
{
  . = 0x4000000;

  .text : { *(.text*) }

  . = 0x8000000;

  .data : { *(.data*) }

}
  \end{verbatim}

\end{frame}

% -)

\begin{frame}[containsverbatim]
  \frametitle{Customizing ELF: ld scripts (basics)}

  \begin{verbatim}
Program Headers:
  Type           Offset   VirtAddr   PhysAddr   FileSiz MemSiz  Flg Align
  LOAD           0x001000 0x04000000 0x04000000 0x0002d 0x0002d R E 0x1000
  LOAD           0x002000 0x08000000 0x08000000 0x00004 0x00008 RW  0x1000
  GNU_STACK      0x000000 0x00000000 0x00000000 0x00000 0x00000 RW  0x4

 Section to Segment mapping:
  Segment Sections...
   00     .text
   01     .data .bss
   02
  \end{verbatim}

\end{frame}

% -)

\begin{frame}[containsverbatim]
  \frametitle{Customizing ELF: ld scripts (basics)}

  Customizing segment can be done through the \textbf{PHDRS} block:

  \begin{verbatim}
PHDRS
{
  code PT_LOAD;
  data PT_LOAD;
}
  \end{verbatim}

  \-

  Then is it possible to assign sections into a specified segment:

  \begin{verbatim}
SECTIONS
{
  . = 0x4000000;
  .text : { *(.text*) } : code

  . = 0x8000000;
  .data : { *(.data*) *(.rodata*) *(.bss*) *(COMMON) } : data
}
  \end{verbatim}

\end{frame}

% -)

\begin{frame}[containsverbatim]
  \frametitle{Customizing ELF: ld scripts (basics)}

  \begin{verbatim}
Program Headers:
  Type           Offset   VirtAddr   PhysAddr   FileSiz MemSiz  Flg Align
  LOAD           0x001000 0x04000000 0x04000000 0x0002d 0x0002d R E 0x1000
  LOAD           0x002000 0x08000000 0x08000000 0x00008 0x00008 RW  0x1000

 Section to Segment mapping:
  Segment Sections...
   00     .text
   01     .data
  \end{verbatim}

\end{frame}

% -)

\begin{frame}[containsverbatim]
  \frametitle{Customizing ELF: ld scripts (basics)}

  It is possible to declare symbols in ldscripts.

  \begin{verbatim}
.data : { *(.data*) }

__cpu_data_start = LOADADDR(.data);
__cpu_data_end = LOADADDR(.data) + SIZEOF(.data);
  \end{verbatim}

  Now, \emph{\_\_cpu\_data\_start} and \emph{\_\_cpu\_data\_end} can
  be used as classical variables into your C program.

\end{frame}

% -)

\begin{frame}
  \frametitle{Why customizing ELF binaries}

  The bootloader needs to load the appropriate segments from the ELF
  file into the right places in memory.

  \-

  By writing your own rules for generating the ELF, you will know in
  advance what your binary looks like.

  \-

  The easiest kind of binary to load is one-segment binary (every
  sections are following each other), only one header to read from the
  ELF.

\end{frame}

%
%
%

%
% bibliography
%

\begin{thebibliography}{4}

%  \bibitem{ID}
%    Sample
%    \newblock Sample

\end{thebibliography}
