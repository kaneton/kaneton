%%
%% copyright     (c) julien quintard
%%
%% project       kaneton
%%
%% file          /home/mycure/kaneton/view/papers/design/design.tex
%%
%% created       julien quintard   [sat nov 19 19:02:11 2005]
%% updated       julien quintard   [wed nov 30 14:17:17 2005]
%%

%
% template
%

\input{../../templates/paper.tex}

%
% header
%

\lhead{\scriptsize{The kaneton design concepts}}

%
% title
%

\title{The kaneton microkernel project}

%
% authors
%

\author{\small{Julien Quintard}}

%
% document
%

\begin{document}

%
% title
%

\maketitle

%%
%% --------- abstract ---------------------------------------------------------
%%

\begin{abstract}

This paper describes the design of the kaneton microkernel.
This system was designed to be ported on many architectures without being
intrusive. Moreover, the main goal of this system was to design a powerful
system able to adapt itself on a network constantly in evolution and to
provide a transparent and easy way to migrate processes, communicate
with system's entities and to be fault tolerant.

\end{abstract}

%
% --------- text --------------------------------------------------------------
%

\begin{multicols}{2}



\section{The kaneton history}

kaneton originated at the EPITA Computer System Laboratory as a pedagogic
project in operating systems. The project was primarily designed by two students
Julien Quintard and Jean-Pascal Billaud although many other people also
contributed to the design and will especially contribute to the implementation.

Having recently developed a micro-kernel base operating system called LSE/OS,
the two students decided to begin the design and development of an operating
system with a more powerful design and able to share resources on a large
network. Nevertheless, the goal of this project remains to be a pedagogic
one. For this reason special interest was made on the design and on the
implementation to be as simple as possible.




\section{The kaneton goals}

Many research projects in operating systems started with an existing system.
For the kaneton microkernel project, we decided to totally design a
new system. Indeed, the previous EPITA Computer System Laboratory projects in
operating systems were not portable enough, so we decided to totally design
this new kernel from scratch with a special interest for the portability.

The primary goal of the kaneton operating system was to design a distributed
operating system but to be totally transparent from the user point of view.
Moreover, a special interest was made on scalable networks, especially
to manage the distributed system nodes neither in a totally centralized way
nor in a totally distributed way but rather in a more moldable way where groups
constantly evolve in size. Another goal was to provide an abstraction to
communications in the distributed system. In addition, the kaneton distributed
operating system will provide a transparent and easy way to migrate processes
on the network, to manage distributed memory while being fault tolerant.

The kaneton operating system was first developed to look like a typical
timesharing system to the user. Nevertheless, kaneton was also designed to
become a very scalable system and to provide a powerful system for
parallel and distributed programming.



\section{The kaneton architecture}

Before describing the kaneton microkernel internals or the kaneton distributed
operating system, it is useful first to outline the kind of hardware for
which the system was designed.

The kaneton microkernel has been designed to deal with multiple architectures
and heterogeneous systems. It was designed with two main requirements about the
hardware:

\begin{enumerate}

\item Virtual memory is needed by the microkernel.
\item Each CPU must have about tens of megabytes of memory.

\end{enumerate}

The kaneton microkernel can be ported on any architecture which respects these
requirements.



\section{The kaneton microkernel}

The kaneton operating system is composed of two parts: a \textbf{microkernel}
which runs on every processor machine of the system and a collection of
\textbf{servers} that provide most of traditional operating system
functionalities: drivers, file servers etc..

We will see later that the term \textbf{server} is not used in the kaneton
documentation. Instead the terms: driver, service etc.. will be used.

The kaneton microkernel runs on every machine of the system including
workstations, the pool processors, specialized servers etc.. The microkernel
has four primary functionalities to provide:

\begin{enumerate}

\item Communication
\item Memory management
\item Process management
\item I/O

\end{enumerate}

We will now describe microkernel's components to understand how the kaneton
microkernel provides communication, memory management, process management etc..

\subsection{Objects And Protections}

To protect objects on the system, the kaneton distributed operating system uses
capabilities.

A \textbf{capability} provides an easy way to allow other tasks of the
system to access a privileged object.

To illustrate this concept, consider a program which allocate a segment of
physical memory. Then it decides to allow another program to only read
this segment. Then it will generate a less privileged capability and give
it to the other program. After all, the second program will be able to read
the segment but not to write it. This example is not the best in which sharing
segments using this method is not the best choice.

A common capability includes the object identifier, the permissions of the
capability on the object, listing allowed operations, a check field assuring
security and other specific fields like for example the location of the
service, a lifetime etc..

Unlike many distributed systems, the kaneton microkernel uses specific and
specialized capabilites to increase scalability.

Consider a modern file system with billions of inodes; this file system
certainly wants to build capabilities with a 64-bit identifier.
We can now consider another service, for example a printer service, listing
every printer of the system. This service certainly wants to use 16-bit
identifier in its capabilities because there will certainly never be more than
65000 printers on this system. Each service is different so each service
will want to use its own capability's format.

The use of specific and specialized capabilites forces the programs to ask
the services to build new capabilites, unlike other systems. Indeed,
the other systems generally use generic capabilites to permit programs to
generate capabilities by themselves. This was not our choice and the result is
more scalable capabilites but a performance loss in capability generation.

Moreover, using this scheme permit services to use the cryptographic algorithm
they want.

Note that the capability generation does not often happen. Moreover,
a capability can be generated and used by many other tasks because
capabilites are generally used to restrict permissions. A capability
is not unique to its user, so a program can generate a capability and
distribute it to many other programs giving them the same permissions.

To conclude, this system is performant in a normal use but can become
slow if a program has to generate many different capabilities, this case
being rare.

The use of specific capabilities allows services to create capabilities,
for example, without identifier or with extra permission fields.

Nevertheless a capability has to protect operations from malicious programs
trying to generate correct capabilites. For this reason, the check field is
highly recommended.

Note that the use of the check field does not garantee security on a
distributed system. For this reason, the kaneton distributed operating
system can evolve with three security policy:

\begin{enumerate}

\item \textbf{No security}: with this policy, the security field of the
      capabilities are not used. No cryptography is used on the system
      to garantee security.
\item \textbf{Local security}: with it, the capabilities are protected from
      malicious programs and users using the check field. So, while there
      is no network message passing of capabilites, the system can be
      considered as safe.
\item \textbf{Global security}: with this security policy, the distributed
      operating system is safe. Every capability is protected with its check
      field but in addition each message on the network is protected by
      cryptographic algorithms.

\end{enumerate}

\subsection{Communication}

The kaneton microkernel and more generally the kaneton distributed operating
system uses messages to communicate with everything.

A key concept behind the kaneton microkernel is precisly the use of messages
to communicate with everything including, tasks, groups, nodes etc..
The communication unification is one of the choice that many other distributed
operating systems do not make. Instead, many systems uses RPC as the key
mechanism for communication between machines.

The RPC system deals with many problems like memory references from which the
RPC system does not know the size. These problems are very difficult to
resolve and implies many complex mechanisms to install while being performant.

A distributed operating system communicates with other nodes of the system in
a very strict way, dealing with a protocol. So the RPC system seemed to be very
complex for our requirements. We decided to not base our system on it and
instead, to use a simple unified message mechanism. Nevertheless, the RPC
system will be allowed but for the userland applications.

Keep in mind that the kaneton project must be as simple as possible to be
understood by students.

To unify communications via messages, the microkernel translates every event
into a message. For example, when an interrupt is received by the kernel
interrupt handler, a message is built and forwarded to the server dedicated
to this interrupt. So, each server just has to take care of how to receive
messages and how to reply them.

Note that no group communication is provided by the microkernel. Indeed, the
group communication concept is inherent to the distributed operating system.
The group communication will be explained later in this paper.

The microkernel includes an authentification mechanism to protect tasks from
sending messages everywhere they want to. To communicate with another task
which will commonly be a server, the client has to ask a capability to
the authentification server. Then the client will be allowed to send messages
to the server. The authentification server is described later in this paper.

\subsection{Memory}

The memory model of the kaneton microkernel is very simple. Each address space
of the system is composed of segments and regions.

A \textbf{segment} consists of a linear sequence of physical addresses.
A segment describes one area of physical memory including the
first address, the last but also some properties like the owner of this
segment, the permissions: execution, read, write etc.. and some
extra attributes. Segments can be accessed via mappings or directly via
the segment interface provided by the kaneton microkernel. Each segment
is identified by an unique identifier and manipulated with a capability.

A \textbf{region} consists of a linear sequence of virtual addresses.
A region has no properties and is only used to map a valid segment.
Using a region in the virtual memory will reference the segment's data
it maps.

An \textbf{address space} is a list of memory locations. In the kaneton
microkernel, an address space includes the list of the segments and regions.
So an address space describes the available process' memory. An address space
is identified by its unique identifier and manipulated with a capability.

Like all the system, the kaneton memory model is based on little objects which
are linked to build more complex objects. An address space is composed
of segments and regions. This model implies that a program is allow to
manages its entire memory itself, its physical memory like its virtual one.

This design leads to very interesting features and more parallelism.
The kernel is now able to create a dozen of address spaces, and then to
insert into them segments and regions. Moreover it is now possible to allocate
segments and to migrate them to another address space without effort. This
memory model also permits to easily recycle data structures because each one
is independent from others.

\subsection{Set}

The kaneton microkernel internally uses a set manager which organizes data
for other kernel managers. Each set is identified by an unique identifier.
The entire microkernel is based on the sets.

Using this manager leads to a very elegant and maintenable source code. From
this fact, every kernel manager uses the set manager to store its data. For
example the task manager uses the set manager to store every task of the
system. Additionnaly, each task contains a set composed of the threads of
this task.

Such a system provides an easy way to store data without effort. From this
fact, the task manager for example do not care about how to store data.

Moreover, it is possible to optimize the code where it is needed. In this
case, it will be useful to optimize the data structures in the set manager
and \textit{not} in every manager using such a data structure like
other systems do.

Indeed, the other operating systems generally use pointers to link kernel
structures together and implicitly form sets. Nevertheless, such a source code
is human unreadable and leads to many programming confusions and errors.

kaneton being a pedagogic distributed operating system project, we wanted
to use the simplest design possible.

The set manager provides many different data structures like linked-list,
double linked-list, circular queue, stack, pipe, array, binary tree, b+-tree
etc.. Moreover the set manager can be extended without affecting the others
managers using it.

In this way, every kernel manager is now able to use the set manager to
store its data. The set manager also provides tools like \textbf{iterators}
to easily and quickly go through sets.

\subsection{Process}

The kaneton microkernel uses a specific nomenclature which is different
from other operating systems.

The system is composed of five different entities in relation with execution.

A \textbf{module} represents a passive execution entity in main memory.
Indeed, a module does not run and has no execution context. The modules are
managed by the module service to reside in main memory the time it is
necessary. For example a very used program like \textit{/bin/ls} certainly
becomes an important module due of its use. Fundamental system's drivers
and services are persistent modules because they will be used in the case
of a crash to restart the crashed service without any dependency.
A module is identified by a unique identifier and manipulated with a
capability.

A \textbf{program} is the lowest privileged task on the system.
The common user programs are the well-known UNIX{\scriptsize \copyright}
programs like \textit{/bin/ls}, \textit{/bin/wc}, \textit{/usr/bin/cc} etc..
A program is a task with no privilege. All it can do is compute some things,
manage data and send messages to more privileged processes.

A \textbf{service} is a server which provides a so-called service. A service
waits for messages, perform a task, and return the result of the service.

A \textbf{driver} is a service which can communicate with hardware devices.
So, the I/O operations are reserved to tasks which are at least a driver.

Finally, a \textbf{core} is a kind of super-driver in which it provides
many services while communicating with hardware devices. Moreover, it is
the only task able to modify every system's internal data structure.

Every task can only be called by less or equal privileged tasks.

The kaneton microkernel does not have processes in the
UNIX{\scriptsize \copyright} terms. Indeed, the kaneton microkernel manages
tasks. A \textbf{task} is a non-active entity because a task is never scheduled.
A task, in the kaneton terms, is a container which describes an executive
environment, context. Each task has an address space describing its useable
memory and one or more threads. A task with only an address space and one
thread is essentially identical to a UNIX{\scriptsize \copyright} process.
The term \textbf{process} will sometimes be used in this paper and more
generally in the kaneton documentation to describe a kaneton task.

Each task of the kaneton system is manipulated with a capability including
its unique identifier.

The consequence of this scheme is a huge parallelism for the
task creation and more generally in all operations in relation with
a task or a subpart of tasks. For example, the kernel can create all
address spaces, then all threads and at the end link them to tasks before
running them. Moreover, this scheme facilitates the recycling of data
structures: task, thread, address space, etc.. Indeed, it is now possible to
unlink, for example, an address space either to release it or to link it to
another task.

The \textbf{thread} is the active entity because it is this one which is
scheduled. Such a thread has a single address space, belongs to a single
task, has a set of registers, a program counter and finally a stack.
Needless to say that the kaneton microkernel handles threads as kernel threads.
Each thread has an unique identifier and is manipulated by a capability.

Like address spaces and many other parts of the system, a more complex
object is created by linking simpler one together. The process of task creation
it listed below:

\begin{enumerate}

\item a task structure is reserved
\item an address space is linked to the task
\item one or more threads are linked to the task

\end{enumerate}

Each task has three important properties: a class, a behaviour and a priority.

The \textbf{class} is chosen at the task creation time. This property
informs the kernel about the nature of the task, its role on the system.
In addition, this class will implicitly determine the rights of the task
on the system. The different classes are \textit{kernel}, \textit{driver},
\textit{service}, \textit{program}. On many architectures, the kernel, driver
and service classes will have the same hardware system priority.
Nevertheless few architectures provides different hardware system privileges
like Intel Architecture.

The \textbf{behaviour} specifies the kernel, the type of the task from the
scheduler point of view. The different values for the behaviour are
\textit{kernel}, \textit{realtime}, \textit{interactive}, \textit{timesharing}
and \textit{backgroud}. Each behaviour defines a range of priorities for the
task.

The \textbf{priority} is a value included in the range defined by the
task behaviour. Any thread of a task can update the priority of its
task in this range modifying the task priority from the scheduler
point of view.

With these properties, a user can create a task very reactive setting an
appropriate behaviour and then update its priority to adjust its quantum.
This mechanism gives the programs many possibilities and permits them to
choose their execution context.

The threads also have an important property: a priority.

Each thread of a task can set its own priority in the range \textbf{[10, 250[}.
From this fact, a thread can set itself an higher priority than the other
threads of its task. The resulting effect is a thread having a longer quantum.
Once again, this mechanism give more liberty to the programs.

\subsection{Processor}

The processor manager also and commonly called cpu manager provides a small
set of primitives to manage the processors on which a task run.

Each thread of the system has the possibility of choosing the processors
on which they want to be run or more precisly the processors which are allowed
to run this thread.

This feature was directly imported from the Mach operating system.
Indeed this mechanism provides the threads of a task the possibility of
settle, distribute the processors in the best way for the program
execution on multiprocessors. The scheduling is done using priorities,
so the programmer has fine-grain control over which threads
are most important and which are least important.

Each processor of each machine has an unique identifier and is manipulated
with a capability.

\subsection{Servers}

Let's talk about the most important servers of the kaneton microkernel.

\subsubsection{Module}

The module service keep track of the current modules.

With each module is associated a \textbf{lifetime} specifying module's
importance. With it, the module service will be able to release certain
modules due to their uselessness. Nevertheless, few modules have a
unlimited lifetime due to their fundamental use. For example the module
corresponding to the IDE driver binary will always reside in the module
service's main memory to be re-launched if the current IDE driver crashes.
This mechanism provides an easy way to lauch fundamental servers independlty
of others.

Due to this mechanism, the programs have to ask the module service to load
a binary into their address spaces. Notice that from this fact, the module
service role is also to bind server's name to modules' identifier. By this
the kernel \textit{never} handles strings in its core source code, resulting
in a simpler source code.

The module service is divided into two parts. The first one called \textbf{mod}
manages modules, lifetime and loads the module into tasks' address spaces
when needed. The other part called \textbf{modfs} is a main memory file
system listing current modules managed by the module manager.

When a program asks the module service to load a module into its address
space, the module manager just reserve a region into the program's address
space, mapping the shared segment corresponding to the module's binary in
main memory.

\subsubsection{Name}

The name service \textbf{ns} provides few primitives to locate services
either on the local machine or on the network.

Indeed, the name service is composed of two parts, the centralized name
service \textbf{cns} which is used to locate drivers, services etc.. on
the local machine and the distributed name service \textbf{dns} which is
used to locate nodes, groups, etc.. on the distributed operating system.
The distributed name service and more precisly the name group will be
explained later in the paper.

The name service was introduced to provide dynamic service execution, allowing
concurrency. Indeed, the name service can decide to dispatch the work between
few identical services. Moreover, the concurrency is allowed and a client
can ask the name service to locate a precise service.

\subsubsection{Authentification}

The \textbf{auth} service checks if two tasks are allowed to communicate.

When a task wants to send a message to another one, it first has to ask
the authentification service a capability allowing it to send messages. Then,
when sending a message, the kernel will check the capability's validity.
For example, the IDE driver should only receive messages from the file systems.
A user application trying to forge an illegal message will be refused.

Moreover, the authentification service will establish a blacklist listing
malicious programs and/or users, preventing system saturation or other
problems.

\subsubsection{Shared Memory}

The shared memory service commonly called the \textbf{sm} service is used
to shared segments with other address space.

The shared memory manager is composed of two subparts, the centralized
shared memory \textbf{csm} and the distributed shared memory \textbf{dsm}.
Each one manages shared memory in its context either on the local system
or on the global distributed system.

Using the shared memory manager ensures that the memory will not be release
if one or more programs are using it.

The distributed shared memory service is used to share memory with
programs on the network. Moreover, it provides a way to reserve huge amount
of memory even if not available on the host machine. The distributed shared
memory group will be explained later in this paper.

\subsection{Conclusion}

\paragraph{}

The kaneton microkernel uses a simple paradigm which allow programmers to
manage memory and execution context as they wanted to. A special interest
was ported on the parallel and distributed programming providing complete
primitives to manage priorities on many levels: thread, task and processor.

To conclude, the kaneton microkernel allows programs to manage their objects
themselves to scale little by little to a better resources distribution.

\end{multicols}

\end{document}
