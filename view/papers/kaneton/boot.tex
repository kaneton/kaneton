%%
%% licence       kaneton licence
%%
%% project       kaneton
%%
%% file          /home/mycure/kaneton/view/papers/kaneton/boot.tex
%%
%% created       matthieu bucchianeri   [mon jan 30 17:33:29 2006]
%% updated       julien quintard   [tue apr  4 12:31:49 2006]
%%

%
% boot
%

\chapter{Boot}

---

In this chapter we will describe the kaneton core design and implementation.

We will first describe the bootloader before describing the core itself.
Note that many design choices make the bootloader understanding difficult
to students. We will try to explain the design choices to make things
clear.

Then we will describe the core's managers taking care of specifying the
interface it provides.

\newpage

%
% text
%

\begin{comment} % XXX

The kaneton core must be launched by a compliant kaneton bootloader.

This kaneton bootloader can be launched by another bootloader like
well known \textit{GRUB} or \textit{LILO} multi-bootloaders or directly
by the machine boot system.

%
% bootloader
%

\section{Bootloader}

In kaneton, one of the bootloader's role is to prepare a correct
execution context for the core.

To do so, the bootloader has to install the proper memory addressing model
the kernel is expecting, depending on the architecture.

Another bootloader's role is to provide the kernel enough information
on the current microprocessor's architecture.

To do so, the bootloader has to fill in an initialization structure which
will be passed to the kernel at its boot time.

This structure will inform the kernel of the location of some
fundamental objects like the kernel code, the kernel stack, the initialization
structure, the modules, the pre-reserved segments, the pre-reserved regions
and the alloc survival area.

We will now detail some of these components.

%
% modules
%

\subsubsection{Modules}

We call \textbf{module} any additionnal file passed at the boot time.

A module can be a picture, a binary object, a configuration file
or anything else.

Do not consider a module in the other kernels terms. A kaneton module
can be anything while the term \textit{module} is generally used to describe
a kernel module, a dynamic part of code which can be attached to the
running kernel.

In kaneton, modules are used to pass the kaneton configuration file
which contains the kaneton parameters and describes the kaneton servers
to launch as soon as possible. The kaneton servers' binary objects to
launch are also passed as modules.

Of course the bootstrap has to handle kind of modules, otherwise it will
not be capable of passing them to the bootloader. For this reason,
a multi-bootloader is generally used as kaneton boostrap.

The bootloader must build a special data structure containing everything
necessary to get access to the modules including: number of modules,
modules' information, modules' content etc..

In fact, the kernel itself will not use the modules. Indeed, a dedicated
server will be launched by the kernel and will get access to the modules.
Then this dedicated server will launch the very first servers.

To do so, the kernel will first launch this dedicated server and then
will explicitly give the area containing the modules to this dedicated
server.

It is obviously simpler to give a single area containing the modules
stuff rather than giving an area containing the modules information, then
an area per module and finally another area containing the modules' string
names.

For these reasons, a very specific area must be built to contain
to whole stuff in relation with the modules so the kernel just has to
give this area to the dedicated server.

The modules area has the following form:

\begin{enumerate}
  \item
    A \textit{t\_modules} structure specifying some general information on
    the modules like the number of modules.
  \item
    An array of variable length modules, each module being composed of:

    \begin{enumerate}
      \item
	A descriptor \textit{t\_module} containing the module's size and
	a pointer to the module's name.
      \item
	The module content.
      \item
	The module's string name terminated by a zero character.
    \end{enumerate}
\end{enumerate}

Be careful, the array of modules is a variable length item array.
Module data and name are variable length blocks.

The dedicated server will refer to the module descriptors to browse
throught the modules.

The calculation used to compute the next module address is:

\begin{verbatim}
sizeof(t_module) + module->size + strlen(module->name) + 1
\end{verbatim}

\notice{A smart idea would be to add a \textit{next} field in the
  \textit{t\_module} structure to directly go through the next module.
  Obviously we could add another interesting field: \textit{content}
  referencing the module's data.}

%
% segments
%

\subsubsection{Segments}

A \textbf{segment} is simply a contiguous area of used physical memory.

Notice that a segment in the kaneton terms has nothing to do with
a segment in some architectures terms.

In fact, the kaneton microkernel has to provide physical memory operations to
reserve, release physical memory areas or segments. To do so, the kaneton
core is composed of a segment manager which provides an interface to
manipulate the segments.

As an example, let's consider the segment reservation which is a very
common segment operation. This operation looks for a contiguous area
of unused physical memory in its internal data structure and then
returns an identifier on this area.

Now, consider that, at the microkernel boot time, the segment manager has
an empty data structure. Then the segment manager can choose any
unused area and return an identifier on it. \textit{any unused area} means
any unused physical memory area including the kernel code area, the kernel
stack area, the modules area, the architecture dependent areas like maybe the
video mapped memory area and the BIOS mapping area etc..

You should understand that the kaneton core needs to know which physical
memory area should not be reserved or in other terms, are pre-reserved.

So, the bootloader must build a data structure containing the set of
pre-reserved segments. By pre-reserved segments we mean every fundamental
and distinctive areas. We will call this simple data structure the
\textit{segment array}.

This data structure will be used by the task manager to properly
initialize the kernel's address space used by the kernel task object.

In other words, this segment array describes the initial state of the
segment manager, so the initial state of the physical memory held by the
kernel.

Therefore it will be impossible, for example, to reserve an area
already held for something else because the segment manager internal
data structure now contains the pre-reserved segments held by the
core.

The segment array contains segment objects which are partially
initialized. Indeed, some segment object properties cannot be set
by the bootloader and will be set by the segment manager.

\notice{Once the segment manager is initialized, the segment array
  becomes useless so it can be released.}

%
% regions
%

\subsubsection{Regions}

A \textbf{region} is a contiguous area of used virtual memory.

A region maps a segment part, or the whole.

As for the segments, the bootloader needs a \textit{region array}.

The region array describes the initial state of the region manager, or
the initial kernel's virtual memory state.

The kernel's task manager will so go through this data structure
and properly rebuild the virtual memory from this data structure to
initialize the kernel's address space.

The region array contains region objects which are partially initialized
as the segments of the segment array.

\notice{Once the regions manager is initialized, the region array
  becomes useless so it can be released.}

%
% survival area
%

\subsubsection{Survival Area}

Like every program, kernels need memory to build and maintain internal
data structures. These data structures can be used to keep track of
the alive processes but also to keep track of the memory state.

For example, kernels typically have a kind of manager which keeps track
of the physical memory state. This manager internally uses a data
structure to know which memory areas are for example unused.

During operating systems history, different data structures were used for
this purpose from the most basic one; the bitmap which just tells whether
a physical memory page is used or not; to more complex one like the buddy
system or complex data structures like the b-tree.

Let's consider a relatively simple data structure which only keeps track
of used physical memory area in a linked-list. Each element of the
linked-list provides enough information to describe a used physical memory
area including the base address, the area size, the permissions etc..

Note that, in kaneton terms, this manager is called the segment manager.

Therefore, to maintain such a data structure this manager needs memory.
Nevertheless, it seems impossible since this manager is actually initializing
its internal data structure to provide this functionality.

You can notice that this manager needs memory while it is its role to provide
an interface to manage memory.

This mutual dependency generally leads to static and specific implementations.

Indeed, kernels usually use a very specific data structure to install
the physical memory manager. Then the other parts of the kernels can allocate
memory without taking care of anything.

But the price to pay is to, for example, implement a simple static array
which will be linked with another one when the elements to manage become
too important.

Then, the kernels' physical memory managers are typically ugly for this
precise reason.

We wanted kaneton to be elegant in every points. So we had to choose another
solution to this typical problem to permit kaneton to evolve in a very
coherent way where everything is dynamic and based on other kaneton
managers.

In kaneton, the data structures are managed by the set manager. This
manager uses the \textit{malloc}() function to allocate fine-grained memory.
This set manager is used by every kaneton manager to store data.

Now let's come back to our physical memory manager problem. Recall that, in
kaneton, the physical memory manager is the segment manager.

We wanted to build the segment manager over the set manager so the segment
manager can use dynamic data structures and not ad-hoc data structure
solutions.

The segment manager uses the set manager which is based on the
\textit{malloc}() function. Then the \textit{malloc}() function needs to
allocate physical memory areas to provide fine-grained allocation in them.
Once again, there is an evil mutual dependency between \textit{malloc}()
and the segment manager.

To break this mutual dependency we decided to give the \textit{malloc}()
function a pre-reserved area so it can use it to provide fine-grained
memory until the segment and region managers are initialized.

Once the segment and region managers will be initialized, the
\textit{malloc}() function will just have to reserve physical memory to
perform the same work than every typical malloc() function do.

Since, at the core boot time, the segment manager is not initialized yet,
the core itself cannot decide where to put this pre-reserved area.

Therefore, the kernel relies on the bootloader to find out a pre-reserved
area of physical memory for the \textit{malloc}() function. This area will
then be called the \textbf{survival area} or sometimes the
\textbf{survival segment}.

%
% initialization structure
%

\subsubsection{Initialization Structure}

As mentioned before, the bootloader has to build an initialization structure
and to pass it to the kernel so the kernel can locate the different
fundamental elements in main memory.

The initialization structure called \textit{t\_init} is defined in the
file \textit{kaneton/include/core/init.h}.

We will now detail the fundamental fields:

\begin{itemize}
  \item
    \textit{mem} and \textit{memsz} indicate the computer's available
    physical memory.
  \item
    \textit{kcode} and \textit{kcodesz} indicate the location and
    aligned size of the kernel binary object in main memory, after relocation.
  \item
    \textit{init} and \textit{initsz} fields indicate the location and
    aligned size of this initialization structure in main memory.
  \item
    \textit{modules} and \textit{modulessz} indicate the location and
    aligned size of the area used to store the modules.
  \item
    \textit{nsegments}, \textit{segments} and \textit{segmentssz}
    indicate the location and aligned size of the area containing the
    segment array. This array describes the core's pre-reserved segments.
  \item
    \textit{nregions}, \textit{regions} and \textit{regionssz} fields
    indicate the location and aligned size of the area containing the
    region array. This array describes the segments to be mapped after
    the initialization of the core region manager.
  \item
    \textit{kstack} and \textit{kstacksz} indicate the kernel stack
    area location and aligned size.
  \item
    \textit{alloc} and \textit{allocsz} fields indicate the location
    and aligned size of the fine-grain allocator survival area.

    This area will be used by the \textit{malloc}() function to provide
    fine-grain allocator while nor segment neither region manager are
    initialized yet.

    The bootloader may allocate about sixteen pages for the survival area.
\end{itemize}

The initialization structure could also contain machine-dependent fields.

Look at the file \textit{kaneton/include/arch/[architecture]/core/init.h}
for more information about the structure machine-dependent initialization
structure called \textit{a\_init}.

\end{comment} % XXX
