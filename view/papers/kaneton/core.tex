%%
%% licence       kaneton licence
%%
%% project       kaneton
%%
%% file          /home/mycure/kaneton/view/papers/kaneton/core.tex
%%
%% created       matthieu bucchianeri   [mon jan 30 17:33:29 2006]
%% updated       julien quintard   [tue apr  4 15:20:05 2006]
%%

%
% core
%

\chapter{Core}

In this chapter we will describe the kaneton core design and implementation.

We will first describe the bootloader before describing the core itself.
Note that many design choices make the bootloader understanding difficult
to students. We will try to explain the design choices to make things
clear.

Then we will describe the core's managers taking care of specifying the
interface it provides.

\newpage

%
% text
%

The kaneton microkernel is composed of managers. Each manager provides
an interface to manipulate a special kaneton object or something else.

%
% id manager
%

\section{id manager}

The \textbf{id manager} provides an interface to manipulate the
kaneton identifiers.

The \textbf{id object} \textit{o\_id} is used to generate unique
- in its own name space - identifiers \textit{t\_id}.

In the current kaneton implementation, identifiers only consist in 64-bit
integers. Therefore, the id manager does not take care of identifiers
recycling. Nevertheless, the id manager interface was designed to permit
identifiers recycling.

Note that the id manager is the very first manager to be initialized. Then
the whole core will use it to generate identifiers for the other kaneton
objects.

%
% interface
%

\subsubsection{Interface}

\function{id\_show}{(o\_id* \argument{o})}
	 {
	   This function just displays the state of the id object
	   \argument{o}.
	 }

\function{id\_clone}{(o\_id* \argument{o},
                      t\_id \argument{old},
                      t\_id* \argument{new})}
	 {
	   This function duplicates an id object using the \argument{o}
	   identifier object, name space.

	   Note that cloning an identifier means reserving a new one
	   with the same properties.
	 }

\function{id\_reserve}{(o\_id* \argument{o},
                        t\_id* \argument{i})}
	  {
	    This function reserves an identifier \argument{i} using the
	    identifier object \argument{o}.
	  }

\function{id\_release}{(o\_id* \argument{o},
                        t\_id \argument{i})}
	 {
	   This function releases the identifier \argument{i}.
	 }

\function{id\_build}{(o\_id* \argument{o})}
	 {
	   This function initializes an identifier object.
	 }

\function{id\_destroy}{(o\_id* \argument{o})}
	 {
	   This function destroys an identifier object.
	 }

\function{id\_init}{(void)}
	 {
	   This function just initializes the id manager.
	 }

\function{id\_clean}{(void)}
	 {
	   This function just cleans the id manager.
	 }

%
% set manager
%

\section{set manager}

The \textbf{set manager} is used to manage the data structures in order
to simplify the other kernel managers. Indeed, every kernel manager
including the task manager, the thread manager, the segment manager etc..
uses the set manager to store the data rather than create and manage data
structures by their own.

More precisly, the set manager is used to store kaneton objects.
As seen earlier, kaneton objects has a first 64-bit field representing
the kaneton object's identifier. Then, the set manager uses this identifier
to retrieve an object in a set.

Notice that to avoid problems, a set must contain objects with unique
identifiers.

The set manager manages set objects. A \textbf{set object} \textit{o\_set}
is a kaneton object so is identified by a unique set identifier
\textit{i\_set}.

The set mecanism is divided in two parts: the set manager and the set
implementations.

While the set implementations are specific to each type of set: array,
linked-list, pipe, etc.., the set manager code is generic and works with all
sets.

The set manager has its own nomenclature we will now detail.

The \textbf{set container} is the set which contains all the set descriptors.
Note that storing set objects in another set object is possible since
set objects are kaneton objects so have a first field kaneton identifier.

The term \textbf{set descriptor} is equivalent to the term \textit{set object}.
We use the term \textit{set object} to describe a set outside of the set
manager while the term \textit{set descriptor} is used inside the set
manager. A set descriptor contains the set meta-data. Indeed, a set descriptor
contains the set data structure holding the objects, the number of objects
managed, the set options, the size of the objects held, the identifier of
the set etc.. Each set descriptor is also composed of an implementation
subpart.

A \textbf{node} is a data structure element. Indeed, each iterator
references a node to be able to locate the previous and next nodes in
the set. Note that sometimes, the node is also the object.

An \textbf{set iterator} is a pointer on a node of a set. Iterators were
introduced to speed up the manipulation of sets. Nevertheless, be carefull
since no insurance can be made on the coherence of iterators if set
operations are made.

In other words, the set container is a set \textit{o\_set} which contains
the set descriptors. Each set descriptor \textit{o\_set} contains a data
structure composed of nodes which contain the kaneton objects provided by
the set manager user.

The Figure \ref{figure:core_sets} illustrates the complex sets organization.

\begin{figure}[h]
  \begin{center}
    \includegraphics[scale=0.5]{figures/core_sets.pdf}
    \caption{Sets organization.}
    \label{figure:core_sets}
  \end{center}
\end{figure}

Note that the set manager is based on the \textit{malloc}() suite functions.
Indeed the set manager maintains a data structure containing the set
descriptors: the \textit{container}. Moreover some data structure
implementation require the \textit{malloc}() suite functions, the simplest
example being the array data structure which requires the \textit{realloc}()
function to be able to expand the data structure without effort.

Due to this requirement, the set manager cannot manage the data structure
for the segments of the segment manager, the kernel address space segments
and the kernel address space regions of the address space manager because
the \textit{malloc}() function is not provided yet. To bypass this restriction
the kaneton microkernel uses an initial \textit{malloc}() version which
is based on a little amount of memory provided by the bootloader, via the
fields \textit{alloc} and \textit{allocsz} of the initialization structure.
This area is called the \textit{survival memory area} as seen in the
bootloader section.

Using this initial \textit{malloc}() function, the set manager is able to
build sets for every kernel managers: segment manager, address space manager,
region manager etc..

The set manager provides options to parameterize the set reservation.

The \textit{SET\_OPT\_CONTAINER} option is only used by the set manager
to build the very first set which then becomes the set container.

The \textit{SET\_OPT\_ALLOC} tells the set manager to always allocate
memory and to copy into this memory the content of the given object.
This option is very useful since the user never cares about allocating
memory. With this option, kaneton object stored in the set are automatically
freed when the set is released.

To tell the set manager to automatically free the objects stored without
setting the \textit{SET\_OPT\_ALLOC}, the \textit{SET\_OPT\_FREE} was
introduced. This option tells the set manager that the user will store
pre-reserved objects but the user wants them to be freed. This option
is mutually exclusive with the \textit{SET\_OPT\_ALLOC} option.

The \textit{SET\_OPT\_SORT} tells the set manager to always keep the set
sorted by identifiers.

The \textit{SET\_OPT\_ORGANISE} option is only used to re-organize the data
structure to keep it as simple as possible. This option may have no sens
with certain data structures.

%
% interface
%

\subsubsection{Interface}

\function{set\_type}{(i\_set \argument{id})}
	 {
	   This function just returns an error if the set corresponding
	   to \argument{id} is not of the type of the set implementation.
	 }

\function{set\_show}{(i\_set \argument{id})}
	 {
	   This function displays the entire set state of the set object
	   \argument{id}.
	 }

\function{set\_dump}{(void)}
	 {
	   This function displays all the set objects of the set manager.
	 }

\function{set\_size}{(i\_set \argument{id},
                      t\_setsz \argument{size})}
	 {
	   This function returns in \argument{size} the number of elements
	   of the set.
	 }

\function{set\_head}{(i\_set \argument{id},
                      t\_iterator* \argument{iterator})}
	 {
	   This function returns an iterator on the first element
	   of the set \argument{id}.
	 }

\function{set\_tail}{(i\_set \argument{id},
                      t\_iterator* \argument{iterator})}
	 {
	   This function returns an iterator on the last element of
	   the set \argument{id}.
	 }

\function{set\_previous}{(i\_set \argument{id},
                          t\_iterator \argument{current},
                          t\_iterator* \argument{previous})}
	 {
	   This function returns an iterator on the previous element
	   of the set.
	 }

\function{set\_next}{(i\_set \argument{id},
                      t\_iterator \argument{current},
                      t\_iterator* \argument{previous})}
	 {
	   This function returns an iterator on the next element
	   of the set.
	 }

\function{set\_insert}{(i\_set \argument{id},
                        void* \argument{data})}
	 {
	   This function inserts an object at the head of the set
	   \argument{id}.
	 }

\function{set\_append}{(i\_set \argument{id},
                        void* \argument{data})}
	 {
	   This function inserts an object at the tail of the set
	   \argument{id}.
	 }

\function{set\_before}{(i\_set \argument{id},
                        t\_iterator \argument{iterator},
                        void* \argument{data})}
	 {
	   This function inserts an object before the one specified
	   by the iterator.
	 }

\function{set\_after}{(i\_set \argument{id},
                       t\_iterator \argument{iterator},
                       void* \argument{data})}
	 {
	   This function inserts an object after the one specified
	   by the iterator.
	 }

\function{set\_add}{(i\_set \argument{id},
                     void* \argument{data})}
	 {
	   This function adds a data object in the set \argument{id}.
	 }

\function{set\_remove}{(i\_set \argument{id},
                        t\_id \argument{i})}
	 {
	   This function removes an object identified by \argument{i}
	   from the set \argument{id}.
	 }

\function{set\_delete}{(i\_set \argument{id},
                        t\_iterator \argument{iterator})}
	 {
	   This function deletes the object corresponding to the iterator.
	 }

\function{set\_flush}{(i\_set \argument{id})}
	 {
	   This function removes every object stored in the set
	   \argument{id}.
	 }

\function{set\_locate}{(i\_set \argument{id},
                        t\_id \argument{i},
                        t\_iterator* \argument{iterator})}
	 {
	   This function returns an iterator on the element corresponding
	   to the identifier \argument{i} of the set \argument{id}.
	 }

\function{set\_object}{(i\_set \argument{id},
                        t\_iterator \argument{iterator},
                        void** \argument{data})}
	 {
	   This function returns the data object corresponding to
	   the iterator.
	 }

\function{set\_push}{(i\_set \argument{id},
                      void* \argument{data})}
	 {
	   This function adds an object to a FIFO or LIFO structure.
	 }

\function{set\_pop}{(i\_set \argument{id})}
	 {
	   This function removes the next object of a FIFO or LIFO structure.
	 }

\function{set\_pick}{(i\_set \argument{id},
                      void** \argument{data})}
	 {
	   This function returns the next object of a FIFO or LIFO structure
	   without deleting it.
	 }

\function{set\_reserve}{(\argument{type},
                         t\_opts \argument{opts},
                         t\_size \argument{datasz},
                         i\_set* \argument{id})}
	 {
	   This function reserves a set object of type \argument{type}
	   with options \argument{opts} which will contain object of
	   \argument{datasz} size.

	   The reserved set object's identifier is returned in
	   \argument{id}.
	 }

\function{set\_release}{(i\_set \argument{id})}
	 {
	   This function releases the set \argument{id}.
	 }

\function{set\_init}{(void)}
	 {
	   This function initializes the set manager.
	 }

\function{set\_clean}{(void)}
	 {
	   This function cleans the set manager.
	 }

You can notice that some operations does not make sense on some data
structures. For example, \textit{set\_push}() or \textit{set\_pop}()
will never be used on arrays or lists, but only on stacks or pipes.

In these cases, the function must be implemented but will only return
an error.

Most widely, some operations have no sense with some options. Inserting
at the beginning of a sorted array must produce an error since it can
cancel the sorting property.

It is important to understand that a set implementation can specify
its own interface. Therefore, for example, the \textit{set\_reserve}()
function could have fifteen arguments for the stack implementation.

To better understand the implementations, take a look at the set
manager directory \textit{kaneton/core/set/}.

%
% stats manager
%

\section{stats manager}

XXX ne se base pas sur les sets

%
% as manager
%

\section{as mananger}

The \textbf{address space manager} or \textbf{as manager} just manages
the address spaces objects.

An \textbf{address space object} or \textbf{as object} \textit{o\_as}
is an abstraction describing the addressable memory. The as objects
are identified by an address space identifier \textit{i\_as}.

An address space object is composed of a set of segments and a set of regions.

The set of segments describes the physical memory that belongs to this
address space while the set of regions describes the virtual memory
used to access the physical one.

It is important to understand that the set of segments holds segment
identifiers while the set of regions holds region objects.

%
% interface
%

\subsubsection{Interface}

\function{as\_show}{(i\_as \argument{id})}
	 {
	   This function shows a precise address space displaying
	   information on it.
	 }

\function{as\_dump}{(void)}
	 {
	   This function shows all the address space objects managed by
	   the address space manager.
	 }

\function{as\_give}{(i\_task \argument{task},
                     i\_as \argument{id})}
	 {
	   This function gives the address space \argument{id} to the
	   task object \argument{task}.
	 }

\function{as\_vaddr}{(i\_as \argument{id},
                      t\_paddr \argument{physical},
                      t\_vaddr \argument{virtual})}
	 {
	   This function translates a physical address into its virtual
	   address.
	 }

\function{as\_paddr}{(i\_as \argument{id},
                      t\_vaddr \argument{virtual},
                      t\_paddr \argument{physical})}
	 {
	   This function translates a virtual address into its physical
	   address.
	 }

\function{as\_clone}{(i\_task \argument{task},
                      i\_as \argument{old},
                      i\_as* \argument{new})}
	 {
	   This function clones an address space taking care of cloning
	   everything necessary: segments, regions etc..
	 }

\function{as\_reserve}{(i\_task \argument{task},
                        i\_as* \argument{id})}
	 {
	   This function reserves an address space object for the
	   task \argument{task} object.

	   The reserved address space object's identifier is returned
	   in \argument{id}.
	 }

\function{as\_release}{(i\_as \argument{id})}
	 {
	   This function just releases the address space \argument{id}.
	 }

\function{as\_get}{(i\_as \argument{id},
                    o\_as** \argument{o})}
	 {
	   This function should only be used by the as manager, the segment
	   manager and the region manager.

	   This function just returns the address space object
	   corresponding to the address space identifier \argument{id}.
	 }

\function{as\_init}{(void)}
	 {
	   This function initializes the address space manager.
	 }

\function{as\_clean}{(void)}
	 {
	   This function cleans the address space manager.
	 }

%
% segment manager
%

\section{segment manager}

The \textbf{segment manager} manages physical memory.

Its goals is to reserve and release physical memory areas, merge or split
allocated areas and finally to read or write directly into physical memory.

The kaneton object manages by the segment manager is the segment object.

A \textbf{segment object} \textit{o\_segment} describes an area of reserved
physical memory. A segment object has some properties like the base
address, the size, the permissions etc.. and is identified by a
segment identifier \textit{i\_segment}.

In the current kaneton microkernel reference implementation, the
segment object's identifier is set from the segment object's base
address. Therefore, it is so easy to retrieve segment object from
the base address. Moreover, physical address are of course unique
so the segment objects can be stored in a set object without effort.

\function{segment\_show}{(i\_segment \argument{id})}
	 {
	   This function displays information on the specified segment
	   \argument{id}.
	 }

\function{segment\_dump}{(void)}
	 {
	   This function displays all segments of the set of segments.
	 }

\function{segment\_clone}{(i\_as \argument{as},
                           i\_segment \argument{old},
                           i\_segment* \argument{new})}
	 {
	   This function clones a segment which will then belong to
	   the address space object \argument{as}.

	   Cloning a segment means reserving a new segment with the
	   exact same properties. Then the content is also copied.
	 }

\function{segment\_inject}{(i\_as \argument{as},
                            o\_segment* \argument{o})}
	 {
	   This function injects a pre-allocated segment in the set of
	   segments.
	 }

\function{segment\_give}{(i\_as \argument{as},
                          i\_segment \argument{id})}
	 {
	   This function gives a segment from one address space to another.
	 }

\function{segment\_resize}{(i\_segment \argument{old},
                            t\_psize \argument{size},
                            i\_segment* \argument{new})}
	 {
	   This function resizes the segment \argument{old} to the
	   size \argument{size}.

	   The new segment, which can be the same, is returned in
	   \argument{new}.
	 }

\function{segment\_split}{(i\_segment \argument{id},
                           t\_psize \argument{size},
                           i\_segment* \argument{left},
                           i\_segment* \argument{rigth})}
	 {
	   This function splits the segment \argument{id} into two segments.

	   The size \argument{size} specifies the size of the new left segment.
	 }

\function{segment\_coalesce}{(i\_segment \argument{left},
                              i\_segment \argument{right},
                              i\_segment* \argument{id})}
	 {
	   This function merges two adjacent segments into a single
	   one \argument{id}.
	 }

\function{segment\_read}{(i\_segment \argument{id},
                          t\_paddr \argument{offset},
                          void* \argument{buffer},
                          t\_psize \argument{size})}
	 {
	   This function reads \argument{size} bytes at offset
	   \argument{offset} from the segment \argument{id}.
	 }

\function{segment\_write}{(i\_segment \argument{id},
                           t\_paddr \argument{offset},
                           const void* \argument{buffer},
                           t\_psize \argument{size})}
	 {
	   This function write the data of \argument{buffer} into the
	   segment \argument{id}.
	 }

\function{segment\_copy}{(i\_segment \argument{dst},
                          t\_paddr \argument{offd},
                          i\_segment \argument{src},
                          t\_paddr \argument{offs},
                          t\_psize \argument{size})}
	 {
	   This function copies data from the segment \argument{src} to
	   the segment \argument{dst}.
	 }

\function{segment\_reserve}{(i\_as \argument{as},
                             t\_psize \argument{size},
                             t\_perms \argument{perms},
                             i\_segment* \argument{id})}
	 {
	   This function reserves a segment with specified properties.
	 }

\function{segment\_release}{(i\_segment \argument{id})}
	 {
	   This function releases the segment \argument{id}.
	 }

\function{segment\_catch}{(i\_as \argument{as},
                           i\_segment \argument{id})}
	 {
	   This function is used to force a segment to be given to an address
	   space.

	   \textbf{Catchable} segments are reserved by the module service
	   for architecture specific servers. Catchable segments
	   are defined in the \argument{kaneton.conf} file.
	 }

\function{segment\_perms}{(i\_segment \argument{id},
                           t\_perms \argument{perms})}
	 {
	   This function changes the permissions of the segment \argument{id}.
	 }

\function{segment\_type}{(i\_segment \argument{id},
                          t\_type \argument{type})}
	 {
	   This function changes the type of a segment.
	 }

\function{segment\_flush}{(i\_as \argument{as})}
	 {
	   This function removes every segment that belongs to the
	   address space \argument{as}.
	 }

\function{segment\_init}{(void)}
	 {
	   This function initializes the segment manager.
	 }

\function{segment\_clean}{(void)}
	 {
	   This function cleans the segment manager.
	 }

%
% region manager
%

\section{region manager}

The \textbf{region manager} manages mappings of segment called regions.

A \textbf{region object} \textit{o\_region} describes an area of virtual
memory mapping a segment part. Each region is identified by a unique region
identifier \textit{i\_region}.

As for segments, regions identifiers are set from the region base address.

\function{region\_show}{(i\_as \argument{as},
                         i\_region \argument{id})}
	 {
	   This function displays information on the specified region
	   \argument{id} of the address space object \argument{as}.
	 }

\function{region\_dump}{(i\_as \argument{as})}
	 {
	   This function displays all the regions of the address space
	   \argument{as}.
	 }

\function{region\_inject}{(i\_as \argument{as},
                           o\_region* \argument{o})}
	 {
	   This function injects a pre-allocated region in the set of
	   regions of the address space \argument{as}.
	 }

\function{region\_resize}{(i\_as \argument{as},
                           i\_region \argument{old},
                           t\_vsize \argument{size},
                           i\_region* \argument{new})}
	 {
	   This function resizes the region \argument{old} to the
	   size \argument{size}.

	   The new region, which can be the same, is returned in
	   \argument{new}.
	 }

\function{region\_reserve}{(i\_as \argument{as},
                            i\_segment \argument{segment},
                            t\_paddr \argument{offset},
                            \align{2.5cm}
                            t\_opts \argument{opts},
                            t\_vaddr \argument{address},
                            t\_vsize \argument{size},
                            i\_region* \argument{id})}
	 {
	   This function reserves a region with specified properties.
	 }

\function{region\_release}{(i\_as \argument{as},
                            i\_region \argument{id})}
	 {
	   This function releases the region \argument{id} that belongs
	   to the address space object \argument{as}.
	 }

\function{region\_flush}{(i\_as \argument{as})}
	 {
	   This function removes every region that belongs to the
	   address space \argument{as}.
	 }

\function{region\_init}{(void)}
	 {
	   This function initializes the region manager.
	 }

\function{region\_clean}{(void)}
	 {
	   This function cleans the region manager.
	 }

%
% map manager
%

\section{map manager}

XXX

%
% event manager
%

\section{event manager}

XXX

%
% timer manager
%

\section{timer manager}

%
% task manager
%

\section{task manager}

XXX

behaviour, priority, classe

%
% thread manager
%

\section{thread manager}

XXX

%
% scheduler
%

\section{scheduler}

XXX
