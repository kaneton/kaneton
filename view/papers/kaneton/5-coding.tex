%%
%% licence       kaneton licence
%%
%% project       kaneton
%%
%% file          /home/mycure/kaneton/view/papers/kaneton/5-coding.tex
%%
%% created       matthieu bucchianeri   [mon jan 30 17:32:57 2006]
%% updated       julien quintard   [wed feb  8 01:19:48 2006]
%%

%
% coding style
%

\chapter{Coding style}

\newpage

\paragraph{}
The \kaneton  project developers  try to follow  a coding  style. This
coding style was introduced to normalize the source code, leading to a
more readable source code.

\paragraph{}
Nevertheless, you  can adapt this coding  style to your own  but try to
follow the rules.

\section*{Headers}

\paragraph{}
Each file must start with an header formatted as shown below:

\begin{verbatim}
/*
 * licence       kaneton licence
 *
 * project       kaneton
 *
 * file          /home/buckman/kaneton/core/kaneton/as/as.c
 *
 * created       julien quintard   [fri feb 11 02:23:41 2005]
 * updated       matthieu bucchianeri   [mon jan 30 20:30:57 2006]
 */
\end{verbatim}

\paragraph{}
An emacs  file for generating  and updating this  header automatically
can be found in \textit{tools/emacs/header.el}. Additionally, you need
to set two environment variables:

\begin{itemize}
\item \textbf{EC\_LICENCE} must be set to ``kaneton licence''
\item \textbf{EC\_DEVELOPER} must be set to your first name and last name
\end{itemize}

\paragraph{}
Please, do not use nicknames in headers.

\section*{Naming convenions}

\paragraph{}
To keep the code as clear as possible, there are several convetions on
type, functions and variables naming.

\subsection*{Variable name}

\paragraph{}
Variable  names   must  be  expressed  in  english   with  lower  case
letters. Here are a few rules you are encouraged to follow:

\begin{itemize}
\item \textbf{sz} suffix for variables representing a size
\item \textbf{n} prefix for variables representing a number of objects
\item \textbf{id} suffix for identifiers
\item \ldots
\end{itemize}

\paragraph{}
Remember that the type name is also used to define a variable. No need
to repeat it in the variable name.

\subsection*{Function name}

\paragraph{}
Function names  must be expressed  in english with lower  case letters
and must  be prefixed by  the file name  they are implemented  in. For
example, a function part of the address space manager must be prefixed
by \textbf{as\_}.

\paragraph{}
These  names must be  chosen carefully:  they must  explicitely define
what the function does.

\subsection*{Type name}

\paragraph{}
As variables  and functions, type  names must be expressed  in english
with lower case letters.

\paragraph{}
Here are the prefixes you must use when writing your own types:

\begin{itemize}
\item \textbf{m\_} for managers main structures
\item \textbf{o\_} for  objects (an object is a  structure which first
64-bits are an identifier)
\item \textbf{i\_} for interfaces (an interface is a set of function pointers)
\item \textbf{d\_} for architecture-dependent structures
\item \textbf{s\_} for general purpose structures
\item \textbf{t\_} for basic and general purpose typedefs
\end{itemize}

\paragraph{}
Notice  that \textbf{d\_}  can be  combined with  other  prefixes, for
example \textbf{do\_} for a dependent object.

\section*{Includes}

\paragraph{}
To keep the  code clear and compact, developer only  need to include a
minimal number of header files:

\begin{itemize}
\item \textit{kaneton.h} for the operating system declarations
\item \textit{klibc.h} for the kaneton specific C library
\end{itemize}

\paragraph{}
These files  are in the include  path, so do not  use relative include
path.

\section*{Types}

\paragraph{}
You  may use  as  soon as  possible  standard types:  \textbf{t\_uint8},
\textbf{t\_sint32}, \ldots{}

\section*{Return values}

\paragraph{}
Every function must report whether it successed or failed. So function
return type should be \textbf{t\_error}.

\paragraph{}
A function  will return  \textbf{ERROR\_NONE} on success  and anything
else on error (for example: \textbf{ERROR\_UNKNOWN}).

\section*{Indentation}

\paragraph{}
There are several indentation rules in \kaneton.

\begin{enumerate}

\item  Field names  of structs  and unions  must be  aligned  with the
struct or union name

\begin{verbatim}
struct       s_set
{
  t_setid    setid;
  t_setsz    size;
  t_type     type;
};
\end{verbatim}

or

\begin{verbatim}
typedef struct
{
  o_id       id;
  t_staid    stats;
  t_setid    container;
}            m_as;
\end{verbatim}

\item Defines and variable must be aligned as shown below:

\begin{verbatim}
#define TASK_PRIOR_CORE     230
#define TASK_HPRIOR_CORE    250
#define TASK_LPRIOR_CORE    210

m_task*                     task;
t_tskid                     ktask = ID_UNUSED;
\end{verbatim}

This rule also applies for variables declarations in functions.

\item Function prototype and body should look like this:

\begin{verbatim}
t_error             stats_function(t_staid          staid,
                                   char*            function,
                                   t_stats_func**   f)
{
  t_sint64          slot = -1;
  t_sint64          i;

  ...
}
\end{verbatim}

Notice  that  parameters name  are  aligned  between  each other,  and
variable names are aligned with function name and between each other.

Try  to respect  this alignment  between functions  in a  single file:
function names may be all aligned and parameter names also.

\end{enumerate}

\section*{Comments}

\paragraph{}
As \kaneton  is intended  to be a  pedagogical project with  clear and
understandable source code.  No need to say that  comments take a very
important part of this objective.

\paragraph{}
Every file must  begin with a comment describing what  is done in this
code. And  every function must be  preceded by a  comment defining its
behavior.

\paragraph{}
To prevent direct comments in the code, we used ``steps'':

\begin{itemize}

\item Each critical  code section on a function is  preceded by a step
number

\item The function header comment contains steps descriptions.

\end{itemize}

There is an example below:

\begin{verbatim}
/*
 * this function shows the usage of comments and steps.
 *
 * steps:
 *
 * 1) compute the index.
 * 2) make the operation.
 * 3) check the result.
 */
t_error         test_foobar(int      a,
                            int      b,
                            int*     c)
{
  int           idx;

  /*
   * 1)
   */

  idx = text_make_index(a, b);

  /*
   * 2)
   */

  idx = idx * a + b;

  /*
   * 3)
   */

  if (idx < 0)
    return ERROR_UNKNOWN;

  *c = idx;

  return ERROR_NONE;
}
\end{verbatim}

\section*{File structure}


% end of include file
