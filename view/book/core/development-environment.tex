%%
%% licence       kaneton licence
%%
%% project       kaneton
%%
%% file          /home/mycure/kaneton/view/books/kaneton/development-environment.tex
%%
%% created       matthieu bucchianeri   [mon jan 30 17:31:26 2006]
%% updated       julien quintard   [sun jul 30 23:01:51 2006]
%%

%
% development environment
%

\chapter{Development Environment}

In this chapter we will study the kaneton development environment
to understand how it works and how to extend it with new users and
machines profiles.

\newpage

%
% text
%

Over the years, the kaneton microkernel evolved, starting with a
very simple introduction to low-level programming and finally
to a complete microkernel development.

Going always further implies many modifications. Indeed, the students
cannot take time to develop their own development environment because
developing a development environment is a whole project by itself.

We wanted to lead students to a complete microkernel development and then
to introduce the parallel and distributed programming. This would not
be possible if they had to develop an entire development environment.

So kaneton people decided to give the students a complete development
environment.

The kaneton development environment is composed of makefiles, shell
scripts and configuration files and together provide multi-users cooperation,
with many operating systems on many architectures.

A development environment describes binaries, compiling options, linking
options etc. to use for the kaneton microkernel project.

The whole kaneton development environment needs exactly two
fundamental tools to work. The first one is GNU make, used to build
powerful makefiles, and the second one is GNU bash, used to write
shell scripts.

If an operating system has these two tools, then kaneton can be developed
on it.

%
% profiles
%

\section{Profiles}

The kaneton development environment permit different users, with different
development parameters and configuration files, running different operating
systems on different architectures, to develop together on the same
microkernel project.

To offer these functionalities, the kaneton development environment is
composed of profiles, machine profiles which describe operating systems
behaviours and user profiles which describe users configurations.

From these profiles, the kaneton development environment will generate
development environment files containing the whole kaneton environment
stuff including variables, shell functions, make functions etc.

The three kaneton development environment files are located in the
\textit{environment/} directory.

The first one contains static kaneton development environment information
and is called \textit{.env.conf}. This file contains absolute paths
to different kaneton directories and kaneton general information.

The two others called \textit{env.mk} and \textit{.env.sh} will be generated
by the kaneton development environment system. These files contain
everything necessary to kaneton makefiles and kaneton shell scripts
including variables and functions.

The kaneton development environment system uses shell environment variables
the user has to set before using the system:

\begin{itemize}
  \item
    \textit{\$KANETON\_USER} holds the user profile name.

    This shell environment variable will be used by the kaneton development
    environment system to retrieve the user profile.
  \item
    \textit{\$KANETON\_MACHINE} holds the machine profile name.

    This value will be used to retrieve the machine profile.
  \item
    \textit{\$KANETON\_SHELL} holds the GNU bash binary path.

    This path will be used to launch the very first shell script used to
    generate the current development environment.
\end{itemize}

%
% machines
%

\subsection{Machines}

kaneton people wanted a powerful system to provide users an easy way
to use kaneton on any operating system and any microprocessor architecture.

Indeed, many students and developers use Apple's MacOS running on PowerPC
microprocessors while other use Solaris running on UltraSparc microprocessors
and finally the others generally use Linux or BSD operating systems on
Intel microprocessors.

kaneton people wanted all the developers to contribute to the same
kaneton implementation without difficulties.

To make it possible, the kaneton microkernel had to compile on
every operating systems. To do so, machine profiles were introduced to
describe operating systems behaviour.

A machine profile is precisly a set composed of an operating system,
a target machine and a target microprocessor architecture.

The naming scheme used for machine profiles is the operating system name,
two colons, the target machine, a dot and finally the microprocessor
architecture for which kaneton is built.

For example, a correct machine profile name would be
\textit{macos::ibm-pc.ia32-virtual} describing the machine profile composed
of the MacOS development operating system generating a kaneton binary for
an IBM PC machine running on an Intel Architecture 32-bit with virtual memory.

Another correct machine profile name would be \textit{freebsd::sgi-o2.mips64}
describing the behaviour of the FreeBSD development operating system and
generating kaneton binary object files for the SGI O2 machine running on
a MIPS 64-bit microprocessor's architecture.

The machine profiles are located in the \textit{environment/machines/} directory.
A subdirectory is used for every machine profiles.

Notice that the kaneton development environment will use the shell
environement variable \textit{\$KANETON\_MACHINE} to locate the
machine profile to use.

Then the current machine profile's files are always located in the
\textit{environment/machines/\$KANETON\_MACHINE/} directory.

A machine profile describes the operating system behaviour for very
generic operations like compiling a file, assembling a file, building
a link between two files, removing a file, changing the current directory,
displaying a message etc.

As seen earlier, the kaneton development environment describes two
behaviours, one for the makefiles, and another for the shell scripts.

The files located in each machine profile are listed below. Note that
machine profiles may add any necessary file in their directory.

\begin{verbatim}
clean.sh
critical.sh
init.sh
machine.conf
machine.mk
machine.sh
\end{verbatim}

The files \textit{critical.sh}, \textit{init.sh} and \textit{clean.sh} are
used to install and uninstall the development environment for this
machine profile.

More precisly, the \textit{critical.sh} shell script must generate
the development environment fundamental files \textit{env.mk} and
\textit{.env.sh} located in the \textit{environment/} directory.

Then, the \textit{init.sh} is called to install machine specific stuff
like links to machine dependent directories. This shell script should also
check for the presence of binaries used by the machine profile.

Finally, the \textit{clean.sh} is called to uninstall the machine
specific stuff.

The \textit{machine.conf} file describes the machine profile configuration
including general variables, general flags etc. for the machine profile.

The file \textit{machine.mk} describes the machine behaviour for
make operations. This file must implement the whole kaneton make interface.

The file \textit{machine.sh} describes the machine behaviour for
shell operations. This file must implement the whole kaneton shell
interface.

Note that it might exist partial behaviours so that the user willing use
this machine profile must implement the other part.

Then, with all these files, an operating system can be described to
perform very basic make and shell operations generating binary object
files for the target microprocessor architecture.

%
% users
%

\subsection{Users}

Each kaneton developer has his own profile located in the kaneton
hierarchy \textit{environment/users/\$KANETON\_USER/}.

Note that this shell environment variable must be composed of a
first name, a dot and a last name; using nickname is not allowed.

For example, a correct user name would be \textit{julien.quintard} and
a bad one would be \textit{ChIcHe}.

The user profile directory contains configuration files used to parameter
the developement environment and the kaneton microkernel. Since every
users has his own profile, the current developer will use his own user
profile configuration and will not interfer with other developers.

The files located in each user profile directory are listed below.

\begin{verbatim}
  conf.c
  conf.h
  kaneton.conf
  modules.conf
  user.conf
  user.mk
  user.sh
\end{verbatim}

The file \textit{conf.c} is not used in the current development environment
implementation.

The file \textit{conf.h} parameterizes the kaneton microkernel specifying
for example the algorithm to use in the segment and region managers,
but is also used to activate for example the debug modes etc.

The file \textit{kaneton.conf} is the runtime kaneton microkernel
configuration file. This file describes the kaneton servers to launch
at the operating system startup. Moreover this file is used to parameter
the kaneton microkernel and servers in a dynamic way.

The file \textit{modules.conf} contains the module files to pass to
kaneton. Note that the first module in this file will be considered as
the kaneton bootloader and the second one as the kaneton core.

The file \textit{user.conf} is the most important since it is used
to configure the whole kaneton development environment. This file uses
the GNU make syntax. Via this file, the developer can parameter the compiling
flags, the boot device modes, the display options, the microkernel
files to use etc.

The \textit{user.mk} makefile is used to redefine or complete the machine
makefile behaviour.

Indeed, a developer could want not to use the general machine behaviour but
instead, prefer redefine parts of it. Then the user can override parts of
the machine profile's makefile behaviour using this file to redefine makefile
functions.

The \textit{user.sh} shell file is used, as the \textit{user.mk}, to
redefine shell functions.

With all these files a kaneton developer can parameterize the whole
kaneton project.

%
% interfaces
%

\section{Interfaces}

%
% make
%

\subsection{Make}

In this section we will detail the make interface that every machine
profile must implement.

The reader should look closer to the machine profiles already implemented.

The current machine reference profile is the \textit{linux} one.

\function{print}{(\argument{color},
                  \argument{text},
                  \argument{options})}
         {
	   This function display the \argument{text} in the specified
	   \argument{color}.

	   The option \textit{--no-newline} can be used not to output
	   the trailing newline.
	 }

\function{change-directory}{(\argument{directory},
                             \argument{options})}
         {
	   This function changes the current working directory.
	 }

\function{launch-shell}{(\argument{shell script},
                         \argument{arguments},
                         \argument{options})}
         {
	   This function launches a new shell script with its arguments.
	 }

\function{launch-python}{(\argument{python script},
                          \argument{arguments},
                          \argument{options})}
         {
	   This function launches a new python script with its arguments.
	 }

\function{launch-perl}{(\argument{shell script},
                        \argument{arguments},
                        \argument{options})}
         {
	   This function launches a new perl script with its arguments.
	 }

\function{launch-make}{(\argument{make file},
                        \argument{directory list},
                        \argument{arguments},
                        \argument{options})}
         {
	   This function launches the make command in each directory of
	   the list.
	 }

\function{launch}{(\argument{file},
                   \argument{...})}
         {
	   This function is a wrapper over the functions to launch new
	   shell, python, perl and make scripts.
	 }

\function{preprocess}{(\argument{preprocessed file},
                       \argument{c file},
                       \argument{options})}
         {
	   This function launches the C preprocessor.
	 }

\function{compile-c}{(\argument{object file},
                      \argument{c file},
                      \argument{options})}
         {
	   This function compile a C file generating an object file.
	 }

\function{lex-l}{(\argument{c file},
                  \argument{lex file},
                  \argument{options})}
         {
	   This function generates a C source file from a lex file.
	 }

\function{assemble-S}{(\argument{object file},
                       \argument{S file},
                       \argument{options})}
         {
	   This function assemble a S file.
	 }

\function{static-library}{(\argument{static library file name},
                           \argument{object files},
                           \argument{options})}
         {
	   This function builds a static library from object files.
	 }

\function{dynamic-library}{(\argument{dynamic library file name},
                            \argument{object files and/or libraries},
                            \argument{options})}
         {
	   This function builds a dynamic library from object files and/or
	   libraries.
	 }

\function{executable}{(\argument{executable file name},
                       \argument{object files and/or libraries},
                       \argument{options})}
         {
	   This function builds a executable from object files and/or
	   libraries.

	   The option \textit{--link-script [file]} specifies the
	   linker script file to use when building the executable object.

	   The option \textit{--no-standard-include} tells the function
	   not to use the operating system standard includes.

	   The option \textit{--no-standard-library} tells the function
	   not to use the operating system standard library.
	 }

\function{archive}{(\argument{archive file name},
                    \argument{object files},
                    \argument{options})}
         {
	   This function builds an archive of object files from multiple
	   object files.
	 }

\function{remove}{(\argument{files},
                   \argument{options})}
         {
	   This function removes the files in the list.
	 }

\function{purge}{()}
         {
	   This function just cleans the current working directory from
	   unecessary files.
	 }

\function{prototypes}{(\argument{files},
                       \argument{options})}
         {
	   This function will generate the prototypes in relation with
	   the files in the list.
	 }

\function{dependencies}{(\argument{files},
                         \argument{output},
                         \argument{options})}
         {
	   This function will generate the dependencies for the
	   \argument{files} and build a makefile dependency
	   \argument{output}.
	 }

\function{version}{(\argument{file})}
         {
	   This function generates a version file from the operating
	   system's informations: user, host, date etc.
	 }

\function{link}{(\argument{link},
                 \argument{file},
                 \argument{options})}
         {
	   This function creates a link \argument{link} for the file
	   \argument{file}.
	 }

\function{compile-tex}{(\argument{file},
                        \argument{options})}
         {
	   This function compiles the file \argument{file}.tex and
	   will generate a readable document.
	 }

\function{paper}{(\argument{file},
                  \argument{options})}
         {
	   This function builds a paper by calling the
	   \textbf{compile-tex()} function.
	 }

\function{lecture}{(\argument{file},
                    \argument{options})}
         {
	   This function builds a lecture document by calling the
	   \textbf{compile-tex()} function.
	 }

\function{subject}{(\argument{file},
                    \argument{options})}
         {
	   This function builds a subject by calling the
	   \textbf{compile-tex()} function.
	 }

\function{correction}{(\argument{file},
                       \argument{options})}
         {
	   This function builds a correction document by calling the
	   \textbf{compile-tex()} function.
	 }

\function{view}{(\argument{file},
                 \argument{options})}
         {
	   This function launches a viewer for the readable document
	   generated by the function \textbf{compile-tex()}.
	 }

\function{contents}{(\argument{file},
                     \argument{options})}
         {
	   This function returns the contents of the file \argument{file}.
	 }

%
% shell
%

\subsection{Shell}

In this section we will detail the shell interface that every machine
profile must implement.

The reader should look closer to the machine profiles already implemented.

\function{print}{(\argument{color},
                  \argument{text},
                  \argument{options})}
         {
	   This function outputs some text to the screen using a specific
	   color \textit{red}, \textit{green}, \textit{blue} etc.

	   The option \textit{--no-newline} can be used not to output
	   the trailing newline.

	   The option \textit{--flickering} tells the function to make
	   the text flicker.
	 }

\function{contents}{(\argument{file},
                     \argument{options})}
         {
	   This function returns the contents of the file \argument{file}.
	 }

\function{temporary}{(\argument{options})}
         {
	   This function creates a temporary file system object.

	   The option \textit{--file} tells the function to create a
	   temporary file.

	   The option \textit{--directory} tells the function to create
	   a temporary directory.
	 }

\function{working-directory}{(\argument{options})}
         {
	   This function returns the path of the current working directory.
	 }

\function{locate}{(\argument{name},
                   \argument{options})}
         {
	   This function tries to locate the program \argument{name}
	   on the system.
	 }

\function{substitute}{(\argument{pattern},
                       \argument{string},
                       \argument{options})}
         {
	   This function substitutes any string of the standard input
	   matching the pattern \argument{pattern} by the string
	   \argument{string}.

	   The option \textit{--everywhere} tells the function to
	   maximize the substitutions on the same line.
	 }

\function{display}{(\argument{message},
                    \argument{header})}
         {
	   This function displays the text \argument{message} in a
	   very specific manner based on the argument \argument{header}:
	   \textit{+}, \textit{!}, \textit{?} etc.
	 }

\function{wait-key}{(\argument{options})}
         {
	   This function just waits for the user to press a key.
	 }

\function{launch-shell}{(\argument{file},
                         \argument{arguments},
                         \argument{options})}
         {
	   This function launches a new shell script \argument{file} with
	   the arguments \argument{arguments}.
	 }

\function{launch-python}{(\argument{file},
                          \argument{arguments},
                          \argument{options})}
         {
	   This function launches the python file \argument{file} with
	   the arguments \argument{arguments}.
	 }

\function{launch-perl}{(\argument{file},
                        \argument{arguments},
                        \argument{options})}
         {
	   This function launches the perl file \argument{file} with
	   the arguments \argument{arguments}.
	 }

\function{launch-make}{(\argument{file},
                        \argument{directories},
                        \argument{arguments},
                        \argument{options})}
         {
	   This function launches the make file \argument{file} in each
	   directory of \argument{directories} with the arguments
	   \argument{arguments}.
	 }

\function{launch-program}{(\argument{file},
                           \argument{arguments},
                           \argument{options})}
         {
	   This function launches the program file \argument{file} with
	   the arguments \argument{arguments}.
	 }

\function{launch}{(\argument{file},
                   \argument{...})}
         {
	   This function is a wrapper over the previously described
	   launch functions.
	 }

\function{copy}{(\argument{source},
                 \argument{destination},
                 \argument{options})}
         {
	   This function copies the file \argument{source} to
	   \argument{destination}.
	 }

\function{link}{(\argument{source},
                 \argument{destination},
                 \argument{options})}
         {
	   This function builds a link between the file \argument{source}
	   and the file \argument{destination}.
	 }

\function{remove}{(\argument{file},
                   \argument{options})}
         {
	   This function removes the file \argument{file}.
	 }

\function{list}{(\argument{directory},
                 \argument{options})}
         {
	   This function lists the file system objects contains in the
	   directory \argument{directory}.

	   The option \textit{--file} tells the function to list the
	   files only.

	   The option \textit{--directory} tells the function to list
	   the directories only.
	 }

\function{change-directory}{(\argument{directory},
                             \argument{options})}
         {
	   This function changes the current working directory to
	   \argument{directory}.
	 }

\function{preprocess}{(\argument{file},
                       \argument{includes},
                       \argument{options})}
         {
	   This function performs a preprocessing task on the file
	   \argument{file}.

	   The argument \argument{includes} is used to provide additional
	   includes.

	   The option \textit{--no-markers} inhibits the generation
	   of linemarkers in the output.
	 }

\function{search}{(\argument{path},
                   \argument{pattern},
                   \argument{options})}
         {
	   This function looks for a file given the pattern
	   \argument{pattern} from the directory \argument{path}.

	   The option \textit{--file} is used to retrieve only files.

	   The option \textit{--directory} is used to retrieve only
	   directories.
	 }

\function{pack}{(\argument{directory},
                 \argument{file},
                 \argument{options})}
         {
	   This function makes an archive \argument{file} of the
	   directory \argument{directory}.
	 }

\function{unpack}{(\argument{directory},
                   \argument{file},
                   \argument{options})}
         {
	   This function extractes the archive \argument{file} into the
	   directory \argument{directory}.
	 }

\function{make-directory}{(\argument{directory},
                           \argument{options})}
         {
	   This function builds a new directory named
	   \argument{directory}.
	 }

\function{make-directory}{(\argument{directory},
                           \argument{options})}
         {
	   This function builds a new directory named
	   \argument{directory}.
	 }

\function{cut}{(\argument{head},
                \argument{tail})}
         {
	   This function tries to locate text between the two patterns
	   \argument{head} and \argument{tail} from the standard input.

	   The option \textit{--delete} tells the function to delete
	   this text and display the rest.

	   The option \textit{--print} tells the function to print
	   this text.
	 }

\function{load}{(\argument{source},
                 \argument{device},
                 \argument{path},
                 \argument{options})}
         {
	   This function loads the file \argument{source} on the
	   specificed device \argument{device}, more precisly
	   at the location \argument{path}.

	   The option \textit{--image} specifies that the argument
	   \argument{device} represents a device image.

	   The option \textit{--device} specifies that the argument
	   \argument{device} represents a device.
	 }

\function{stamp}{(\argument{format},
                  \argument{options})}
         {
	   This function returns a date following the given format
	   \argument{format}.
	 }

\function{record}{(\argument{log},
                   \argument{time},
                   \argument{options})}
         {
	   This function starts recording a session and outputs
	   the text into the file \argument{log} while the timings
	   are output in the file \argument{time}.
	 }

\function{play}{(\argument{log},
                 \argument{time},
                 \argument{options})}
         {
	   This function plays a previously recorded session where
	   the files \argument{log} and \argument{time} hold the
	   text and the timings.
	 }

\function{lookup}{(\argument{array},
                   \argument{element},
                   \argument{options})}
         {
	   This function tries to locate part of the string
	   \argument{element} in the array \argument{array}.
	 }

%
% actions
%

\section{Actions}

Almost every different actions can be triggered from the kaneton
root directory.

These actions are listed below.

\command{make init}
        {
	  This action will initialize the kaneton development environment.

	  \example{\$ make init}
	}

\command{make clean}
	{
	  This action will clean the kaneton development environment.

	  \example{\$ make clean}
	}

\command{make kaneton}
	{
	  This action will build the kaneton microkernel.

	  \example{\$ make kaneton}
	}

\command{make clear}
	{
	  This action will removing every compiled files.

	  \example{\$ make clear}
	}

\command{make purge}
	{
	  This action will clean directories from unecessary files.

	  \example{\$ make purge}
	}

\command{make dep}
	{
	  This action will generate makefiles dependencies.

	  \example{\$ make dep}
	}

\command{make proto}
	{
	  This action will generate C prototypes.

	  \example{\$ make proto}
	}

\command{make check}
	{
	  This action will be used to run the test suite used to validate
	  the kaneton whole behaviour.

	  \example{\$ make check}
	}

\command{make cheat}
	{
	  This action will launch the cheat tests on students kaneton
	  implementations.

	  \example{\$ make cheat}

	  \example{\$ make cheat-2006.k3}
	}

\command{make build}
	{
	  This action will build the boot device.

	  \example{\$ make build}
	}

\command{make install}
	{
	  This action will install the kaneton stuff on the boot device.

	  \example{\$ make install}
	}

\command{make export}
	{
	  This action will build a kaneton package.

	  \example{\$ make export}

	  \example{\$ make export-k5}
	}

\command{make view}
	{
	  This action will generate and display a kaneton document.

	  \example{\$ make view}

	  \example{\$ make view-develop}

	  \example{\$ make view-papers::kaneton}
	}

\command{make record}
	{
	  This action will record a real-time session.

	  \example{\$ make record}

	  \example{\$ make record-sessions::test.ts}
	}

\command{make play}
	{
	  This action will play a recorded session.

	  \example{\$ make play}

	  \example{\$ make play-sessions::prototypes.ts}
	}

\command{make info}
	{
	  This action will display general kaneton information.

	  \example{\$ make info}
	}
