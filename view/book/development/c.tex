%
% ---------- header -----------------------------------------------------------
%
% project       kaneton
%
% license       kaneton
%
% file          /home/mycure/kaneton/view/book/development/c.tex
%
% created       julien quintard   [fri may 25 20:24:38 2007]
% updated       julien quintard   [fri jun  1 01:05:19 2007]
%

%
% ---------- c ----------------------------------------------------------------
%

\section{C}
\label{section:c}

This section is intended to detail the kaneton \textit{C} coding style.
The specifications in this document are to be well-known by every kaneton
developer.

The kaneton coding style was introduced in order to uniformize the \textit{C}
coding styles of kaneton project contributors. Indeed, as explained in this
section, the kaneton coding style is very different from the coding styles
of other open source projects especially the \textit{GNU} style.

The key aspect of the coding style is the clarity through the coherency.
Indeed, every choice was made for the good of the project so that everyone
can very easily read the source code of the kaneton microkernel.

%
% naming
%

\subsection{Naming}

Names in kaneton must comply to the following several rules.

% general

\subsubsection{General}

Entities generally belong to a higher component: manager, module, package etc.
Since the \textit{C} language does not provide any namespace feature, the
programmer must rigorously name entities by prefixing them with the name
of the higher components.

Composite names must be separated by underscores: \textit{\_}.

Moreover, entities including variables, functions, macros, types etc. must
have explicit and/or mnemonic names.

\begin{verbatim}
  #define IA32_OPTION_READ              1

  #define SET_TYPE_ARRAY                0x02

  #define MIPS64_THREAD_STACKSZ         8192
\end{verbatim}

Obviously, names can be abbreviated, but only when it allows shorter code
without a loss of meaning. The following rules must be used in this way:

\begin{itemize}
  \item
    The suffix \textbf{sz} must be used to represent a size:

    \begin{verbatim}
      #define PAGESZ                    4096

      int                               modsz;
    \end{verbatim}
  \item
    The \textbf{n} prefix for variables representing a number:

    \begin{verbatim}
      int                               ntasks;
    \end{verbatim}
\end{itemize}

More generally, entities must be named with a \textit{unique} word,
excluding the namespace prefix. Short less explicit names are always prefered
on very long explicit names which are then difficult to name and use.

The following example first illustrates a wrong usage:

\begin{verbatim}
  t_errval              segment_dump_set(i_set              segment_set,
                                         t_uint32           number_of_segmens);
\end{verbatim}

In this example, many entities are badly named and should be replaced by
something similar to the following:

\begin{verbatim}
  t_error               segment_dump(i_set              segments,
                                     t_uint32           nsegmens);
\end{verbatim}

Indeed, types are used as pre-names. Therefore, the entity name should
not overlap the type's name. For example, the following example is incorrect:

\begin{verbatim}
  t_vaddr               video_addr;

  i_event               eventid;
\end{verbatim}

Developers should prefer simpler names:

\begin{verbatim}
  t_vaddr               video;

  i_event               id;
\end{verbatim}

Finally, names must be expressed in English, without spelling mistakes.

% capitalization

\subsubsection{Capitalization}

Entities including variables, functions, types, structures, enumerations,
unions etc. must be expressed using lower case letters, digits and underscores
only. More precisely, entity names must be matched by the following
regular expression:

\begin{verbatim}
  [a-z][a-z0-9_]*
\end{verbatim}

This is the common rule. However, some exceptions exist.

Macro names must be entirely capitalized except for macros which create
an abstraction as it is the case for the \textit{set manager} interface. Macro
arguments must be prefixed and suffixed by an underscore so that naming
collision is avoided.

\begin{verbatim}
  #define SCHEDULER_STATE_RUN           0

  #define SEGMENT_BPT_NODESZ            4096

  #define set_reserve(_type_, _args_...)                                \
    set_reserve_##_type_(_args_)
\end{verbatim}

Comments must be written in lower case letters. Indeed, no capitalization
must be used, at all.

\begin{verbatim}
  /*
   * this function shows a segment.
   *
   * steps:
   *
   * 1) get the segment object.
   * 2) compute the type string.
   * 3) compute the perms string.
   * 4) display the entry.
   * 5) call machine dependent code.
   */

  t_error                 segment_show(i_segment                  id)
  {
    [...]
  }
\end{verbatim}

% types

\subsubsection{Types}

Type names are classified according to the group they belong to.

Firstly, structures, unions and enumerations must not be directly used.
Instead, a type must be defined. In order to indicate the entity class a type
represents, prefixes are used.

Below are listed the different groups:

\begin{itemize}
  \item
    Manager types are prefixed by \textit{m\_};
  \item
    kaneton object types are prefixed by \textit{o\_};
  \item
    Dispatch interfaces are prefixed by \textit{d\_};
  \item
    Architecture-dependent types are prefixed by \textit{a\_};
  \item
    Platform-dependent types are prefixed by \textit{p\_};
  \item
    kaneton identifiers are prefixed by \textit{i\_}.
\end{itemize}

Note that group prefixes can be combined in several ways. For instance,
the prefix \textit{ao\_} represents an architecture-dependent object.

If a type does not fit in these groups, then it can be considered as a
general purpose type. In this case, one of the following prefixes must be used:

\begin{itemize}
  \item
    Structure types are prefixed by \textit{s\_};
  \item
    Enumeration types are prefixed by \textit{e\_};
  \item
    Union types are prefixed by \textit{u\_};
  \item
    Basic aliased types are prefixed by \textit{t\_}.
\end{itemize}

The example below illustrates this rule:

\begin{verbatim}
  typedef struct
  {
    i_segment                     id;

    i_as                          as;

    t_type                        type;

    t_paddr                       address;
    t_psize                       size;

    t_perms                       perms;
  }                               o_segment;
\end{verbatim}

The use of \textit{C} standard types like \textit{int}, \textit{long long}
is prohibited since there exist kaneton-specific types \textit{t\_uint32},
\textit{t\_uint64} which provide a size guarantee. Indeed, the \textit{C}
standard does not specify the size of the types \textit{int} etc. depending
on the architecture.

%
% layout
%

\subsection{Layout}

The global layout of files and sections of code pertaining to the \textit{C}
preprocessor, including file inclusion and inclusion protection, must
comply to specifications detailed in the following.

Note that an \textit{Emacs} configuration file is provided in
\textit{tool/emacs}. This file contains bindkeys for generating many of
the syntaxes explained in this section. If some contributors are using
a different text editor, then it is their responsibility to follow the rules
by developing a plugin for their text editor, for instance.

% file

\subsubsection{File}

\textit{C} source and header files are composed of sections. The example
below illustrates these sections:

\begin{verbatim}
  /*
   * -------- dependencies ----------------------------------------------------
   */

  #include <core/id.h>
  #include <core/types.h>

  /*
   * -------- macros ----------------------------------------------------------
   */

  /*
   * types
   */

  #define SET_TYPE_ARRAY          0x01
  #define SET_TYPE_BPT            0x02
  #define SET_TYPE_LL             0x03
  #define SET_TYPE_PIPE           0x04
  #define SET_TYPE_STACK          0x05

  /*
   * iterator's state
   */

  #define ITERATOR_STATE_USED     0x01
  #define ITERATOR_STATE_UNUSED   0x02
\end{verbatim}

Next are listed some of the most important sections:

\begin{itemize}
  \item
    \textbf{header}: this section contains the file header which provides
    information on the file edition: creation, last update etc.

    \-

    Note that the first and last authors are also specified in this header.
    Remember that kaneton is a community driven project and therefore these
    names do not represent the main file's authors.

    \-

    This section must be present in every source and header file as it
    contains the file creation and last updates.
  \item
    \textbf{information}: this section contains a general description of
    what this file provides.

    \-

    This section must be present in every source file.

    \begin{verbatim}
      /*
       * ---------- information -----------------------------------------------
       *
       * the address space manager manages address spaces.
       *
       * an address space describes process' useable memory. each address space
       * is composed of two sets.
       *
       * the first describes the segments held by this address space, in other
       * words the physical memory.
       *
       * the latter describes the regions, the virtual areas which reference
       * some segments.
       *
       * a task can give its address space to another with as_give().
       */
    \end{verbatim}
  \item
    \textbf{dependencies}: this section contains inclusions of dependency
    files.

    \-

    This is the common section which contains the well-known \textit{\#include}
    preprocessor directives.
  \item
    \textbf{includes}: this section contains inclusion statements of additional
    files.

    \-

    This section must not be misused since there also exist a
    \textit{dependencies} section.

    \begin{verbatim}
      /*
       * ---------- dependencies ----------------------------------------------
       */

      #include <core/id.h>
      #include <core/types.h>

      /*
       * ---------- includes --------------------------------------------------
       */

      #include <core/set-array.h>
      #include <core/set-bpt.h>
      #include <core/set-ll.h>
    \end{verbatim}
  \item
    \textbf{macros}: this section contains macro definitions.

    \-

    This section must not contain macro functions as there is a section
    dedicated to these.
  \item
    \textbf{macro functions}: this section contains the macro function
    definitions which are dissociated from the basic macro definitions.

    \begin{verbatim}
      /*
       * ---------- macros ----------------------------------------------------
       */

      /*
       * options
       */

      #define SET_OPT_NONE            0x00
      #define SET_OPT_FORWARD         0x01
      #define SET_OPT_BACKWARD        0x02
      #define SET_OPT_CONTAINER       0x04
      #define SET_OPT_ALLOC           0x08
      #define SET_OPT_FREE            0x10
      #define SET_OPT_SORT            0x20
      #define SET_OPT_ORGANISE        0x40

      /*
       * ---------- macro functions -------------------------------------------
       */

      #define set_type(_type_, _id_)                                    \
        set_type_##_type_(_id_)

      #define set_reserve(_type_, _args_...)                            \
        set_reserve_##_type_(_args_)
    \end{verbatim}
  \item
    \textbf{types}: this section contains de type definitions.
  \item
    \textbf{prototypes}: this section contains the prototype definititions.

    \-

    This section is specific as the kaneton microkernel project uses a
    tool for generating prototypes from \textit{C} source file. For more
    information, please refer to the section dedicated to the prototype
    generation.

    \begin{verbatim}
      /*
       * ---------- prototypes ------------------------------------------------
       *
       *      ../../core/set/set.c
       *      ../../core/set/set-array.c
       *      ../../core/set/set-ll.c
       *      ../../core/set/set-bpt.c
       *      ../../core/set/set-pipe.c
       *      ../../core/set/set-stack.c
       */

      /*
       * ../../core/set/set.c
       */

      t_error                 set_dump(void);

      t_error                 set_size(i_set                          id,
                                       t_setsz*                       size);
    \end{verbatim}
  \item
    \textbf{externs}: this section contains external declarations.

    \begin{verbatim}
      /*
       * ---------- extern ----------------------------------------------------
       */

      /*
       * the init variable, filled by the bootloader, containing in this case
       * the list of segments to mark used.
       */

      extern t_init*          init;
    \end{verbatim}
  \item
    \textbf{globals}: this section contains global variable declarations.

    \begin{verbatim}
      /*
       * ---------- globals ---------------------------------------------------
       */

      /*
       * the segment manager structure.
       */

      m_segment*              segment;
    \end{verbatim}
  \item
    \textbf{functions}: this section contains function definitions.
\end{itemize}

More specifically, header files are likely to contain the sections:
\textit{header}, \textit{dependencies}, \textit{macros}, \textit{types},
\textit{includes}, \textit{macro functions}, \textit{prototypes} etc. while
the source files should contain the sections: \textit{header},
\textit{information}, \textit{includes}, \textit{externs}, \textit{globals},
\textit{functions} etc.

The \textit{header} section is basically the file header which was described
in a previous section.

% preprocessor

\subsubsection{Preprocessor}

The preprocessor directives must appear on the first column with no
identation:

\begin{verbatim}
  #ifndef CORE_SET_H
  #define CORE_SET_H              1

  /*
   * debug
   */

  #if (DEBUG & DEBUG_SET) && defined(SET_DEBUG_TRAP)

  #define set_debug(_func_, _id_, _args_...)                              \
    fprintf(stderr, '[setd] trap: %s(%qu, %s)\n',                         \
            #_func_,                                                      \
            _id_,                                                         \
            #_args_);

  #else

  #define set_debug(_func_, _id_, _args...)

  #endif

  #endif
\end{verbatim}

All header files must be protected against multiple inclusions. The
guard macro must be named according to the location of the header file
with the suffix \textit{\_H} in order to avoid guard macro name collision.

\begin{verbatim}
  #ifndef ARCHITECTURE_IA32_SEGMENT_H
  #define ARCHITECTURE_IA32_SEGMENT_H           1

  [...]

  #endif
\end{verbatim}

Spanning macros over multiple lines is encouraged for a sake of clarity. In
such cases, escaped lines breaks \textit{$\backslash$-newline} must appear
on the same column. For this purpose, tabulations must be used:

\begin{verbatim}
  /*
   * traps
   */

  #define set_trap(_func_, _id_, _args_...)                               \
    (                                                                     \
      {                                                                   \
        t_error           _r_ = ERROR_UNKNOWN;                            \
        o_set*            _set_;                                          \
                                                                          \
        set_debug(_func_, _id_, _args_);                                  \
                                                                          \
        if (set_descriptor((_id_), &_set_) == ERROR_NONE)                 \
          {                                                               \
            switch (_set_->type)                                          \
              {                                                           \
                case SET_TYPE_ARRAY:                                      \
                  _r_ = _func_##_array((_id_), ##_args_);                 \
                  break;                                                  \
                case SET_TYPE_BPT:                                        \
                  _r_ = _func_##_bpt((_id_), ##_args_);                   \
                  break;                                                  \
                case SET_TYPE_LL:                                         \
                  _r_ = _func_##_ll((_id_), ##_args_);                    \
                  break;                                                  \
                case SET_TYPE_PIPE:                                       \
                  _r_ = _func_##_pipe((_id_), ##_args_);                  \
                  break;                                                  \
                case SET_TYPE_STACK:                                      \
                  _r_ = _func_##_stack((_id_), ##_args_);                 \
                  break;                                                  \
              }                                                           \
          }                                                               \
        _r_;                                                              \
      }                                                                   \
    )
\end{verbatim}

% functions

\subsubsection{Functions}

Every function must be preceded by a comment which completely describes the
actions the function performs. Moreover, some function parts need additional
description. In order not to overload the function body with heavy comments,
a kaneton-specific function organisation was introduced.

Indeed, functions body are composed of \textit{steps}, each step representing
a bunch of coherent actions. These actions are not described in the body
of the function, but rather in the comment preceding the function. Thus,
the body is clearly decomposed into steps for the sake of clarity and
expressiveness while these steps can be heavily documented in the
function comment.

Therefore, function definitions must comply this organisation as illustrated
below:

\begin{verbatim}
  /*
   * this function adds a set descriptor to the set container.
   *
   * steps:
   *
   * 1) if the descriptor to add is the set which will contain the set objects,
   *    the container, just put it as the set container.
   * 2) otherwise, add this object in the set container.
   */

  t_error                 set_new(o_set*                          o)
  {
    SET_ENTER(set);

    /*
     * 1)
     */

    if (o->setid == set->sets)
      {
        if ((set->container = malloc(sizeof(o_set))) == NULL)
          SET_LEAVE(set, ERROR_UNKNOWN);

        memcpy(set->container, o, sizeof(o_set));

        SET_LEAVE(set, ERROR_NONE);
      }

    /*
     * 2)
     */

    if (set_add(set->sets, o) != ERROR_NONE)
      {
        cons_msg('!', 'set: unable to add this set descriptor '
                 'to the set container\n');

        SET_LEAVE(set, ERROR_UNKNOWN);
      }

    SET_LEAVE(set, ERROR_NONE);
  }
\end{verbatim}

Note that putting a single blank line for separating pieces of code is more
than encouraged as it leads to a more readable source code.

Note that comments must comply to the template exposed above. The following
are examples of what is a bad comment:

\begin{verbatim}
  /*
  ** bad comment
  */

  /* Bad Comment
   */
\end{verbatim}

Finally, it is absolutely forbidden to put comments on a single line
as well as to use the \textit{C++} comment characters sequence \textit{//}.

%
% style
%

\subsection{Style}

The following sections specify various aspects of what constitutes good
programming behaviour at the language level. They cover various aspects
of the \textit{C} constructs.

% blocs

\subsubsection{Blocks}

All braces must be on their own line. This rule implies a programming style
very different from the \textit{BSD} or \textit{GNU} coding styles which
put the open brace at the end of the line.

\begin{verbatim}
  if (option & OPTION_OPTIMISED)
    {
      [...]
    }
\end{verbatim}

In addition, closing braces must appear on the same column as the
corresponding opening brace.

The text between two braces must be indented by a fixed, homogeneous amount
of whitespaces. This amount is fixed to \textit{2} whitespaces. Note that
the \textit{Emacs} default identation comply to this rule.

Moreover, the braces must also be indented by the amount of \textit{2}
spaces from the previous line. However, some exceptions exist:

\begin{verbatim}
  if (type == TYPE_SET)
    {
      int       i;

      {
        int     j;

	[...]
      }
    }
\end{verbatim}

In \textit{C} functions, the declaration part must be separated from statements
with a single blank line. Note that when there are no declarations, there
must not be any blank line separator.

Blocks are generally composed of bunches of statements and expressions. Every
developer is welcomed to put a single blank line in order to clearly separate
bunches of pieces of code.

\begin{verbatim}
  t_error                 set_get(i_set                           setid,
                                  t_id                            id,
                                  void**                          o)
  {
    t_iterator            iterator;

    SET_ENTER(set);

    if (set_locate(setid, id, &iterator) != ERROR_NONE)
      SET_LEAVE(set, ERROR_UNKNOWN);

    if (set_object(setid, iterator, o) != ERROR_NONE)
      SET_LEAVE(set, ERROR_UNKNOWN);

    SET_LEAVE(set, ERROR_NONE);
  }
\end{verbatim}

% alignment

\subsubsection{Alignment}

Declaration identifiers must be aligned with the function name, using
tabulations only. Moreover, the declarations must be ordered according
to the length of the identifier, starting with the longer, as shown below.

\begin{verbatim}
  t_error                 segment_dump(void)
  {
    t_state               state;
    t_setsz               size;
    t_iterator            i;

    [...]
  }
\end{verbatim}

In \textit{C}, pointerness is not part of the type. However, in the kaneton
coding style, the pointer symbol \textit{*} in declarations must appear next
to the type.

Function argument lists must be broken between each argument, after the
comma. In addition, the argument identifiers must be properly aligned
together, with tabulations.

\begin{verbatim}
  t_error                 as_give(i_task                  tskid,
                                  i_as                    asid)
  {
    o_task*               from;
    o_task*               to;
    o_as*                 o;

    [...]
  }
\end{verbatim}

Structures and union fields must be aligned with the type name, using
tabulations. In addition, when declaring a structure or union type, there
must be only one field declaration per line.

\begin{verbatim}
  typedef struct
  {
    i_event                       eventid;

    t_type                        type;

    u_event_handler               handler;
  }                               o_event;
\end{verbatim}

Enumerations values must be capitalized and must appear on their own line.

When an expression, declaration, assignment etc. spans over multiple lines,
the additional lines must be indented according to the type of statement.
It is indeed the responsibility of the developer to align these lines
properly. Note that \textit{Emacs}'s alignment comply to many of the
kaneton rules.

% declarations

\subsubsection{Declarations}

There must be only one declaration per line.

External declarations must not be located in functions blocks but rather in the
global scope.

Variables may be initialised at the point of declaration. This way, bugs
detection could be improved. For this purpose, however, valid expressions
are only those composed of constants and macros.

Below are illustrated some very bad constructs:

\begin{verbatim}
  t_error                 task_current(i_task*                    tsk)
  {
    i_thread              current, next;
    o_thread*             o = thread_get(current);
    extern                sched;

    [...]
  }
\end{verbatim}

% statements

\subsubsection{Statements}

A single line must not contain more than one statement. In addition, commas
must not be used on a line to separate statements.

The comma must be followed by a single space, except when they separate
arguments in functions or macro functions declarations and calls, and the
argument list spans multiple lines.

The semicolon must be followed by a newline and must not be preceded by
a whitespace, except if alone on its line.

\begin{verbatim}
  {
    int                   i;

    for (i = 0; i < 256; i++)
      ;

    [...]

    obscure_example(id, as);

    [...]
  }
\end{verbatim}

There exist exception to the above rules. For more information, please
refer to the section about control structures.

Statement keywords must be followed by a single whitespace, except
those without arguments. This especially implies the \texttt{return} without
argument, like \texttt{continue} and \texttt{break}, must not be separated
from the following semicolon.

Statement keywords which take an argument must enclose the argument
between parentheses, as illustrated next.

\begin{verbatim}
  {
    i_timer              id;

    while (1)
      {
        if (id != ID_UNUSED)
          continue;

        [...]

        return (0);
      }
  }
\end{verbatim}

Finally, the \texttt{goto} statement must not be used.

% expressions

\subsubsection{Expressions}

All binary and ternary operators must be padded on the left and right by
one space, including assignment operators.

Prefix and suffix operators must not be padded neither on the left nor on
the right.

When necessary, padding is always done with a single whitespace.

The \verb|.| and \verb|->| operators must no be padded.

Below is an example illustrating these rules.

\begin{verbatim}
  {
    int*        p;

    x = 10 * *p + reference->value++;

    x += (reference->tag == 1 ? 10 : 0);
  }
\end{verbatim}

There must not be any whitespaces between the function name and the opening
parenthesis in function calls.

Expressions may span over multiple lines. When a line break occurs within
an expression, it must appear just after a binary operator, in which case the
binary operator must not be padded on the right by a whitespace.

%
% control structures
%

\subsection{Control Structures}

% general

\subsubsection{General}

Control structure keywords must be followed by a whitespace. The conditional
parts of algorithmic constructs - \texttt{if}, \textit{while}, \texttt{do},
\textit{for}, \textit{else} - must be alone on their line.

The following constructs are incorrect:

\begin{verbatim}
  {
    if(option & OPTION_SET)
      return 0;

    while (str[i]) write(1, str[i++], 1)

    if (id != ID_UNUSED) {
      foo();
    } else {
      bar();
    }

    do {
      ++x;
    } while (x < 10);
  }
\end{verbatim}

The following must be prefered:

\begin{verbatim}
  {
    if (option & OPTION_SET)
      return (0);

    while (str[i])
      write(1, str[i++], 1)

    if (id != ID_UNUSED)
      {
        foo();
      }
    else
      {
        bar();
      }

    do
      {
        ++x;
      } while (x < 10);
  }
\end{verbatim}

% for

\subsubsection{for}

As a general exception, the \texttt{for} construct breaks many of the
previously defined rules.

Multiple statements may appear in the initial and iteration part of the
\texttt{for} structure. For this effect, commas must be used to separate
statements.

The three part of the \texttt{for} construct may span over multiple lines. The
\texttt{while} construct must be prefered to a \texttt{for} construct with
three empty parts.

The following examples are very wrong:

\begin{verbatim}
  {
    int         i;

    for (i = 0, int j = 1;
         j = j + 2, i < 10;
         i++)
      ;

    for (;;) ;
  }
\end{verbatim}

Instead, prefer:

\begin{verbatim}
  {
    int         i;
    int         j;

    for (i = 0, j = 1, j = j + 2;
         i < 10;
         j = j + 2, i++)
      ;

    for (; ; )
      ;
  }
\end{verbatim}

Finally, single-line loops - \texttt{for} and \texttt{while} - must have
their terminating semicolon on the following line, as illustrated above.

%
% ---------- XXX --------------------------------------------------------------
%

  return [sepcial dans kaneton avec les LEAVE]

+programmation differente: type retour = error, valeur retour = last args

declarations au debut des blocs et nul par ailleurs, for, a l'interieur etc..

function(input, *output)
