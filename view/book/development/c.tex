%
% ---------- header -----------------------------------------------------------
%
% project       kaneton
%
% license       kaneton
%
% file          /home/mycure/kaneton/view/book/development/c.tex
%
% created       julien quintard   [fri may 25 20:24:38 2007]
% updated       julien quintard   [sat may 26 15:42:50 2007]
%

%
% ---------- c ----------------------------------------------------------------
%

\section{C}

This section is intended to detail the kaneton \textit{C} coding style.
The specifications in this documents are to be well-known by every kaneton
developer.

The kaneton coding style was introduced in order to uniformize the \textit{C}
coding styles of kaneton project contributors. Indeed, as explained in this
section, the kaneton coding style is very different from the coding styles
of other open source project especially the \textit{GNU} style.

The key aspect of the coding style is the clarity through the coherency.
Indeed, every choice was made for the good of the project so that everyone
can very easily read the source code of the kaneton microkernel.

%
% naming
%

\subsection{Naming}

Names in programs must comply to the following several rules.

% general

\subsubsection{General}

Entities generally belong to a higher component: manager, module, package etc.
Since the \textit{C} language does not provide any namespace feature, the
programmer must rigorously name entities by prefixing them with the name
of the higher components.

Composite names must be separated by underscores: \textit{\_}.

Moreover, entities including variables, functions, macros, types etc. must
have explicit and/or mnemonic names.

\begin{verbatim}
  #define IA32_OPTION_READ              1
  #define SET_TYPE_ARRAY                0x02
  #define MIPS64_THREAD_STACKSZ         8192
\end{verbatim}

Obviously, names can be abbreviated, but only when it allows shorter code
without a loss of meaning. The following rules must be used in this way:

\begin{itemize}
  \item
    The suffix \textbf{sz} must be used to represent a size:

    \begin{verbatim}
      #define PAGESZ                    4096

      int                               modsz;
    \end{verbatim}
  \item
    The \textbf{n} prefix for variables representing a number:

    \begin{verbatim}
      int                               ntasks;
    \end{verbatim}
\end{itemize}

More generally, entities must be named with a \textit{unique} word,
excluding the namespace prefix. Short less explicit names are always prefered
on very long explicit names which are then difficult to name and use.

The following example first illustrates a wrong usage and then its correction:

\begin{verbatim}
  t_errval              segment_dump_set(i_set              segment_set,
                                         t_uint32           number_of_segmens);
\end{verbatim}

In this example, many entities are badly named and should be replaced by
something similar to the following:

\begin{verbatim}
  t_error               segment_dump(i_set              segments,
                                     t_uint32           nsegmens);
\end{verbatim}

Additionally, types are used as pre-names. Therefore, the entity name should
not overlap the type's name. For example, the following example is incorrect:

\begin{verbatim}
  t_vaddr               video_addr;

  i_event               eventid;
\end{verbatim}

Developers should prefer simpler names:

\begin{verbatim}
  t_vaddr               video;

  i_event               id;
\end{verbatim}

Finally, names must be expressed in English, without spelling mistakes.

% capitalization

\subsubsection{Capitalization}

Entities including variables, functions, types, structures, enumerations,
unions etc. must be expressed using lower case letters, digits and underscores
only. More precisely, entity names must be matched by the following
regular expression:

\begin{verbatim}
  [a-z][a-z0-9_]*
\end{verbatim}

This is the common rule. However, some exceptions exist.

Macro names must be entirely capitalized except for macros which create
an abstraction as it is the case for the \textit{set manager} interface. Macro
arguments must be prefixed and suffixed by an underscore so that naming
collision is avoided.

\begin{verbatim}
  #define SCHEDULER_STATE_RUN           0
  #define SEGMENT_BPT_NODESZ            4096

  #define set_reserve(_type_, _args_...)                                \
    set_reserve_##_type_(_args_)
\end{verbatim}

Comments must also be written in lower case letters. Indeed, no capitalization
must be used, at all.

\begin{verbatim}
  /*
  * this function shows a segment.
  *
  * steps:
  *
  * 1) get the segment object.
  * 2) compute the type string.
  * 3) compute the perms string.
  * 4) display the entry.
  * 5) call machine dependent code.
  */

  t_error                 segment_show(i_segment                  segid)
  {
    [...]
  }
\end{verbatim}

% types

\subsubsection{Types}

Type names are classified according to the group they belong to.

Firstly, structures, unions and enumerations must not be directly used.
Instead, a type must be defined. In order to indicate the entity class a type
represents, prefixes are used.

Below are listed the different groups:

\begin{itemize}
  \item
    Manager types are prefixed by \textit{m\_};
  \item
    kaneton object types are prefixed by \textit{o\_};
  \item
    Dispatch interfaces are prefixed by \textit{d\_};
  \item
    Architecture-dependent types are prefixed by \textit{a\_};
  \item
    Platform-dependent types are prefixed by \textit{p\_};
  \item
    kaneton identifiers are prefixed by \textit{i\_}.
\end{itemize}

Note that group prefixed can be combined in several ways. For instance,
the prefix \textit{ao\_} represents an architecture-dependent object.

If a type does not fit in these groups, then it can be considered as a
general purpose type. In this case, one of the following prefixes must be used:

\begin{itemize}
  \item
    Structure types are prefixed by \textit{s\_};
  \item
    Enumeration types are prefixed by \textit{e\_};
  \item
    Union types are prefixed by \textit{u\_};
  \item
    Basic aliased types are prefixed by \textit{t\_}.
\end{itemize}

The example below illustrates this rule:

\begin{verbatim}
  typedef struct
  {
    i_segment                     segid;

    i_as                          asid;

    t_type                        type;

    t_paddr                       address;
    t_psize                       size;

    t_perms                       perms;
  }                               o_segment;
\end{verbatim}

%
% layout
%

%
% ---------- XXX --------------------------------------------------------------
%

Layout
  File [trailing whitespace, empty lines]
  Comments [lowercase]
  Preprocessor [\\]

Style
  Blocks
  Alignment
  Declarations
  Statements
  Expressions
  Functions [arg align]

Control Structures
  General Rules
  for
  switch

+comment system: step etc..
+programmation differente: type retour = error, valeur retour = last args
