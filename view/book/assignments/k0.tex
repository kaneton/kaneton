%
% ---------- header -----------------------------------------------------------
%
% project       kaneton
%
% license       kaneton
%
% file          /home/mycure/kaneton/view/book/assignments/future/k0.tex
%
% created       julien quintard   [fri nov 28 05:25:37 2008]
% updated       julien quintard   [sat nov 29 16:07:29 2008]
%

%
% ---------- k0 ---------------------------------------------------------------
%

\chapter{k0}
\label{chapter:k0}

\name{k0} is an introduction to low-level programming.

\newpage

%
% ---------- text -------------------------------------------------------------
%

\section{Abstract}

k0 is an introduction to low level programming. During this first step of
the kaneton project, you will deal with:

\begin{enumerate}
  \item
    {\bf Intel x86}

    x86 assembly and architecture
  \item
    {\bf BIOS interrupts}

    How to use BIOS services
  \item
    {\bf ELF binaries}

    Structure and execution of an ELF file
\end{enumerate}

The final goal is to write a complete ELF bootloader, which could be used to
load a kernel.

\clearpage

\section{Tarball}

What we expect is a .tar.bz2 tarball which contains the following structure :
\begin{verbatim}
        ex1/ex1.S
        ex2/ex2.S
        ex3/ex3.S
        ex4/ex4.S
        ex5/ex5.S
        ex6/ex6.S
\end{verbatim}

The tarball should contain these files and nothing more. Please be careful with
the extension of the source files. the S is uppercase !

Each file should contain the labels (functions) that are expected, and should
end with the bootsector signature.

Here is a sample of what a file should look like :

\begin{verbatim}
.code16

requested_function_1:
	mov $0x42, %ah
	mov %bl, %bl
local_label:
	int $0x10
	xor %dh, %dh
        jmp local_label
	ret

signature:
	.org 510, 0
	.short 0xaa55

\end{verbatim}

\section{Testing}

You will need to test your own code. Since you are using gcc to build, your
source file is going through the CPP preprocessor. This means you can use
the \#include directives in your files.

We suggest you to write separate test files which include your source file.
For example, to write a test file for exercise 1, you can write this :

\begin{verbatim}

.globl _start
_start:
        mov 0x42, %al
        call print_char
loop:
        jmp loop

#include "ex1.S"

\end{verbatim}

This way, your code file will never contain test code, so you don't risk giving
us your test code in your source file.


Your code will be tested automatically by our test suite. We are going to link
your code with our test code. The whole thing has to fit in 512 bytes once assembled. This means that you have to write your code efficiently, to prevent generating too much binary code, which would make it impossible for it to fit together with our test code in 512 bytes.
To prevent that, each exercise indicated the maximum size our test code will take, in bytes.
For each exercise, you have to run a test to make sure your code will fit with our test code during the tests.
To do that, you need to make a simple test file which just contains, for exercise 1, for instance :

\begin{verbatim}

.space 175,0

#include "ex1.S"

\end{verbatim}

The value 175 has to be replaced by the value indicated for each exercice.

Then you need to try to run gcc on that file. If gcc returns without error, it means that your code is small enough to be linked with our test code, otherwise, you will get this kind of error message :

\begin{verbatim}
ex1.S: Assembler messages:
ex1.S:12: Error: attempt to move .org backwards
\end{verbatim}

This means you have to optimize your code until it fits, otherwise you will fail some tests on this exercise.

%
% String display
%

\newpage

\section{Exercises}

\subsection{String display}

\subsubsection*{Overview}
In this first exercise you will learn how to use Video BIOS Services to
print strings on the screen.

\subsubsection*{Assignments}
The work is divided up into several steps. First, try to print a char and
to move the cursor on the screen and then, use those functions to display
a string.

\subsubsection*{File}
\begin{itemize}
  \item \location{ex1/ex1.S}
\end{itemize}

\subsubsection*{Free space required}
175 bytes

\subsubsection*{Interface}
\command{print\_char}
{
  Print the character which ASCII code is \argument{\%al} at current cursor
  position.
}

\command{cursor\_set}
{
  Set cursor position at row \argument{\%dh} and column \argument{\%dl}.
}

\command{print\_string}
{
  Print the string pointed by \argument{\%si} at row \argument{\%dh} and
  column \argument{\%dl}.
}

%
% Registers dump
%

\newpage

\subsection{Registers dump}

\subsubsection*{Overview}
This exercice requires more assembly skill. Its only point is to make you
practice.

\subsubsection*{Assignments}
You will code three famous libc-like functions and use them to program
a function which will dump the values stored in some registers.

\subsubsection*{File}
\begin{itemize}
  \item \location{ex2/ex2.S}
\end{itemize}

\subsubsection*{Free space required}
155 bytes

\subsubsection*{Interface}
\command{malloc}
{
  This function allocates memory in a very simple way. Declare the heap and
  declare a break value at its beginning.
  Your malloc must allocate \argument{\%ax} bytes and return the address
  in \argument{\%di}.
}

\command{itoa\_hex}
{
  Convert the integer in \argument{\%ax} into string using hexadecimal
  representation and store in \argument{\%si} the address of the string.
  The format must follow the regular expression 0x[0-9a-f]\{4\}.
  42 must for instance be printed as 0x002a. You could use this function
  to check your malloc, since the buffer where you will store the result
  string has to be allocated somewhere in memory.
}

\command{dump\_registers}
{
  Program a function which dumps the registers. You will start writing
  at current cursor position, i.e. you \emph{must not} modify it. You have to
  follow this output:
}
\begin{verbatim}
        ax = 0x1234
        bx = 0x0000
        cx = 0xabcd
        dx = 0x00ff
        si = 0x1000
        di = 0x0ff8
\end{verbatim}

\command{}
{
  {\em Important:}

  You have to handle the end of the screen. When you are on the last line of
  the screen, going to the next line means going back to the first line.
  You can know if the cursor is at the last line by reading its position
  with the appropriate BIOS call.

  {\em Warning:}

  Start output at current cursor position, even if it is not at the beginning
  of a line. To simulate a line return, just move
  the cursor to the first column of the line under. Even though it could be
  ugly, don't move the cursor before printing and don't erase the characters
  printed by \textbf{qemu}!

  Also, Qemu will have already displayed some stuff before you run this
  function. It means the output will probably be ugly (mixed up with qemu BIOS
  messages), but it's important that you don't try to make it look nice, or
  you won't pass the tests. So your output will be mixed up in qemu BIOS stuff
  and will probably have some fancy colors too, but it's not a problem.
}

%
% Keyboard inputs
%

\newpage

\subsection{Keyboard inputs}

\subsubsection*{Overview}
Now that you are more familiar with BIOS services and assembly programming,
you're going to write a basic keyboard driver.

\subsubsection*{Assignments}
First, you will program a function which gets keycodes from the keyboard
buffer, and then, use this function to print entered text on the screen.

\subsubsection*{File}
\begin{itemize}
  \item \location{ex3/ex3.S}
\end{itemize}

\subsubsection*{Free space required}
155 bytes

\subsubsection*{Interface}
\command{get\_key}
{
  Get an ASCII code from the keyboard buffer and store it in \argument{\%al}.
}

\command{getln}
{
  This function prints characters typed on the keyboard until the ENTER key
  is pressed. Pressing ENTER will result in a newline being printed and the
  function will return.
  The modifiers like SHIFT, ALT, CTRL or caps lock won't be tested. Advanced
  typing using the arrows, BACKSPACE and DELETE is not required either.
  You don't have to handle the end of line special case, it won't be tested.
}

%
% Floppy drive
%

\newpage

\subsection{Floppy drive}

\subsubsection*{Overview}
During this exercise you are going to work with floppy drives using BIOS
interrupts. The final goal is to load the second sector from the floppy drive
in order to check whether it's a bootsector or not. In this exercise, we load the
second sector, because the first sector is already loaded. This technique is used
for example by GRUB to perform \emph{chainloading}.

\subsubsection*{Assignments}
The drive must be initialized before any reading. Then, get the second sector of
the floppy, and check the signature. A valid bootsector ends with 0xaa55.

Be careful, sectors are actually numbered starting from 1, and not 0.

\subsubsection*{File}
\begin{itemize}
  \item \location{ex4/ex4.S}
\end{itemize}

\subsubsection*{Free space required}
155 bytes

\subsubsection*{Interface}
\command{floppy\_init}
{
  Initialize floppy drive.
}

\command{is\_bootsector}
{
  Initializes the floppy drive, load the second sector of the floppy and
  check whether it is a valid
  bootsector. It must print the following output at current cursor
  position for the following cases - respectively valid, and invalid $0x0042$
  signatures:
}
\begin{verbatim}
        magic found: 0xaa55
\end{verbatim}
\command{}
{
  or
}
\begin{verbatim}
        wrong magic: 0x0042
\end{verbatim}

\command{}
{
  The magic number which should be printed is the one that has been read in
  the sector which has been loaded.
  This function has to initialize the floppy drive, you can call your previous
  function to do that.
}

%
% Operating mode switching
%

\newpage

\subsection{Operating mode switching}

\subsubsection*{Overview}
Since kernels generally use 32-bit mode, it's time to know how to switch from
\emph{real} 16-bit mode to \emph{protected} 32-bit mode.

\subsubsection*{Assignments}
You will first read \emph{Intel IA-32 mode switching procedure} on the wiki
and code a function to switch to that mode. Then, you will have to display a
string in 32-bit mode.

{\em Warning:}

Don't forget that the code executed after switching to protected mode must be
32-byte assembled code. Moreover, BIOS interrupts cannot be used in protected
mode, see \emph{VGA text Framebuffer} on the Wiki to know how to do.

\subsubsection*{File}
\begin{itemize}
  \item \location{ex5/ex5.S}
\end{itemize}

\subsubsection*{Free space required}
225 bytes

\subsubsection*{Interface}
\command{pmode\_switch}
{
  Switch from real mode to protected mode.
  Note that when calling this function, the CPU will push the return address
  as a 16-bit address, but when returning from it, the CPU will pop a 32 bit
  return address since it will have switched from real (16-bit) to protected
  (32-bit) mode. Consider that you don't have to do anything special to get
  this to work : the caller of this function will have to push the 16-bit zero
  value on the stack before calling, so that the instruction pointer does get
  a valid 32-bit return address.

  Don't forget to push zero before calling it for your tests too.
}

\command{print\_string32}
{
  Print the string \argument{\%esi} on the screen at row \argument{\%ecx}
  and column \argument{\%edx}. The rows and columns are starting at index 0.
  So the upper left corner has coordinates (0,0).
  We don't care about colors, you can change them or not.
  You don't have to handle the end of line, this will not be tested.
}

%
% ELF Loader
%

\newpage

\subsection{ELF Loader}

\subsubsection*{Overview}
Any bootloader must be able to load a kernel binary and to execute it.
The \emph{Executable and Linking Format} is a binary executable format used on
many UNIX platform. The goal of this part is to give an introduction to the
ELF structure so that you will learn how to load and execute such a file.

\subsubsection*{Assignments}
You will write a complete bootloader which loads and executes an ELF file
- located right after the bootsector - and then relocate it in memory
before jumping on it.

An ELF binary is provided to be loaded with your bootsector (see \emph{Files}
on the Wiki). To build a disk image with your bootsector on the first sector,
and the kernel on the next ones, you can use the following command:

\begin{verbatim}
42sh$ cat bootsector kernel.elf /dev/zero | dd bs=512 count=2880 of=disk.img
\end{verbatim}

To load and execute an ELF file, you will have to parse the ELF header at the
beginning of the file. Each ELF file is divided into \emph{segments} which are
located into different offsets, and must be separately relocated at different
memory locations. The segment list of the executable file is described by the
\emph{Program Headers} table - \emph{Phdr} - in the ELF header (read \emph{ELF Header} on the Wiki).

\subsubsection*{File}
\begin{itemize}
  \item \location{ex6/ex6.S}
\end{itemize}

\subsubsection*{Free space required}
145 bytes

\subsubsection*{Interface}

\command{kernel\_preload}
{
  This function has to load into memory the number of sectors given into
  \argument{\%al}, from the drive given into \argument{\%dl}, starting from
  the second sector.

  The function must switch to protected mode, and return into \argument{\%eax}
  the address of the memory area where sectors are loaded.

  You have to handle the case of a kernel which resides on more than a single
  track, which requires several calls to the appropriate BIOS call.
}

\command{elf\_load}
{
  Load and execute the elf file located at address \argument{\%esi}.
  Consider that the caller has called \command{kernel\_preload} before calling
  this function, so this function doesn't need to call it.
}
