%
% ---------- header -----------------------------------------------------------
%
% project       kaneton
%
% license       kaneton
%
% file          /home/mycure/kaneton/view/book/assignments/k3.tex
%
% created       julien quintard   [fri nov 28 05:25:37 2008]
% updated       julien quintard   [mon feb  7 20:45:53 2011]
%

%
% ---------- k3 ---------------------------------------------------------------
%

\chapter{k3}
\label{chapter:k3}

\name{k3} consists in providing the kaneton microkernel with a multitasking
environment.

kaneton relies on the concept of \name{task} which contains an address space
and one or more \name{thread}s. The \name{scheduler} takes threads and
decides which one should be executed next. By switching between one thread and
another at a fast pace, the kernel gives the user the illusion to execute
programs in parallel.

\newpage

%
% ---------- text -------------------------------------------------------------
%

%
% requirements
%

\section{Requirements}

Every student will find in the chapter \name{Task Management} of the
\name{IA-32 Architectures Software Developer's Manual, Volume 3A: System
Programming Guide, Part 1}.

In addition, students should not hesistate to dive into the chapters
\name{Interrupt and Exception Handling} and \name{Protection} which contain
material directly related to this stage.

%
% assignments
%

\section{Assignments}

The objective in this stage is for students to \textit{(i)} complete the
scheduler manager's core by implementing their own algorithm and \textit{(ii)}
implement the hardware \name{Intel} context switch.

% core
\subsection{Core}

XXX 4 managers: task, thread, scheduler and cpu

% scheduler
\subsubsection*{scheduler}

\begin{itemize}
  \item
    \location{kaneton/core/scheduler/scheduler.c}
  \item
    \location{kaneton/core/include/scheduler.h}
\end{itemize}

XXX

- dans scheduler.h on a la structure d'un scheduler. a noter que le
  scheduler manager est concu pour les systemes multiprocs. ainsi il
  y a un scheduler par CPU, ceux-ci etant stockes dans un set.

- the student is welcome to add the necessary to the scheduler structure
  or even to change everything including the code already provided as long
  as the scheduler interface remains.

  show/dump: affiche c'est cool super pas important
  quantum: change la duree minimum d'execution d'un thread. warning: must
    be a multiple of the timer delay. the threads already in the scheduler
    may need to be updated in order to adjust their timeslices.
  yield: very important, the objective is the give up the execution right
    away! the student must therefore find a way to do this.
  elect: objective, find the next thread to schedule though it could be the
    same. here is the core algorithm: decrease the timeslice of the current
    thread, try to find a more important thread to schedule or the current
    one if it has not expired, or any active one or the idle. that is the
    basic idea though students are welcome to do as they want.
    important: if the scheduler state is stop, return the future thread
    as being the kernel thread i.e \_kernel.thread
  add: add the thread to the active threads
  remove: remove the thread from the scheduler. note that if the thread
   is currently being scheduled, the execution should be yielded. students
   should read the code of the thread manager as a specific behaviour is
   expected from some of those functions.
  update: retrieve the thread and update its priority and timeslice, moving
   the thread to another queue for example, if required.

  students should update whatever they need in this manager.

%
% glue
%

\subsection{Glue}

XXX students should also have a look at the cpu, task glue managers. more
important is to thorougly study the thread manager's glue which calls the
architecture context functions: context-setup in initialize, context-build
in reserve and context-destroy in clean.

% scheduler
\subsubsection*{scheduler}

\begin{itemize}
  \item
    \location{kaneton/machine/glue/ibm-pc.ia32/educational/scheduler.c}
  \item
    \location{kaneton/machine/glue/ibm-pc.ia32/educational/include/scheduler.h}
\end{itemize}

XXX

as the student can notice a few thins are already set up in the glue
scheduler manager:
- a timer is reserved when the scheduler is started. note that since the
 machine knows a single CPU is supported, hence there will be a single
 scheduler, the CPU argument to scheduler\_start is ignored.
- the handler triggered by this timer is also provided: scheduler\_switch().
  this function basically calls elect() and then requests the architecture
  function context\_switch() to perform the actual context switch between
  the current and the future thread.
  note that the provided functions assume that scheduler->thread contains
  the current elected thread. students can change that as long as the rest
  is updated accordingly.

this file therefore contains the core of the scheduler, the function which
is called on a regular basis and ask the manager to elect a new thread. then
the context switch is requested.

%
% architecture
%

\subsection{Architecture}

XXX the basic idea is to rely on interrupts

% context
\subsubsection*{context}

\begin{itemize}
  \item
    \location{kaneton/machine/architecture/ia32/educational/context.c}
  \item
    \location{kaneton/machine/architecture/ia32/educational/include/context.h}
\end{itemize}

XXX

- warning: depending on the thread's privilege (ring0 or other) the information
 will be stored on the stack or the pile (aka the thread's kernel/ring0 stack).
 until now, and more precisely in k1, interrupts and exceptions were
 interrupted the only thread i.e the kernel thread which evolves in ring0.
 thus everything was pushed on the kernel thread's current stack. this must
 be adapted by using the SAVE and RESTORE macros.

- note that as a effect, the location of the thread's context is either
 on the stack or the pile. thus, once an interrupt occur, the location of
 the context should be set for the kernel to read/write the interrupted
 thread's context. the address of the context should be set in
 thread->machine.context.

- the objective is to save the interrupted thread's context, then to
 load the kernel address space by using architecture.kernel.pdbr and
 more precisely to jump on the KIS - Kernel Interrupt Stack which is used
 specifically to handle interrupts: architecture.kernel.kis.pointer contains
 the stack pointer.

- the context switch is basically composed of the switch() function coupled
 with the two macros SAVE and RESTORE.

- the switch() function takes the current and future thread. the idea
 behind this function is to update the architecture structure for the
 RESTORE macro-function to know what to restore and perhaps to update the
 TSS if necessary.

- SAVE should be called by the asm part of an interrupt handler in
 order to save the thread context. note that the context expected to be
 saved is given in context.h though it can be adapted to your needs. once
 the context saved, the KIS must be set up by loading the kernel PDBR.
 finally some registers may need to be updated for the KIS handler.

- RESTORE does the opposite moving from the KIS back to the thread stack
 or pile depending on its privilege, restoring its context and returning from
 the interrupt.

XXX

% context
\subsubsection*{context}

\begin{itemize}
  \item
    \location{kaneton/machine/architecture/ia32/educational/context.c}
  \item
    \location{kaneton/machine/architecture/ia32/educational/include/context.h}
\end{itemize}

XXX the architecture structure which is at the center of context switch
 mechanism

%
% advices
%

\section{Advices}

  appeler context\_locate
