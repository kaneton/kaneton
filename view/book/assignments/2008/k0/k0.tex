%%
%% licence       kaneton licence
%%
%% project       kaneton
%%
%% file          /home/lec_l/kaneton/view/books/assignments-k0/k0.tex
%%
%% created       laurent lec   [thu jan 17 22:42:21 2008]
%% updated       laurent lec   [thu jan 17 22:42:21 2008]
%%

%
% k0
%

\chapter{k0: bootstrap}

%
% informations
%

\begin{tabular}{p{7cm}l}
Duration: & 1 week \\
File name: & {\em login\_x}-k0.tar.bz2 \\
In charge: & Julian Pidancet \& Elie Bleton\\
Mailing-list: & kaneton-students@googlegroups.com \\
Languages: & x86 assembly, C and ld scripts \\
Students per group: & 1 \\
\end{tabular}

\section{Abstract}

k0 is an introduction to low level programming. During this first step of
the kaneton project, you will deal with :

\begin{enumerate}
  \item
    {\bf Intel x86}\\
    Introduction to x86 assembly and architecture\\
  \item
    {\bf BIOS interrupts}\\
    How to use BIOS services\\
  \item
    {\bf ELF binaries}\\
    Structure and execution of an ELF file\\
\end{enumerate}

\clearpage

\section{Before starting}

\begin{itemize}
\item
  You have to use \textbf{gas} syntax. Use \textbf{gcc} to assemble your
  code and \textbf{ld} to output the flat binary.
  \begin{verbatim}
gcc  -c bootsect.S -o bootsect.o
ld bootsect.o -o bootsect --oformat binary --Ttext 0x7c00
  \end{verbatim}
\item
  You will use \textbf{qemu} to test your binary.
  \begin{verbatim}
qemu -fda bootsect
  \end{verbatim}
\item
  Remember that x86 processors start in 16-bit mode, so you must find a
  directive to tell \textbf{gcc} to assemble 16-bit code. When you later
  switch to protected mode, find another directive to assemble 32-bit code.
\item
  \emph{No} register shall be modified unless explicitly requested.
\item
  Your bootsector must end with signature 0xaa55 to be valid. This means you
  must insert blank bytes after your code until byte 510, and then dump
  the signature.
\item
  Screeb output will be strictly tested, so be careful : it must not
  differ.
\item
  Your test code must be removed from final source but the signature must be
  present. Your code must not include a label \textbf{\_start}.
\end{itemize}

Good luck and have fun !

%
% String display
%

\newpage

\section{String display}

\subsection*{Overview}
In this first exercise you will learn how to use Video BIOS Services to
print strings on the screen.

\subsection*{Assignments}
The work is divided up into several steps. First, try to print a char and
to move the cursor on the screen and then, use those functions to display
a string.

\subsection*{File}
\begin{itemize}
  \item k0-login\_x/ex1/ex1.S
\end{itemize}

\subsection*{Interface}
\function{print\_char}{}
{
  Print the character which ASCII code is \argument{\%ah} at current cursor
  position.
}

\function{cursor\_set}{}
{
  Set cursor position at row \argument{\%ah} and column \argument{\%al}.
}

\function{print\_string}{}
{
  Print the string pointed by \argument{\%si} at row \argument{\%ah} and
  column \argument{\%al}.
}

%
% Registers dump
%

\newpage

\section{Registers dump}

\subsection*{Overview}
This exercice requires more assembly skill. Its only point is to make you
practice.

\subsection*{Assignments}
You will code three famous libc-like functions and use them to program
a function which will dump the values stored in some registers.

\subsection*{File}
\begin{itemize}
  \item k0-login\_x/ex2/ex2.S
\end{itemize}

\subsection*{Interface}
\function{malloc}{}
{
  This function allocates memory in a very simple way. Declare the heap and
  declare a break value at its beginning.
  Your malloc must allocate \argument{\%ax} bytes and return the address
  in the same register.
}

\function{itoa}{}
{
  Convert the integer \argument{\%ax} into string whose address will be
  stored in \argument{\%ax}. Use this function to check your malloc.
}

\function{itoa\_hex}{}
{
  Convert the integer in \argument{\%ax} into string using hexadecimal
  representation and store in \argument{\%ax} the address of the string.
  The format must follow the regular expression 0x[0-9a-f]\{4\}.
  42 must for instance be printed as 0x002a.
}

\function{dump\_registers}{}
{
  Program a function which dumps the registers. You will start writing
  at current cursor position, i.e. you \emph{must not} modify it. You have to
  follow this output :
}
\begin{verbatim}
        ax = 0x1234 = 4660
        bx = 0x0000 = 0
        cx = 0xabcd = 43981
        dx = 0x00ff = 255

        bp = 0x1000 = 4096
        sp = 0x0ff8 = 4088
        ip = 0x7c00 = 317445
\end{verbatim}

\function{}{}
{
  {\em Warning:}

  Start output at current cursor position. To simulate a line return, just move
  the cursor to the first column of the line under. Even though it could be
  ugly, don't move the cursor before and don't erase the characters printed by
  \textbf{qemu}, just move the cursor !
}

%
% Keyboard inputs
%

\newpage

\section{Keyboard inputs}

\subsection*{Overview}
Now that you are more familiar with BIOS services and assembly programmation,
you're going to write a basic keyboard driver.

\subsection*{Assignments}
First, you will program a function which gets keycodes from the keyboard
buffer, and then, use this function to print entered text on the screen.

\subsection*{File}
\begin{itemize}
  \item k0-login\_x/ex3/ex3.S
\end{itemize}

\subsection*{Interface}
\function{get\_key}{}
{
  Get an ASCII code from the keyboard buffer and store it in \argument{\%al}.
}

\function{getln}{}
{
  This function prints entered strings. Pressing ENTER will result in a
  newline.
  The modifiers like SHIFT, ALT, CTRL or caps lock won't be tested. Advanced
  typing using the arrows, BACKSPACE and DELETE is not required either.
}

%
% Floppy drive
%

\newpage

\section{Floppy drive}

\subsection*{Overview}
During this exercise you are going to work with floppy drives using BIOS
interrupts. The final goad is to load the first sector of a floppy in order
to check whether it's a bootsector or not.

\subsection*{Assignments}
The drive must be initialized before any reading. Then, get the first sector of
the floppy, and check the signature. A valid bootsector ends with 0xaa55.

\subsection*{File}
\begin{itemize}
  \item k0-login\_x/ex4/ex4.S
\end{itemize}

\subsection*{Interface}
\function{floppy\_init}{}
{
  Initialize floppy drive.
}

\function{is\_bootsector}{}
{
  Load the first sector of the floppy and check whether it is a valid
  bootsector. It must print the following output at current cursor
  position for each case :
}
\begin{verbatim}
        magic found: 0xaa55
\end{verbatim}
\function{}{} {
or
}
\begin{verbatim}
        wrong magic: 0x0042
\end{verbatim}


%
% Operating mode switching
%

\newpage

\section{Operating mode switching}

\subsection*{Overview}
Since kernels generally use 32-bit mode, it's time to know how to switch from
``real'' 16-bit mode to ``protected'' 32-bit mode.

\subsection*{Assignments}
You will first read \emph{Intel IA-32 mode switching procedure} and code a
function to switch to that mode. Then, you will have to display a string in
32-bit mode.

{\em Warning:}\\
Don't forget that the code executed after switching to protected mode must be
32-byte assembled code. Moreover, BIOS interrupts are never used in protected
mode, see \emph{VGA text Framebuffer} appendix to know how to do.

\subsection*{File}
\begin{itemize}
  \item k0-login\_x/ex5/ex5.S
\end{itemize}

\subsection*{Interface}
\function{pmode\_enabled}{}
{
  Switch from real mode to protected mode.
}

\function{print\_string32}{}
{
  Print the string \argument{\%si} on the screen at row \argument{\%ah}
  and column \argument{\%al}. We don't care about colors, you can change them
  or not.
}

%
% ELF Loader
%

\newpage

\section{ELF Loader}

\textbf{FIXME}


%
% Appendix
%

\chapter{Appendix}

%
% BIOS services
%

\section{BIOS services}

We give you the documentation about the BIOS interrupts you need for this
project.

If you want to call interrupt \argument{N,M} you need to put \argument{M} in
\argument{ah} and to use the instruction \textbf{int N}. Be careful, the
interrupt code is always given in its hexadecimal representation. Therefore,
\emph{INT 10} stands for \emph{INT 0x10}.

%
% Video BIOS services
%
\subsection{INT 10,2 Set cursor position}
\begin{itemize}
  \item{AH = 0x02}
  \item{BH = page number (0 for graphics modes)}
  \item{DH = row}
  \item{DL = column}
\end{itemize}

80x25 mode uses coordinates (0, 0) to (24, 79).

\subsection{INT 10,3 Read cursor position and size}
\begin{itemize}
  \item{AH = 0x03}
  \item{BH = page number (0 for graphics modes)}
\end{itemize}

On return :

\begin{itemize}
  \item{CH = cursor starting scan line (low order 5 bits)}
  \item{CL = cursor ending scan line (low order 5 bits)}
  \item{DH = row}
  \item{DL = column}
\end{itemize}


\subsection{INT 10,E Write text in teletype mode}
\begin{itemize}
  \item{AH = 0x0e}
  \item{AL = ASCII character to write}
  \item{DH = page number (text modes)}
  \item{BL = foreground pixel color (graphics mode)}
\end{itemize}

Cursor advances after write.

%
% Diskette BIOS Services
%
\subsection{INT 13,0 Reset disk system}
\begin{itemize}
  \item{AH = 0x00}
  \item{DL = drive number}
\end{itemize}

On return :

\begin{itemize}
  \item{AH = disk operationstatus}
  \item{CF = 0 if successful, 1 if error}
\end{itemize}

\subsection{INT 13,2 Read disk sectors}
\begin{itemize}
  \item{AH = 0x02}
  \item{AL = number of sectors to read}
  \item{CH = track/cylinder number}
  \item{CL = sector number}
  \item{DH = head number}
  \item{DL = drive number}
  \item{ES:BX = pointer to buffer}
\end{itemize}

On return :

\begin{itemize}
  \item{AH = disk operationstatus}
  \item{AL = number of sectors read}
  \item{CF = 0 if successful, 1 if error}
\end{itemize}
%
% Keyboard BIOS Services
%
\subsection{INT 16,0 Wait for keypress and read character}
\begin{itemize}
  \item{AH = 0x00}
\end{itemize}

On return :

\begin{itemize}
  \item{AH = keyboard scan code}
  \item{AL = ASCII character or zero if special function key}
\end{itemize}

Halts program until a key with a scancode is pressed.

%
% VGA text framebuffer
%
\newpage
\section{VGA text framebuffer}
\textbf{FIXME}

%
% Intel mode switching
%

\newpage
\section{Intel IA-32 mode switching procedure}
\textbf{FIXME}

%% To use the processor in protected mode after hardware or software reset, a mode
%% switch must be performed from real-address mode. Once in protected mode, soft-
%% ware generally does not need to return to real-address mode. To run software written
%% to run in real-address mode (8086 mode), it is generally more convenient to run the
%% software in virtual-8086 mode, than to switch back to real-address mode.

%% Before switching to protected mode from real mode, a minimum set of system data
%% structures and code modules must be loaded into memory, as described in Section
%% 9.8, “Software Initialization for Protected-Mode Operation.” Once these tables are
%% created, software initialization code can switch into protected mode.

%% Protected mode is entered by executing a MOV CR0 instruction that sets the PE flag
%% in the CR0 register. (In the same instruction, the PG flag in register CR0 can be set to
%% enable paging.) Execution in protected mode begins with a CPL of 0.

%% Intel 64 and IA-32 processors have slightly different requirements for switching to
%% protected mode. To insure upwards and downwards code compatibility with Intel 64
%% and IA-32 processors, we recommend that you follow these steps:

%% 1. Disable interrupts. A CLI instruction disables maskable hardware interrupts. NMI
%%      interrupts can be disabled with external circuitry. (Software must guarantee
%%      that no exceptions or interrupts are generated during the mode switching
%%      operation.)

%% 2. Execute the LGDT instruction to load the GDTR register with the base address of
%%      the GDT.

%% 3. Execute a MOV CR0 instruction that sets the PE flag (and optionally the PG flag)
%%      in control register CR0.

%% 4. Immediately following the MOV CR0 instruction, execute a far JMP or far CALL
%%      instruction. (This operation is typically a far jump or call to the next instruction in
%%      the instruction stream.)
%%      The JMP or CALL instruction immediately after the MOV CR0 instruction changes
%%      the flow of execution and serializes the processor.
%%      If paging is enabled, the code for the MOV CR0 instruction and the JMP or CALL
%%      instruction must come from a page that is identity mapped (that is, the linear
%%      address before the jump is the same as the physical address after paging and
%%      protected mode is enabled). The target instruction for the JMP or CALL instruction
%%      does not need to be identity mapped.

%% 5. If a local descriptor table is going to be used, execute the LLDT instruction to load
%%      the segment selector for the LDT in the LDTR register.

%% 6. Execute the LTR instruction to load the task register with a segment selector to
%%     the initial protected-mode task or to a writable area of memory that can be used
%%     to store TSS information on a task switch.

%% 7. After entering protected mode, the segment registers continue to hold the
%%     contents they had in real-address mode. The JMP or CALL instruction in step 4
%%     resets the CS register. Perform one of the following operations to update the
%%     contents of the remaining segment registers.
%%     — Reload segment registers DS, SS, ES, FS, and GS. If the ES, FS, and/or GS
%%         registers are not going to be used, load them with a null selector.
%%     — Perform a JMP or CALL instruction to a new task, which automatically resets
%%         the values of the segment registers and branches to a new code segment.

%% 8. Execute the LIDT instruction to load the IDTR register with the address and limit
%%     of the protected-mode IDT.

%% 9. Execute the STI instruction to enable maskable hardware interrupts and perform
%%     the necessary hardware operation to enable NMI interrupts.

%% Random failures can occur if other instructions exist between steps 3 and 4 above.
%% Failures will be readily seen in some situations, such as when instructions that refer-
%% ence memory are inserted between steps 3 and 4 while in system management
%% mode.


%
% The ELF file format
%

\newpage
\section{The ELF file format}
\textbf{FIXME}
