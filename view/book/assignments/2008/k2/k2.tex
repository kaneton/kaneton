%%
%% licence       kaneton licence
%%
%% project       kaneton
%%
%% file          /home/buckman/kaneton/view/books/assignments-k2/k2.tex
%%
%% created       matthieu bucchianeri   [tue feb  7 11:49:56 2006]
%% updated       matthieu bucchianeri   [wed mar 14 23:46:36 2007]
%%

%
% k2
%

\chapter{K2: event management}

%
% informations
%

\begin{tabular}{p{7cm}l}
Duration: & 2 weeks \\
Directory name: & kaneton/ \\
In charge: & Julian Pidancet \& Elie Bleton\\
Mailing-list: & kaneton-students@googlegroups.com \\
Languages: & C, assembly \\
Students per group: & 2 (same groups as for K1) \\
\end{tabular}

\section{Abstract}

K2 project consists in developing an important low-level part of the
kernel: the interrupts. Interrupts can be thrown by the microprocessor
itself (exceptions, software interrupts\ldots) or by external devices
(IRQs). You will program another component of the CPU: the interrupt
controller. In addition, K2 will introduce a high-level timer
management, used later for the scheduler.

The concerned managers are:

\begin{enumerate}
  \item
    {\bf The event manager}\\
    Handling exception, IRQ and soft-interrupts
  \item
    {\bf The time manager}\\
    Providing one-shot or periodical triggers
\end{enumerate}

As usual, some machine-independent code is needed (especially for the
timer manager) and an architecture-specific code for Intel IA-32.

\textbf{Important}: Don't forget the FIXMEs in the machine-dependent
part of the \textit{as manager}.

\begin{verbatim}
// FIXME: do not forget to map the IDT in the freshly created
// address space
\end{verbatim}

Remember that you can add code whereever you want. Even if there isn't any FIXME.

%
% event manager
%

\newpage

\section{event manager}

\subsection* {Overview}

The event manager in kaneton is used to hook exceptions, IRQ and
software interrupts and to redirect them to the correct ISR
(\emph{Interrupt Service Routine}).

There are two possibilities when redirecting events:
\begin{itemize}
\item
  Callbacks. Callbacks are functions that can be registered for
  a given event and called when the event occurs.
\item
  Messages. IPC can be thrown on events. \textbf{At this point
    of the project, these kind of hooks must not be implemented}.
\end{itemize}

\subsection* {Assignments}

In K2 you will have to develop the low-level part of the event
manager for Intel IA-32 architecture.

Low-level includes that you will write some code in the
machine-dependent part of the manager. But for the first time, you
will also have to write a significant part of the IA-32 library
(\emph{libia32}).

For example, the functions used to fill the interrupt vector table
(called IDT on IA-32) or to initialize the PIC (8259A) will be placed in
libia32.

When receiving events, your kernel \textbf{must} save and restore
the execution context, for the moment only the processor's
registers need to be saved (address space switch is for K3).

\subsection*{Files}

\subsubsection{\color{filerefcolor} machine-independent}
\begin{itemize}
\item kaneton/core/event/event.c
\item kaneton/core/include/event.h
\end{itemize}

\subsubsection{\color{filerefcolor} machine-dependant : architecture}
\begin{itemize}
\item FIXME: kaneton/include/arch/ibm-pc.ia32-virtual/core/event.h
\end{itemize}

\subsubsection{\color{filerefcolor} machine-dependant : machine}
\begin{itemize}
\item FIXME: libs/libia32/pmode/idt.c
\item FIXME: libs/libia32/include/pmode/idt.h
\item FIXME: libs/libia32/interrupt/*.c
\item FIXME: libs/libia32/include/interrupt/*.h
\end{itemize}

\subsection*{Required implementation}
You \textit{must} implement these functions. We give you their prototypes
and a small description of what they are expected to do.

\function{event\_show}{(i\_event \argument{id})}
	 {
	   This function displays information on an event object.
	 }

\function{event\_dump}{(void)}
	 {
	   This function displays information on all the event objects.
	 }

\function{event\_reserve}{(i\_event \argument{id},
                           e\_event\_type \argument{type},
                           u\_event\_handler \argument{handler})}
	 {
	   This function installs an event handler.

	   \argument{type} can be :
	   \begin{itemize}
	     \item
	       \textbf{EVENT\_FUNCTION}: this means that the event will
	       call a function, which pointer is given in the union
	       \argument{handler}
	     \item
	       \textbf{EVENT\_MESSAGE}: this means that the event will
	       generate an IPC to the task given in the union
	       \argument{handler}. Not implemented.
	   \end{itemize}

	   The union \argument{handler} contains a pointer to a
	   function returning void and getting an event identifier in
	   argument and an optional error code (integer). The union
	   also contains a task identifier in the case of IPC action.

	   See appendix for an example of call.
	 }

\function{event\_release}{(i\_event \argument{id})}
	 {
	   This function releases an event handler.
	 }
\newpage
\function{event\_get}{(i\_event \argument{id},
                       o\_event** \argument{o})}
	 {
	   This function returns in \argument{o} the event object
	   corresponding to \argument{id}.
	 }

\function{event\_init}{(void)}
	 {
	   This function initializes the event manager.
	 }

\function{event\_clean}{(void)}
	 {
	   This function cleans the event manager.
	 }


%
% time manager
%

\newpage

\section{time manager}
\subsection*{Overview}

The timer manager is helpful to create one-shot or repeated
periodical actions. Like in the event manager, the action
performed can be either a callback or a message (\textbf{only
  callbacks must be supported for K2}).

The component required to measure time is called the PIT (8254) on
IA-32.

\subsection*{Assignments}

Your work is to develop the whole timer manager.

Code used to program the PIT must be placed in the libia32.

\textbf{The accuracy of your time manager will be tested. An error
  of more than a ten milliseconds will lead our tests to fail.}

The machine-dependent part of the manager will only consist in
initializing the PIT and then counting ticks. The independent code
of the manager will offer the higher level functionnalities listed
below.

\subsection*{Files}
\subsubsection{\color{filerefcolor} machine-independent}
\begin{itemize}
\item kaneton/core/time/timer.c
\item kaneton/include/core/timer.h
\end{itemize}

\subsubsection{\color{filerefcolor} machine-dependent : machine}
\begin{itemize}
\item FIXME: kaneton/core/arch/ibm-pc.ia32-virtual/timer.c
\item FIXME: kaneton/include/arch/ibm-pc.ia32-virtual/core/timer.h
\end{itemize}

\subsubsection{\color{filerefcolor} machine-dependent : architecture}
\begin{itemize}
\item libs/libia32/time/timer.c
\item libs/libia32/include/time/pit.h
\end{itemize}

\newpage
\subsection*{Interface}

\function{timer\_show}{(i\_timer \argument{id})}
	 {
	   This (\textbf{optional}) function displays information on a
	   timer object.
	 }

\function{timer\_dump}{(void)}
	 {
	   This (\textbf{optional}) function displays information on
	   all the timers.
	 }

\function{timer\_reserve}{(t\_type \argument{type},
                           u\_timer\_handler \argument{handler},
                           t\_uint32 \argument{delay},
                           t\_uint32 \argument{repeat},
                           i\_timer* \argument{id})}
	 {
	   This function reserves a timer which will expire in
	   \argument{delay} microseconds.

	   The arguments \argument{type} and \argument{handler} works
	   the same way as for \emph{event\_reserve}, but the
	   prototype of the callback is different (returning void and
	   taking no argument).

	   The \argument{repeat} argument specifies if the timer
	   must be re-inserted once expired.

	   See appendix for an example of call.
	 }

\function{timer\_release}{(i\_timer \argument{id})}
	 {
	   This function releases a timer object.
	 }

\function{timer\_delay}{(i\_timer \argument{id},
                         t\_uint32 \argument{delay})}
	 {
	   This function updates the delay.
	 }

\function{timer\_repeat}{(i\_timer \argument{id},
                          t\_uint32 \argument{repeat})}
	 {
	   This function updates the repeat property.
	 }

\function{timer\_modify}{(i\_timer \argument{id},
                          t\_uint32 \argument{delay},
                          t\_uint32 \argument{repeat})}
	 {
	   This function combines the effect of the two previous one.
	 }

\function{timer\_get}{(i\_timer \argument{id},
                       o\_timer** \argument{o})}
	 {
	   This function returns in \argument{o} the timer object
	   corresponding to \argument{id}.
	 }

\function{timer\_init}{(void)}
	 {
	   This function initializes the timer manager.
	 }

\function{timer\_clean}{(void)}
	 {
	   This function cleans the timer manager.
	 }

%
% advanced topics
%

\newpage

\section{Bonuses}

kaneton microkernel is first of all a pedagogical project which do not
aims at being optimized. That is why, when nothing is specified, you
always will implement the simplest algorithms.\\
\\
Nevertheless, we will always encourage students who want to write
additional bonuses, as far as they respect the following rules:

\begin{enumerate}
\item Bonuses will be evaluated only if a basic implementation is
  actually working.
\item Bonuses must be accepted \textbf{prior to the implementation}
  by the kaneton team.
\end{enumerate}

Bonuses ideas:
\begin{itemize}
\item More accurate timer using the APIC
\item Managing nested interrupts and priorities
\end{itemize}

%
% appendix
%

\newpage

\section{Appendix}

\textbf{Example of event\_reserve}

\begin{verbatim}
void          ia32_pf_handler(t_id         id,
                              t_uint32     error_code)
{
  t_uint32    addr;

  SCR2(addr);
  printf("#PF @ %p\n", addr);

  while (1)
    ;
}

...

event_reserve(14, EVENT_FUNCTION, EVENT_HANDLER(ia32_pf_handler));
\end{verbatim}

\textbf{Example of timer\_reserve}

\begin{verbatim}
void          sched_switch(void)
{
  // FIXME: chiche just stole this code
}

...

timer_reserve(EVENT_FUNCTION, TIMER_HANDLER(sched_switch),
              sched->quantum, TIMER_REPEAT_ENABLE,
              &sched->machdep.timer);
\end{verbatim}
