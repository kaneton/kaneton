%%
%% licence       kaneton licence
%%
%% project       kaneton
%%
%% file          /home/buckman/kaneton/view/books/assignments-k2/k2.tex
%%
%% created       matthieu bucchianeri   [tue feb  7 11:49:56 2006]
%% updated       matthieu bucchianeri   [wed mar 14 23:46:36 2007]
%%

%
% k2
%

\chapter{K2: event management}

%
% informations
%

\begin{tabular}{p{7cm}l}
Duration: & 2 weeks \\
Directory name: & kaneton/ \\
In charge: & Julian Pidancet \& Elie Bleton\\
Newsgroup: & epita.cours.kaneton\\
Languages: & C, assembly \\
Students per group: & 2 (same groups as for K1) \\
\end{tabular}

\section{Abstract}

K2 project consists in developing an important low-level part of the
kernel: the interrupts. Interrupts can be thrown by the microprocessor
itself (exceptions, software interrupts\ldots) or by external devices
(IRQs). You will program another component of the CPU: the interrupt
controller. In addition, K2 will introduce a high-level timer
management, used later for the scheduler.

The concerned managers are:

\begin{enumerate}
  \item
    {\bf The event manager}\\
    Handling exception, IRQ and soft-interrupts
  \item
    {\bf The time manager}\\
    Providing one-shot or periodical triggers
\end{enumerate}

As usual, some machine-independent code is needed (especially for the
timer manager) and an architecture-specific code for Intel IA-32.

\textbf{Important}: Don't forget the FIXMEs in the machine-dependent
part of the \textit{as manager}.

\begin{verbatim}
// FIXME: do not forget to map the IDT in the freshly created
// address space
\end{verbatim}

Remember that you can add code whereever you want. Even if there isn't any FIXME.

%
% event manager
%

\newpage

\section{event manager}

\subsection* {Overview}

The event manager in kaneton is used to hook exceptions, IRQ and
software interrupts and to redirect them to the correct ISR
(\emph{Interrupt Service Routine}).

There are two possibilities when redirecting events:
\begin{itemize}
\item
  Callbacks. Callbacks are functions that can be registered for
  a given event and called when the event occurs.
\item
  Messages. IPC can be thrown on events. \textbf{At this point
    of the project, these kind of hooks must not be implemented}.
\end{itemize}

\subsection* {Assignments}

In K2 you will have to develop the low-level part of the event
manager for Intel IA-32 architecture.

Low-level includes that you will write some code in the
machine-dependent part of the manager. But for the first time, you
will also have to write a significant part of the IA-32 library
(\emph{architecture:IA32 platform:IBM-PC}).

For example, the functions used to fill the interrupt vector table
(called IDT on IA-32) or to initialize the PIC (8259A) should be placed
in libia32. \textbf{You're free to architecture your code freely for
the ia32\_ functions.}

When receiving events, your kernel \textbf{must} save and restore
the execution context, for the moment only the processor's
registers need to be saved (address space switch is for K3).

\subsection*{Useful documentation}

\begin{itemize}
  \item \url{http://developer.intel.com/design/processor/manuals/253668.pdf}
	    {\textbf{IA-32 Intel Architecture Software Developer's Manual,
	    Volume 3A: System Programming Guide Part 1.}}
	    Chapter 5 : Interrupt and Exception Handling.
  \item \url{http://pdos.csail.mit.edu/6.828/2005/readings/hardware/8259A.pdf}
	    {\textbf{8259A Programmable Interrupt Controller datasheet}}
\end{itemize}

\newpage
\subsection*{Files}
You're not required to implement code in every file that is linked here. However, keep in mind that the architecture dependant part of the event manager will resolve first in the glue. You're free to dispatch the code as you want from there.

\subsubsection{\color{filerefcolor} machine-independent}
\begin{itemize}
\item kaneton/core/event/event.c
\item kaneton/core/include/event.h
\end{itemize}

\subsubsection{\color{filerefcolor} machine-dependant : glue}
\begin{itemize}
\item kaneton/machine/glue/ibm-pc.ia32/educational/include/event.h
\item kaneton/machine/glue/ibm-pc.ia32/educational/event.c
\end{itemize}

\subsubsection{\color{filerefcolor} machine-dependant : architecture}
\begin{itemize}
\item kaneton/machine/architecture/ia32/educational/include/interrupt.h
\item kaneton/machine/architecture/ia32/educational/interrupt.c
\item kaneton/machine/architecture/ia32/generic/include/idt.h
\item kaneton/machine/architecture/ia32/generic/idt.c
\end{itemize}

\subsubsection{\color{filerefcolor} machine-dependant : platform}
\begin{itemize}
\item kaneton/machine/platform/ibm-pc/include/irq.h
\item kaneton/machine/platform/ibm-pc/irq.c
\end{itemize}

\newpage
\subsection*{Required implementation}
You \textit{must} implement these functions. We give you their prototypes
and a small description of what they are expected to do.

\function{event\_reserve}{(i\_event \argument{id},
                           e\_event\_type \argument{type},
                           u\_event\_handler \argument{handler},
                           t\_vaddr \argument{data}))}
	 {
	   This function installs an event handler.

	   \argument{type} can be :
	   \begin{itemize}
	     \item
	       \textbf{EVENT\_FUNCTION}: this means that the event will
	       call a function, which pointer is given in the union
	       \argument{handler}
	     \item
	       \textbf{EVENT\_MESSAGE}: this means that the event will
	       generate an IPC to the task given in the union
	       \argument{handler}. \textup{Not to implement yet}.
	   \end{itemize}

	   \paragraph{The union \argument{handler}} contains a pointer to a
	   function returning void and getting an event identifier in
	   argument and an optional data field (integer virtual address).
           The union also contains a task identifier in the case of IPC action.


           \paragraph{The \argument{data} argument} should be simply forwarded to the
           handler. We don't expect any specific behavior regarding this argument.

           \paragraph{} See appendix for an example of call.
	 }

\function{event\_release}{(i\_event \argument{id})}
	 {
	   This function releases an event handler.
	 }

\function{event\_init}{(void)}
	 {
	   This function initializes the event manager.
	 }

\function{event\_clean}{(void)}
	 {
	   This function cleans the event manager.
	 }


%
% time manager
%

\newpage

\section{time manager}
\subsection*{Overview}

The timer manager is helpful to create one-shot or repeated
periodical actions. Like in the event manager, the action
performed can be either a callback or a message (\textbf{only
  callbacks must be supported for K2}).

The component required to measure time is called the PIT (8254) on
IA-32.

\subsection*{Assignments}

Your work is to develop the whole timer manager.

\textbf{The accuracy of your time manager will be tested. An error
  of more than a ten milliseconds will lead our tests to fail.}

The machine-dependent part of the manager will only consist in
initializing the PIT and then counting ticks. The independent code
of the manager will offer the higher level functionnalities listed
below.

\subsection*{Useful documentation}

\begin{itemize}
  \item \url{http://pdos.csail.mit.edu/6.828/2005/readings/hardware/82C54.pdf}
	    {\textbf{82C54 Programmable Interval Timer Datasheet}}
\end{itemize}

\subsection*{Files}
\subsubsection{\color{filerefcolor} machine-independent}
\begin{itemize}
\item kaneton/core/include/timer.h
\item kaneton/core/time/timer.c
\end{itemize}

\subsubsection{\color{filerefcolor} machine-dependent : glue}
\begin{itemize}
\item kaneton/machine/glue/ibm-pc.ia32/educational/include/timer.h
\item kaneton/machine/glue/ibm-pc.ia32/educational/timer.c
\end{itemize}

\subsubsection{\color{filerefcolor} machine-dependent : platform}
\begin{itemize}
\item kaneton/machine/platform/ibm-pc/include/timer.h
\item kaneton/machine/platform/ibm-pc/timer.c
\end{itemize}

\newpage
\subsection*{Interface}

\function{timer\_reserve}{(t\_type \argument{type},
                           u\_timer\_handler \argument{handler},
			   t\_vaddr \argument{data},
                           t\_uint32 \argument{delay},
                           t\_uint32 \argument{repeat},
                           i\_timer* \argument{id})}
	 {
	   This function reserves a timer which will expire in
	   \argument{delay} microseconds.

	   The arguments \argument{type} and \argument{handler} works
	   the same way as for \emph{event\_reserve}, but the
	   prototype of the callback is different (returning void and
	   taking the current timer \argument{id} and \argument{data}
	   arguments).

	   The \argument{repeat} argument specifies if the timer
	   must be re-inserted once expired.

	   See appendix for an example of call.
	 }

\function{timer\_release}{(i\_timer \argument{id})}
	 {
	   This function releases a timer object.
	 }

\function{timer\_delay}{(i\_timer \argument{id},
                         t\_uint32 \argument{delay})}
	 {
	   This function updates the delay.
	 }

\function{timer\_repeat}{(i\_timer \argument{id},
                          t\_uint32 \argument{repeat})}
	 {
	   This function updates the repeat property.
	 }

\function{timer\_modify}{(i\_timer \argument{id},
                          t\_uint32 \argument{delay},
                          t\_uint32 \argument{repeat})}
	 {
	   This function combines the effect of the two previous one.
	 }

\function{timer\_get}{(i\_timer \argument{id},
                       o\_timer** \argument{o})}
	 {
	   This function returns in \argument{o} the timer object
	   corresponding to \argument{id}.
	 }

\function{timer\_initialize}{(void)}
	 {
	   This function initializes the timer manager.
	 }

\function{timer\_clean}{(void)}
	 {
	   This function cleans the timer manager.
	 }

%
% advanced topics
%

\newpage

\section{Bonuses}

kaneton microkernel is first of all a pedagogical project which do not
aims at being optimized. That is why, when nothing is specified, you
always will implement the simplest algorithms.\\
\\
Nevertheless, we will always encourage students who want to write
additional bonuses, as far as they respect the following rules:

\begin{enumerate}
\item Bonuses will be evaluated only if a basic implementation is
  actually working.
\item Bonuses must be accepted \textbf{prior to the implementation}
  by the kaneton team.
\end{enumerate}

Bonuses ideas:
\begin{itemize}
\item More accurate interrupt controler and timer using the APIC
\item Managing nested interrupts and priorities
\item Any bonus relevant for K1
\end{itemize}

%
% appendix
%

\newpage

\section{Appendix}

\subsection{Errata}

\subsubsection*{Rationale}

The given source doesn't make a clear, typed, distinction between
handlers that accept error codes as a third argument and those who
don't. We provide you a short typedef patch as an indication of
how you could proceed to handle this problem in a less ``hackish''
way.

\subsubsection*{Patches}

The code to fix is located in \textit{kaneton/core/include/event.h}.
There you will find the definition of the generic event handler,
and the union that holds it. \\

We suggest you to enhance this union with the additon of another
handler type, \textit{t\_event\_handler\_errcode}, which designates a
callback for exceptions accepting an errorcode, as per the Intel IA32
architecture specifications

\begin{verbatim}
typedef void			(*t_event_handler)(i_event, t_vaddr);
typedef void			(*t_event_handler_errcode)(i_event, t_vaddr, t_uint32); // NEW
\end{verbatim}

And the assorted union.
\begin{verbatim}
typedef union
{
    t_event_handler		function;
    t_event_handler_errcode	function_errcode; //NEW
    i_task			taskid;
}				u_event_handler;
\end{verbatim}

\subsubsection*{Usage}
The same file provides a macro (\texttt{EVENT\_HANDLER}) that will cast
anything into the right handler type. Using this macro removes the
\textit{need} of the patch we give here as you may use any kind of
handler in practice. You're free to either use our patch without
casting, or using casting without our patch.

\newpage
\subsection{Exemples}

\textbf{Example of event\_reserve}

\begin{verbatim}
void          ia32_pf_handler(i_event      id,
                              t_vaddr      data,
                              t_uint32     error_code)
{
  t_uint32    addr;

  /* rape the stack to get addr */
  printf("#PF @ %p\n", addr);

  while (1)
    ;
}

...

event_reserve(14, EVENT_FUNCTION, EVENT_HANDLER(ia32_pf_handler), 0xDEADBEEF);
\end{verbatim}

\textbf{Example of timer\_reserve}

\begin{verbatim}
void          sched_switch(void)
{
  // FIXME: chiche just stole this code
}

...

timer_reserve(EVENT_FUNCTION, TIMER_HANDLER(sched_switch), 42,
              sched->quantum, TIMER_REPEAT_ENABLE,
              &sched->machdep.timer);
\end{verbatim}
