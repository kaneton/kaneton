%
% ---------- header -----------------------------------------------------------
%
% project       kaneton
%
% license       kaneton
%
% file          /home/mycure/kaneton/view/book/assignments/future/k0.tex
%
% created       julien quintard   [fri nov 28 05:25:37 2008]
% updated       julien quintard   [sat nov 29 16:07:29 2008]
%

%
% ---------- k0 ---------------------------------------------------------------
%

\chapter{k0}
\label{chapter:k0}

\name{k0} is an introduction to low-level programming.

\newpage

%
% ---------- text -------------------------------------------------------------
%

\section{Abstract}

k0 is an introduction to low level programming. During this first step of
the kaneton project, you will deal with:

\begin{enumerate}
  \item
    {\bf Intel x86}

    x86 assembly and architecture
  \item
    {\bf BIOS interrupts}

    How to use BIOS services
  \item
    {\bf ELF binaries}

    Structure and execution of an ELF file
\end{enumerate}

The final goal is to write a complete ELF bootloader, which could be used to
load a kernel.

\clearpage

\section{Before starting}

\begin{itemize}
\item
  You have to follow \textbf{gas} syntax. Use \textbf{gcc} to assemble your
  code and \textbf{ld} to output the flat binary.
  \begin{verbatim}
gcc  -c bootsect.S -o bootsect.o
ld bootsect.o -o bootsect ---oformat binary ---Ttext 0x7c00
  \end{verbatim}
\item
  You will use \textbf{qemu} to test your binary.
  \begin{verbatim}
qemu -fda bootsect
  \end{verbatim}
\item
  Remember that x86 processors start in 16-bit mode, so you must find a
  directive to tell \textbf{gcc} to assemble 16-bit code. When you later
  switch to protected mode, find another directive to assemble 32-bit code.
\item
  \emph{No} register shall be modified unless explicitly requested.
\item
  Your bootsector must end with signature 0xaa55 to be valid. This means you
  have to insert bytes after your code until byte 510, and then dump the
  signature.
  \begin{verbatim}
signature:
        .org 510, 0
        .short 0xaa55
  \end{verbatim}
\item
  Screen output will be strictly tested, so be careful: it must not differ.
\item
  Your test code must be removed from final source but the signature must be
  present. Your code must not include a label \textbf{\_start} or labels
  starting with two underscores.
\end{itemize}

Good luck and have fun!

%
% String display
%

\newpage

\section{Exercises}

\subsection{String display}

\subsubsection*{Overview}
In this first exercise you will learn how to use Video BIOS Services to
print strings on the screen.

\subsubsection*{Assignments}
The work is divided up into several steps. First, try to print a char and
to move the cursor on the screen and then, use those functions to display
a string.

\subsubsection*{File}
\begin{itemize}
  \item \location{k0-login\_x/ex1/ex1.S}
\end{itemize}

\subsubsection*{Interface}
\command{print\_char}
{
  Print the character which ASCII code is \argument{\%al} at current cursor
  position.
}

\command{cursor\_set}
{
  Set cursor position at row \argument{\%dh} and column \argument{\%dl}.
}

\command{print\_string}
{
  Print the string pointed by \argument{\%si} at row \argument{\%dh} and
  column \argument{\%dl}.
}

%
% Registers dump
%

\newpage

\subsection{Registers dump}

\subsubsection*{Overview}
This exercice requires more assembly skill. Its only point is to make you
practice.

\subsubsection*{Assignments}
You will code three famous libc-like functions and use them to program
a function which will dump the values stored in some registers.

\subsubsection*{File}
\begin{itemize}
  \item \location{k0-login\_x/ex2/ex2.S}
\end{itemize}

\subsubsection*{Interface}
\command{malloc}
{
  This function allocates memory in a very simple way. Declare the heap and
  declare a break value at its beginning.
  Your malloc must allocate \argument{\%ax} bytes and return the address
  in \argument{\%di}.
}

\command{itoa\_hex}
{
  Convert the integer in \argument{\%ax} into string using hexadecimal
  representation and store in \argument{\%si} the address of the string.
  The format must follow the regular expression 0x[0-9a-f]\{4\}.
  42 must for instance be printed as 0x002a. You could use this function
  to check your malloc.
}

\command{dump\_registers}
{
  Program a function which dumps the registers. You will start writing
  at current cursor position, i.e. you \emph{must not} modify it. You have to
  follow this output:
}
\begin{verbatim}
        ax = 0x1234
        bx = 0x0000
        cx = 0xabcd
        dx = 0x00ff
        si = 0x1000
        di = 0x0ff8
\end{verbatim}

\command{}
{
  {\em Warning:}

  Start output at current cursor position. To simulate a line return, just move
  the cursor to the first column of the line under. Even though it could be
  ugly, don't move the cursor before printing and don't erase the characters
  printed by \textbf{qemu}!
}

%
% Keyboard inputs
%

\newpage

\subsection{Keyboard inputs}

\subsubsection*{Overview}
Now that you are more familiar with BIOS services and assembly programming,
you're going to write a basic keyboard driver.

\subsubsection*{Assignments}
First, you will program a function which gets keycodes from the keyboard
buffer, and then, use this function to print entered text on the screen.

\subsubsection*{File}
\begin{itemize}
  \item \location{k0-login\_x/ex3/ex3.S}
\end{itemize}

\subsubsection*{Interface}
\command{get\_key}
{
  Get an ASCII code from the keyboard buffer and store it in \argument{\%al}.
}

\command{getln}
{
  This function prints entered strings. Pressing ENTER will result in a
  newline.
  The modifiers like SHIFT, ALT, CTRL or caps lock won't be tested. Advanced
  typing using the arrows, BACKSPACE and DELETE is not required either.
}

%
% Floppy drive
%

\newpage

\subsection{Floppy drive}

\subsubsection*{Overview}
During this exercise you are going to work with floppy drives using BIOS
interrupts. The final goal is to load the second sector from the floppy drive
in order to check whether it's a bootsector or not. In this exercise, we load the
second sector, because the first sector is already loaded. This technique is used
for example by GRUB to perform \emph{chainloading}.

\subsubsection*{Assignments}
The drive must be initialized before any reading. Then, get the second sector of
the floppy, and check the signature. A valid bootsector ends with 0xaa55.

Be careful, sectors are actually numbered starting from 1, and not 0.

\subsubsection*{File}
\begin{itemize}
  \item \location{k0-login\_x/ex4/ex4.S}
\end{itemize}

\subsubsection*{Interface}
\command{floppy\_init}
{
  Initialize floppy drive.
}

\command{is\_bootsector}
{
  Load the second sector of the floppy and check whether it is a valid
  bootsector. It must print the following output at current cursor
  position for the following cases - respectively valid, and invalid $0x0042$
  signatures:
}
\begin{verbatim}
        magic found: 0xaa55
\end{verbatim}
\command{}
{
  or
}
\begin{verbatim}
        wrong magic: 0x0042
\end{verbatim}

%
% Operating mode switching
%

\newpage

\subsection{Operating mode switching}

\subsubsection*{Overview}
Since kernels generally use 32-bit mode, it's time to know how to switch from
\emph{real} 16-bit mode to \emph{protected} 32-bit mode.

\subsubsection*{Assignments}
You will first read \emph{Intel IA-32 mode switching procedure} and code a
function to switch to that mode. Then, you will have to display a string in
32-bit mode.

{\em Warning:}

Don't forget that the code executed after switching to protected mode must be
32-byte assembled code. Moreover, BIOS interrupts cannot be used in protected
mode, see \emph{VGA text Framebuffer} appendix to know how to do.

\subsubsection*{File}
\begin{itemize}
  \item \location{k0-login\_x/ex5/ex5.S}
\end{itemize}

\subsubsection*{Interface}
\command{pmode\_switch}
{
  Switch from real mode to protected mode.
}

\command{print\_string32}
{
  Print the string \argument{\%esi} on the screen at row \argument{\%ecx}
  and column \argument{\%edx}. We don't care about colors, you can change them
  or not.
}

%
% ELF Loader
%

\newpage

\subsection{ELF Loader}

\subsubsection*{Overview}
Any bootloader must be able to load a kernel binary and to execute it.
The \emph{Executable and Linking Format} is a binary executable format used on
many UNIX platform. The goal of this part is to give an introduction to the
ELF structure so that you will learn how to load and execute such a file.

\subsubsection*{Assignments}
You will write a complete bootloader which loads and executes an ELF file
- located right after the bootsector - and then relocate it in memory
before jumping on it.

An ELF binary is provided to be loaded with your bootsector. To build
a disk image with your bootsector on the first sector, and the kernel on the
next ones, you can use the following command:

\begin{verbatim}
42sh$ cat bootsector kernel.elf /dev/zero | dd bs=512 count=2880 of=disk.img
\end{verbatim}

To load and execute an ELF file, you will have to parse the ELF header at the
beginning of the file. Each ELF file is divided into \emph{segments} which are
located into different offsets, and must be separately relocated at different
memory locations. The segment list of the executable file is described by the
\emph{Program Headers} table - \emph{Phdr} - in the ELF header.

The structure of the ELF header is described in \emph{elf.h}, located in many
UNIX systems in \verb+/usr/include/+.

Here is a simplified view of the elf.h file :

\begin{verbatim}
typedef uint16_t Elf32_Half;
typedef uint32_t Elf32_Word;
typedef uint32_t Elf32_Addr;
typedef uint32_t Elf32_Off;

/* The ELF file header.  This appears at the start of every ELF file.  */

#define EI_NIDENT (16)

typedef struct                      /* Offset   Description */
{
  unsigned char e_ident[EI_NIDENT]; /* +0       Magic number and other info */
  Elf32_Half    e_type;             /* +16      Object file type */
  Elf32_Half    e_machine;          /* +18      Architecture */
  Elf32_Word    e_version;          /* +20      Object file version */
  Elf32_Addr    e_entry;            /* +24      Entry point virtual address */
  Elf32_Off     e_phoff;            /* +28      Program header table file offset */
  Elf32_Off     e_shoff;            /* +32      Section header table file offset */
  Elf32_Word    e_flags;            /* +36      Processor-specific flags */
  Elf32_Half    e_ehsize;           /* +40      ELF header size in bytes */
  Elf32_Half    e_phentsize;        /* +42      Program header table entry size */
  Elf32_Half    e_phnum;            /* +44      Program header table entry count */
  Elf32_Half    e_shentsize;        /* +46      Section header table entry size */
  Elf32_Half    e_shnum;            /* +48      Section header table entry count */
  Elf32_Half    e_shstrndx;         /* +50      Section header string table index */
} Elf32_Ehdr;                       /* sizeof(Elf32_Ehdr) = 52 */
\end{verbatim}
\newpage
\begin{verbatim}
/* Conglomeration of the identification bytes, for easy testing as a word.  */
#define	ELFMAG		"\177ELF"
#define	SELFMAG		4

typedef struct                      /* Offset   Description */
{
  Elf32_Word    p_type;             /* +0       Segment type */
  Elf32_Off     p_offset;           /* +4       Segment file offset */
  Elf32_Addr    p_vaddr;            /* +8       Segment virtual address */
  Elf32_Addr    p_paddr;            /* +12      Segment physical address */
  Elf32_Word    p_filesz;           /* +16      Segment size in file */
  Elf32_Word    p_memsz;            /* +20      Segment size in memory */
  Elf32_Word    p_flags;            /* +24      Segment flags */
  Elf32_Word    p_align;            /* +28      Segment alignment */
} Elf32_Phdr;                       /* sizeof(Elf32_Phdr) = 32 */
\end{verbatim}

\subsubsection*{File}
\begin{itemize}
  \item \location{k0-login\_x/ex6/ex6.S}
\end{itemize}

\subsubsection*{Interface}

\command{kernel\_preload}
{
  This function has to load into memory the number of sectors given into
  \argument{\%al}, from the drive given into \argument{\%dl}, starting from
  the second sector.

  The function must switch to protected mode, and return into \argument{\%eax}
  the address of the memory area where sectors are loaded.
}

\command{elf\_load}
{
  Load and execute the elf file located at address \argument{\%esi}.
}
