%%
%% licence       kaneton licence
%%
%% project       kaneton
%%
%% file          /home/buckman/crypt/kaneton/view/exams/kernels/2007-t5/2007-t5.tex
%%
%% created       julien quintard   [fri dec  2 22:25:51 2005]
%% updated       matthieu bucchianeri   [mon feb 12 23:37:26 2007]
%%

%
% template
%

\input{../../../templates/exam.tex}

%
% header
%

\lhead{\scriptsize{2007}}

%
% title
%

\title{Examen de noyaux et systèmes d'exploitation (kaneton)}

%
% authors
%

\author{\small{Matthieu Bucchianeri, Renaud Voltz}}

%
% document
%

\begin{document}

%
% title
%

\maketitle

%
% --------- information -------------------------------------------------------
%

\begin{center}

\textbf{Ordinateurs, PDA et téléphones non autorisés}

\textbf{Documents autorisés}

\textbf{Durée 2 heures}

\scriptsize{Une copie mal présentée et bourrée de fautes d'orthographe
            sera pénalisée.}

\scriptsize{Le barème est donné à titre indicatif, en cas de modifications,
            aucune contestation ne sera possible}

\end{center}

%
% --------- text --------------------------------------------------------------
%

\vspace{3cm}

\section{Exercice 1 : Généralités -- \emph{8 points}}

Ces petits exercices vous offrent la possibilité de nous montrer votre
bonne connaissance et compréhension du cours.

\subsection{Assembleur (3 points)}

Le code assembleur suivant est executé sur un microprocesseur Intel
80386 en mode réel.

Indiquez, pour chaque instruction, ce qu'elle fait.

\begin{verbatim}
MOV AX, 0x1200
MOV ES, AX
MOV BX, 0x4000
MOV AL, ES:[BX]
TEST AL, AL
JZ end
ADD AL, 42
MOV AH, 0xE
INT 0x10
\end{verbatim}

\subsection{ICU en cascade (3 points)}

Les microprocesseurs de la famille IA-32 ne disposent que d'un fil
d'IRQ nommé \textbf{INTA}.

Afin de supporter plusieurs sources d'interruptions externes, on
utilise un controlleur d'interruption appelé PIC (\emph{Programmable
Interrupt Controller}, chip 8259). Ce PIC dispose de 8 entrées
(\textbf{IR$_{0}$} - \textbf{IR$_{7}$}) et d'une unique sortie
\textbf{INT}. Il dispose aussi d'un fil \textbf{INTACK} qui sert à
l'acquittement par le microprocesseur, déclencheant la mise sur le bus
de données du numéro de l'IRQ reçue.

On considerera que cette valeur mise sur le bus peut être
automatiquement additionnée à une autre par le PIC (ne vous souciez
donc pas de cette dernière).

On souhaite utiliser 2 PIC en cascade pour disposer de plus de 8
lignes d'IRQ. Proposez un montage répondant à ce problème.

\subsection{Binary buddy system (2 points)}

Un considère un allocateur de mémoire grain-fin de type \emph{malloc}
basé sur un buddy system binaire.

Le buddy system dispose initialement d'une page de 4 ko.

Le programme effectue successivement des appels à \emph{malloc} avec
les tailles suivantes (en kilo-octet) : 126, 510, 1200, 10, 1000, 498,
2000. \textbf{Attention} : par successivement, nous entendons que vous
ne repartirez pas du début (un bloc 4 ko) entre chaque allocation.

Donnez l'état de l'allocateur, c'est-à-dire l'ensemble des blocs
libres et occupés après chacune de ces allocations. Que se passe-t-il
lors de la dernière allocation ? Que préconisez-vous ?

\section{Exercice 2 : Gestion de mémoire -- \emph{12 points}}

Les deux parties suivantes sont indépendantes.

Vous trouverez en annexe la description de l'interface kaneton et des
objets qu'il vous sera nécessaire d'utiliser.

Lorsqu'il vous est demandé d'écrire du code, vous pourrez négliger la
gestion des erreurs \textbf{uniquement dans les cas où elle n'apporte
rien au problème}. Comprenez par là qu'on considère (par exemple) qu'un
\emph{segment\_get} sur un identifiant de segment valide ne renverra
pas d'erreur. En revanche, vous \textbf{devez gerer les erreurs qui
peuvent conduire à des segfault}.

\subsection{Implémentation de \emph{region} sur MIPS}

Dans cet exercice, vous allez implementer le manager \emph{region} de
kaneton pour un microprocesseur de la famille MIPS (vu en cours).

Contrairement aux microprocesseurs IA-32 qui implementent un
algorithme de remplacement automatique des entrées TLB basé sur un
arbre (la page-directory et les page-tables), le microprocesseur MIPS
R3000 n'offre aucune aide au programmeur en cas de TLB-miss.

Lorsque la MMU demande une traduction d'adresse et qu'aucune entrée
dans les TLB n'est satisfaisante, une exception est générée. C'est
alors au noyau de remplir les TLB comme il convient, ou de déclarer
une erreur fatale.

Notez aussi que la taille des pages sur le MIPS R3000 est fixée à 4
kilo-octets.

\subsubsection{Modification du manager \emph{as} (1 points)}

Les TLB contiennent des entrées provenant de tous les espaces
d'adressage confondus. Ainsi, pour indiquer à quel espace d'adressage
une entrée TLB appartient, un champ identifiant de 6 bits est présent
dans chacune des entrées.

Allez-vous devoir faire des modifications dans la partie dépendante de
\emph{as} ? Si oui, lesquelles ?

En quoi le fait d'encoder le champ identifiant sur 6 bits peut-il
poser problème ?

\textbf{Pour la suite de l'exercice, vous ne devez pas considerer le
        problème identifié ci-dessus.}

\subsubsection{Implementation du gestionnaire de TLB-miss (3 points)}

Pour cette question, nous vous fournissons des fonctions de la
bibliothèque MIPS. Ces fonctions (de bas-niveau) sont décrites en
annexe.

Ecrivez le code du gestionnaire de TLB-miss. Vous pouvez bien entendu
vous appuyer sur les fonctions données ci-dessus et sur toutes les
autres fonctions de l'interface kaneton.

Le prototype du gestionnaire de TLB-miss est le suivant :

\function{tlb\_miss}{(i\_as asid)}
{
\begin{itemize}
\item
  \emph{asid} est l'identifiant de l'espace d'adressage sur lequel
  s'est produit l'erreur
\end{itemize}
}

\subsubsection{Implementation de \emph{mipsr3000\_region\_release} (3 points)}

Ecrivez le code dépendant de la fonction \emph{region\_release}. Vous
pouvez utiliser les fonctions de l'interface kaneton et celles de la
bibliothèque MIPS.

\subsubsection{Amélioration des performances (bonus)}

Indiquez pourquoi votre code n'est pas suffisament
performant. Proposez une (ou plusieurs) solution(s) pour gagner en
performances.

\subsection{Implémentation du copy-on-write}

Le copy-on-write (vu en cours) est une astuce d'optimisation trés
utilisée dans les noyaux modernes.

Le principe du copy-on-write est le suivant : lorsqu'on clone un
espace d'adressage (par exemple dans le cas d'un appel système
\emph{fork}), les zones réservées en mémoire physique ne sont pas
dupliquées. Seules les correspondances (mappings) entre la mémoire
virtuelle et la mémoire physique sont recopiées.

Par la suite, c'est uniquement lors d'une écriture dans une zone
mémoire que le segment de mémoire physique est recopié (afin qu'il y
en ait un exemplaire par espace d'adressage).

Dans cet exercice, nous simplifierons le problème en considérant
qu'\textbf{un espace d'adressage ne pourra être dupliqué qu'une unique
fois}.

\subsubsection{Modification des objets (1,5 points)}

Indiquez les modifications à apporter aux objets (\emph{o\_as},
\emph{o\_segment} et \emph{o\_region}).

Vous indiquerez aussi les modifications à faire dans les opérations
existantes pour prendre en compte ou remplir les champs ajoutés.

\subsubsection{Implémentation du gestionnaire de page-fault (3,5 points)}

Ecrivez le code du gestionnaire de page-fault. Vous pouvez employer
toutes les fonctions de l'interface kaneton. \textbf{Attention},
contrairement à l'exercice précédent, votre code doit être indépendant
de l'architecture. Cependant, dans le cas ou votre code nécessiterait
une partie dépendante de l'architecture (pour mettre-à-jour des TLB
par exemple), vous preciserez \textbf{sans l'implémenter} le
comportement de ce code.

Le prototype du gestionnaire de page-fault est le suivant :

\function{page\_fault}{(i\_as asid, t\_vaddr address, t\_bool is\_write\_fault)}
{
\begin{itemize}
\item
  \emph{asid} est l'identifiant de l'espace d'adressage sur lequel
  s'est produit l'erreur
\item
  \emph{address} est l'adresse virtuelle ayant provoqué l'erreur
\item
  \emph{is\_write\_fault} indique si l'erreur est due à une tentative
  d'écriture à une adresse marquée en lecture seule.
\end{itemize}
}

\subsubsection{Implémentation sans limitations (bonus)}

En quoi le cas ou un espace d'adressage peut être dupliqué plusieurs
fois est-il plus complexe à gérer ?

Proposez les modifications pour gérer le copy-on-write quelque soit le
nombre de clonage de l'espace d'adressage effectué.

\newpage

\subsection*{Annexes}

\subsection{kaneton as manager}

\subsubsection{as object}

\begin{verbatim}
typedef struct
{
  i_as         asid;

  i_task       tskid;

  i_set        segments;
  i_set        regions;

  machdep_data(o_as);
}              o_as;
\end{verbatim}

\subsubsection{as interface}

\function{as\_vaddr}{(i\_as \argument{id},
                      t\_paddr \argument{physical},
                      t\_vaddr \argument{virtual})}
	 {
	   This function translates a physical address into its virtual
	   address.
	 }

\function{as\_paddr}{(i\_as \argument{id},
                      t\_vaddr \argument{virtual},
                      t\_paddr \argument{physical})}
	 {
	   This function translates a virtual address into its physical
	   address.
	 }

\function{as\_clone}{(i\_task \argument{task},
                      i\_as \argument{old},
                      i\_as* \argument{new})}
	 {
	   This function clones an address space taking care of cloning
	   everything necessary: segments, regions etc\ldots
	 }

\function{as\_reserve}{(i\_task \argument{task},
                        i\_as* \argument{id})}
	 {
	   This function reserves an address space object for the
	   task \argument{task} object.

	   The reserved address space object's identifier is returned
	   in \argument{id}.
	 }

\function{as\_release}{(i\_as \argument{id})}
	 {
	   This function just releases the address space \argument{id}.
	 }

\function{as\_get}{(i\_as \argument{id},
                    o\_as** \argument{o})}
	 {
	   This function should only be used by the as manager, the segment
	   manager and the region manager.

	   This function just returns the address space object
	   corresponding to the address space identifier \argument{id}.
	 }

\subsection{kaneton segment manager}

\subsubsection{segment object}

\begin{verbatim}
typedef struct
{
  i_segment    segid;

  i_as         asid;

  t_paddr      address;
  t_psize      size;

  t_perms      perms;

  machdep_data(o_segment);
}              o_segment;
\end{verbatim}

\subsubsection{segment interface}

\function{segment\_clone}{(i\_as \argument{as},
                           i\_segment \argument{old},
                           i\_segment* \argument{new})}
	 {
	   This function clones a segment which will then belongs to
	   the address space object \argument{as}.

	   Cloning a segment means reserving a new segment with the
	   exact same properties. Then the content is also copied.
	 }

\function{segment\_read}{(i\_segment \argument{id},
                          t\_paddr \argument{offset},
                          void* \argument{buffer},
                          t\_psize \argument{size})}
	 {
	   This function reads \argument{size} bytes at offset
	   \argument{offset} from the segment \argument{id}.
	 }

\function{segment\_write}{(i\_segment \argument{id},
                           t\_paddr \argument{offset},
                           const void* \argument{buffer},
                           t\_psize \argument{size})}
	 {
	   This function write the data of \argument{buffer} into the
	   segment \argument{id}.
	 }

\function{segment\_copy}{(i\_segment \argument{dst},
                          t\_paddr \argument{offd},
                          i\_segment \argument{src},
                          t\_paddr \argument{offs},
                          t\_psize \argument{size})}
	 {
	   This function copies data from the segment \argument{src} to
	   the segment \argument{dst}.
	 }

\function{segment\_reserve}{(i\_as \argument{as},
                             t\_psize \argument{size},
                             t\_perms \argument{perms},
                             i\_segment* \argument{id})}
	 {
	   This function reserves a segment with specified properties.
	 }

\function{segment\_release}{(i\_segment \argument{id})}
	 {
	   This function releases the segment \argument{id}.
	 }

\function{segment\_perms}{(i\_segment \argument{id},
                           t\_perms \argument{perms})}
	 {
	   This function changes the permissions of the segment \argument{id}.
	 }

\subsection{kaneton region manager}

\subsubsection{region object}

\begin{verbatim}
typedef struct
{
  i_region     regid;

  i_segment    segid;

  t_vaddr      address;
  t_paddr      offset;
  t_vsize      size;
  t_opts       opts;

  machdep_data(o_region);
}              o_region;
\end{verbatim}

\subsubsection{region interface}

\function{region\_reserve}{(i\_as \argument{as},
                            i\_segment \argument{segment},
                            t\_paddr \argument{offset},
                            t\_opts \argument{opts},
                            t\_vaddr \argument{address},
                            t\_vsize \argument{size},
                            i\_region* \argument{id})}
	 {
	   This function reserves a region with specified properties.
	 }

\function{region\_release}{(i\_as \argument{as},
                            i\_region \argument{id})}
	 {
	   This function releases the region \argument{id} that belongs
	   to the address space object \argument{as}.
	 }

\subsection{kaneton libmips}

\subsubsection{Interface}

\functionn{t\_vaddr}{mips\_bad\_vaddr}{()}
{
  Get the virtual address that caused the fault.
}

\functionn{}{mips\_set\_tlb}{()}
{

}

\functionn{}{mips\_get\_tlb}{()}
{

}

\functionn{}{mips\_del\_tlb}{(t\_uint32 entry)}
{
  Mark the \argument{entry} of the TLB as invalid (remove it).
}

\functionn{t_uint32}{mips\_randon\_entry}{()}
{
  Get the index of a random entry in the TLB that can be replaced.
}

\end{document}
