%%
%% licence       kaneton licence
%%
%% project       kaneton
%%
%% file          /home/buckman/kaneton/view/books/assignments-k1/k1.tex
%%
%% created       matthieu bucchianeri   [tue feb  7 11:49:56 2006]
%% updated       matthieu bucchianeri   [wed feb  7 23:14:25 2007]
%%

%
% k2
%

\chapter{k1: memory management}

%
% informations
%

\begin{tabular}{p{7cm}l}
Duration: & 2 weeks \\
File name: & {\em login\_x}-k1.tar.bz2 \\
In charge: & Matthieu Bucchianeri \& Renaud Voltz\\
Mailing-list: & kaneton-students@googlegroups.com \\
Languages: & C \\
Students per group: & 2 \\
\end{tabular}

\section{Abstract}

k1 project consists in developing a large part of the kaneton memory management. Using all the concepts learned in class, you will have to implement:

\begin{enumerate}
  \item
    {\bf The segment manager}\\
    Manage physical memory
  \item
    {\bf The region manager}\\
    Manage virtual memory
  \item
    {\bf The map manager}\\
    Assume the mapping between physical and virtual memory.\\
\end{enumerate}

This part of the kaneton project introduces important notions around the
kaneton design.

For the first time, you will have to write kaneton managers. This point is
very important since one of the fundamental concepts of kaneton microkernel
is to be subdivided into managers.

The kaneton microkernel was also designed to be ported on many
architectures. It uses specific macro functions to import and call
architecture-dependent routines. You will also have
to understand this concept and to study how it is implemented in the
kaneton microkernel. This feature is heavily used in the region manager since
most of its job is actually done in the architecture-dependent code.

%
% Segment manager
%

\newpage

\section{Segment manager}

\begin{itemize}
  \item {\bf Overview}\\
    The segment manager provides a complete interface to manipulate physical
    memory areas called {\em segments}. It is called everytime the kernel
    needs to allocate, modify or free a physical memory area.\\

    In other words, the segment manager interface provides:
    \begin{itemize}
    \item a physical memory allocator
    \item physical memory read/write operations
    \item a way to set physical memory areas attributes (size, permissions, \ldots)\\
      \end{itemize}

  \item {\bf Assignments}\\
    In k1, you will write the entire segment manager. That includes the
    machine-independent part of the manager, as well as the machine-dependent
    code.\\

    The architecture-dependent code must always be invoked using the kaneton
    internal portability facilities.\\
    \\
    Your segment manager must be compliant to the kaneton segment manager
    interface as described below.\\

  \item {\bf Interface}\\
    \function{segment\_reserve}{(i\_as \argument{as},
      t\_psize \argument{size},
      t\_perms \argument{perms},
      i\_segment* \argument{id})}
             {
               This function reserves in the address space
             \argument{as} a segment with specified properties. This
             function calls the physical memory allocator, implemented
             in function \emph{segment\_space}. The identifier
             of the reserved segment is returned in \argument{id}.
	     }
     \function{segment\_space}{(o\_as* \argument{as},
       t\_psize \argument{size},
       t\_paddr* \argument{address})}
     {
       This function allocates for the address space \argument{as} a
       contiguous space of size \argument{size} in physical
       memory. The address of the beginning of the allocated block is
       returned in \argument{address}.
     }

    \function{segment\_release}{(i\_segment \argument{id})}
             {
               This function releases the segment \argument{id}.
             }

    \function{segment\_inject}{(i\_as \argument{as},
      o\_segment* \argument{o})}
	     {
	       This function injects a pre-allocated segment in the
	       address space \argument{as}. It means that no physical
	       memory is allocated, the \argument{o} structure is
	       trusted to be correctly filled.
	     }

     \function{segment\_get}{(i\_segment \argument{segid},
       o\_segment** \argument{o})}
       {
	 This function retrieves a segment object \argument{o} given its identifier
	 \argument{segid}.
       }

     \function{segment\_flush}{(i\_as \argument{as})}
              {
		This function removes every segment that belongs to
		the address space \argument{as} and releases the
		physical memory associated.
              }

    \function{segment\_clone}{(i\_as \argument{as},
      i\_segment \argument{old},
      i\_segment* \argument{new})}
             {
               This function clones a segment which will then belong to
               the address space object \argument{as}.

               Cloning a segment means reserving a new segment with the
               exact same properties. Then the content is also copied.
             }

    \function{segment\_read}{(i\_segment \argument{id},
      t\_paddr \argument{offset},
      void* \argument{buffer},
      t\_psize \argument{size})}
             {
               This function reads \argument{size} bytes at offset
               \argument{offset} from the segment \argument{id}.
             }

     \function{segment\_write}{(i\_segment \argument{id},
       t\_paddr \argument{offset},
       const void* \argument{buffer},
       t\_psize \argument{size})}
              {
		This function write the data of \argument{buffer} into the
		segment \argument{id}.
              }

    \function{segment\_copy}{(i\_segment \argument{dst},
      t\_paddr \argument{offd},
      i\_segment \argument{src},
      t\_paddr \argument{offs},
      t\_psize \argument{size})}
             {
               This function copies data from the segment \argument{src} to
               the segment \argument{dst}.
             }

    \function{segment\_perms}{(i\_segment \argument{id},
      t\_perms \argument{perms})}
             {
               This function changes the permissions of the segment \argument{id}.
             }

  \item {\bf {Files}}\\

    \begin{tabular}{| l | l |}
      \hline
      machine-independent & {\em kaneton/core/segment/segment.c}\\
      machine-dependent & {\em kaneton/core/arch/ibm-pc.ia32-virtual/segment.c}\\
      libarch & {\em libs/libia32/pmode/*.c}\\\hline
    \end{tabular}
\end{itemize}


%
% region manager
%

\newpage

\section{Region manager}
\begin{itemize}
  \item {\bf Overview}\\
    The region manager provides a complete interface to manipulate virtual memory
    areas called {\em regions}. It is used to reserve virtual memory and to map it
    on segments.\\
    \\
    The region manager thus provides:

    \begin{itemize}
      \item a virtual memory allocator
      \item virtual memory mapping routines\\
    \end{itemize}

    {\em Warning:}\\
    the region manager always deals with existing valid segments. In
    other terms, it never reserves, releases or modifies a segment to fit the mapping
    needs. Such an initiative is handled by the map manager.\\

  \item {\bf Assignments}\\
    In k1, you will write the machine-dependent code of the kaneton region manager.
    This code implements an interface between the machine-independent manager, and
    the specific needs of the IA-32 architecture.\\
    \\
    You are also asked to respect the given interface and to use the provided
    libarch low-level functions.\\
    \\
    The following functions are given (except \emph{region\_space}, very similar to \emph{segment\_space}), but you must write the code in
    the architecture-dependent side of the manager.

  \item {\bf Interface}\\
\function{region\_reserve}{(i\_as \argument{as},
                            i\_segment \argument{segment},
                            t\_paddr \argument{offset},
                            t\_opts \argument{opts},
                            t\_vaddr \argument{address},
                            t\_vsize \argument{size},
                            i\_region* \argument{id})}
	 {
	   This function reserves a region with specified properties
	   into the address space \argument{as}. This region maps the
	   segment given by \argument{segment}. The identifier of the reserved region is returned in \argument{id}. Values for \argument{opts} can be:

	   \begin{itemize}
	     \item {REGION\_OPT\_NONE}: no options
	     \item {REGION\_OPT\_FORCE}: forces the region to be reserved at address \argument{address}. Otherwise, uses \emph{region\_space} to allocate the region.
	     \item {REGION\_OPT\_USER}: set the region addressable in both user and kernel mode
	     \item {REGION\_OPT\_PRIVILEGED}: set the region to be addressable in kernel mode only
	     \item {REGION\_OPT\_LOCAL}: set the region to be local to the address space
	     \item {REGION\_OPT\_GLOBAL}: set the region to be global over all address spaces
	   \end{itemize}
	   The \argument{offset} indicates where to start mapping
	   physical address. For example, reserving two regions on a
	   single segment is allowed.
	   \begin{center}
	     \includegraphics[width=0.4\linewidth]{figures/offset}
	   \end{center}
	 }

\function{region\_release}{(i\_as \argument{as},
                            i\_region \argument{id})}
	 {
	   This function releases the region \argument{id} that
	   belongs to the address space object \argument{as}. Be
	   careful, releasing a region does not mean releasing the
	   associated segment.
	 }

\function{region\_inject}{(i\_as \argument{as},
                           o\_region* \argument{o})}
	 {
	   This function injects a pre-allocated region in the set of
	   regions of the address space \argument{as}.
	 }

\function{region\_flush}{(i\_as \argument{as})}
	 {
	   This function removes every region that belongs to the
	   address space \argument{as}.
	 }

	 \function{region\_get}{(i\_as \argument{asid},
	   i\_region \argument{regid},
	   o\_region** \argument{o})}
		  {
		    This function retrieves the region object
		    \argument{o} associated to the identifier
		    \argument{regid} in the address space
		    \argument{asid}.
		  }

  \item {\bf Files}\\

    \begin{tabular}{| l | l |}
      \hline
      machine-independent & {\em kaneton/core/region/region.c}\\
      machine-dependent & {\em kaneton/core/arch/ibm-pc.ia32-virtual/region.c}\\
      libarch & {\em libs/libia32/paging/*.c}\\\hline
    \end{tabular}

\end{itemize}

%
% Map manager
%

\newpage

\section{Map manager}

\begin{itemize}
  \item {\bf Overview}\\
    The map manager implements a high-level interface to manipulate memory mappings.
    It directly depends on both segment and region managers.\\
    \\
    For example, reserving a map consists in the two following steps:
    \begin{itemize}
      \item ask the segment manager to reserve physical memory.
      \item ask the region manager to map this memory on virtual addresses.\\
    \end{itemize}

    {\em Note:}\\
    As the map manager's role is to delegate its tasks to lower managers, it does
    not require to implement a machine-dependent interface.\\

  \item {\bf Assignments}\\
    In k1, you will write the whole map manager. This manager will use the segment
    and region manager you implemented sooner.\\
    \\
    As usual, your map manager must conform to the kaneton map manager interface as
    described as follow.\\
    \\
    In addition, you will have to provide a wrapper to classical
    \emph{mmap} and \emph{munmap} functions.

  \item {\bf Interface}\\

\function{map\_reserve}{(i\_as \argument{as},
                         t\_opts \argument{opts},
                         t\_vsize \argument{size},
                         t\_perms \argument{perms},
                         t\_vaddr* \argument{address})}
	 {
	   This function reserves some physical memory and map it into
	   the address space \argument{as}.  The segment will have the
	   size \argument{size} with the permissions \argument{perms}
	   while the region will map the whole segment.

	   The virtual address is returned in \argument{address}. The
	   values for \argument{opts} can be:
	   \begin{itemize}
	     \item {MAP\_OPT\_NONE}: no option is specified
	     \item {MAP\_OPT\_FORCE}: forces the memory to be allocated at virtual address \argument{address}
	     \item {MAP\_OPT\_USER}: set permissions for both user and kernel
	     \item {MAP\_OPT\_PRIVILEGED}: set permissions for kernel only
	   \end{itemize}
	 }

\function{map\_release}{(i\_as \argument{as},
                         t\_vaddr \argument{address})}
	 {
	   This function releases a previously reserved map, this
	   includes releasing both virtual and physical memory.
	 }

  \item {\bf {Files}}\\

    \begin{tabular}{| l | l |}
      \hline
      machine-independent & {\em kaneton/core/map/map.c}\\\hline
    \end{tabular}
\end{itemize}

%
% advanced topics
%

\newpage

\section{Bonuses}

kaneton microkernel is first of all a pedagogical project which do not ains at being
optimized. That is why, when nothing is specified, you always will implement the simplest
algorithms.\\
\\
Nevertheless, we will always encourage students who want to write additional bonuses, as far as they respect the following rules:
\begin{enumerate}
  \item Bonuses will be evaluated only if a basic implementation is actually working.
  \item Bonuses must be either picked from the following list, or accepted by the kaneton team.\\
\end{enumerate}

Bonuses ideas:
\begin{itemize}
\item Buddy system
\item Slab allocator
\end{itemize}
