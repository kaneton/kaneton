%%
%% licence       kaneton licence
%%
%% project       kaneton
%%
%% file          /home/buckman/kaneton/view/books/assignments-k1/k1.tex
%%
%% created       matthieu bucchianeri   [tue feb  7 11:49:56 2006]
%% updated       matthieu bucchianeri   [sun feb 11 22:54:06 2007]
%%

%
% k2
%

\chapter{K2: event management}

%
% informations
%

\begin{tabular}{p{7cm}l}
Duration: & 2 weeks \\
Directory name: & kaneton/ \\
In charge: & Matthieu Bucchianeri \& Renaud Voltz\\
Mailing-list: & kaneton-students@googlegroups.com \\
Languages: & C \\
Students per group: & 2 (same groups as for K1) \\
\end{tabular}

\section{Abstract}

K2 project consists in developing XXX

\begin{enumerate}
  \item
    {\bf The event manager}\\
    XXX
  \item
    {\bf The time manager}\\
    XXX
\end{enumerate}

XXX

%
% event manager
%

\newpage

\section{\textbf{event} manager}

\begin{itemize}
  \item {\bf Overview}\\
    XXX
  \item {\bf Assignments}\\
    XXX
  \item {\bf Interface}\\
\function{event\_show}{(i\_event \argument{id})}
	 {
	   This function displays information on an event object.
	 }

\function{event\_dump}{(void)}
	 {
	   This function displays information on all the event objects.
	 }

\function{event\_reserve}{(i\_event \argument{id},
                           e\_event\_type \argument{type},
                           u\_event\_handler \argument{handler})}
	 {
	   This function installs an event handler.

	   \argument{type} can be :
	   \begin{itemize}
	     \item
	       \textbf{EVENT\_FUNCTION}: XXX
	     \item
	       \textbf{EVENT\_MESSAGE}: XXX
	   \end{itemize}

	   The union \argument{handler} contains XXX
	 }

\function{event\_release}{(i\_event \argument{id})}
	 {
	   This function releases an event handler.
	 }

\function{event\_get}{(i\_event \argument{id},
                       o\_event** \argument{o})}
	 {
	   This function returns in \argument{o} the event object
	   corresponding to \argument{id}.
	 }

\function{event\_init}{(void)}
	 {
	   This function initializes the event manager.
	 }

\function{event\_clean}{(void)}
	 {
	   This function cleans the event manager.
	 }
  \item {\bf {Files}}\\

    \begin{tabular}{| l | l |}
      \hline
      machine-independent & {\em kaneton/core/event/event.c}\\
      &  {\em kaneton/include/core/event.h}\\\hline
      machine-dependent & {\em kaneton/core/arch/ibm-pc.ia32-virtual/event.c}\\
      & {\em kaneton/include/arch/ibm-pc.ia32-virtual/core/event.h}\\\hline
      libarch & {\em libs/libia32/pmode/idt.c}\\
      & {\em libs/libia32/include/pmode/idt.h}\\
      & {\em libs/libia32/interrupt/*.c}\\
      & {\em libs/libia32/include/interrupt/*.h}\\\hline
    \end{tabular}
\end{itemize}


%
% tine manager
%

\newpage

\section{\textbf{time} manager}
\begin{itemize}
  \item {\bf Overview}\\
    XXX
  \item {\bf Assignments}\\
    XXX
  \item {\bf Interface}\\
\function{timer\_show}{(i\_timer \argument{id})}
	 {
	   This function displays information on a timer object.
	 }

\function{timer\_dump}{(void)}
	 {
	   This function displays information on all the timers.
	 }

\function{timer\_reserve}{(t\_type \argument{type},
                           u\_timer\_handler \argument{handler},
                           t\_uint32 \argument{delay},
                           t\_uint32 \argument{repeat},
                           i\_timer* \argument{id})}
	 {
	   This function reserves a timer which will expire in
	   \argument{delay} microseconds.

	   The arguments \argument{type} and {handler} works the same
	   way as for \emph{event_reserve}.

	   The \argument{repeat} argument specifies if the timer
	   must be re-inserted once expired.
	 }

\function{timer\_release}{(i\_timer \argument{id})}
	 {
	   This function releases a timer object.
	 }

\function{timer\_delay}{(i\_timer \argument{id},
                         t\_uint32 \argument{delay})}
	 {
	   This function updates the delay.
	 }

\function{timer\_repeat}{(i\_timer \argument{id},
                          t\_uint32 \argument{repeat})}
	 {
	   This function updates the repeat property.
	 }

\function{timer\_modify}{(i\_timer \argument{id},
                          t\_uint32 \argument{delay},
                          t\_uint32 \argument{repeat})}
	 {
	   This function combines the effect of the two previous one.
	 }

\function{timer\_get}{(i\_timer \argument{id},
                       o\_timer** \argument{o})}
	 {
	   This function returns in \argument{o} the timer object
	   corresponding to \argument{id}.
	 }

\function{timer\_init}{(void)}
	 {
	   This function initializes the timer manager.
	 }

\function{timer\_clean}{(void)}
	 {
	   This function cleans the timer manager.
	 }
  \item {\bf Files}\\

    \begin{tabular}{| l | l |}
      \hline
      machine-independent & {\em kaneton/core/time/timer.c}\\
      &  {\em kaneton/include/core/timer.h}\\\hline
      machine-dependent & {\em kaneton/core/arch/ibm-pc.ia32-virtual/timer.c}\\
      & {\em kaneton/include/arch/ibm-pc.ia32-virtual/core/timer.h}\\\hline
      libarch & {\em libs/libia32/time/timer.c}\\
      &  {\em libs/libia32/include/time/pit.h}\\\hline
    \end{tabular}

\end{itemize}

%
% advanced topics
%

\newpage

\section{Bonuses}

kaneton microkernel is first of all a pedagogical project which do not
aims at being optimized. That is why, when nothing is specified, you
always will implement the simplest algorithms.\\
\\
Nevertheless, we will always encourage students who want to write
additional bonuses, as far as they respect the following rules:

\begin{enumerate}
  \item Bonuses will be evaluated only if a basic implementation is
  actually working.
  \item Bonuses must be either picked from the following list, or
  accepted by the kaneton team.\\
\end{enumerate}

Bonuses ideas:
\begin{itemize}
\item More accurate timer using the APIC
\item Managing priority among interrupts
\item Managing nested interrupts
\end{itemize}
