%%
%% licence       kaneton licence
%%
%% project       kaneton
%%
%% file          /home/buckman/kaneton/view/books/assignments-k1/k1.tex
%%
%% created       matthieu bucchianeri   [tue feb  7 11:49:56 2006]
%% updated       matthieu bucchianeri   [sun feb 11 22:54:06 2007]
%%

%
% k2
%

\chapter{K2: event management}

%
% informations
%

\begin{tabular}{p{7cm}l}
Duration: & 2 weeks \\
Directory name: & kaneton/ \\
In charge: & Matthieu Bucchianeri \& Renaud Voltz\\
Mailing-list: & kaneton-students@googlegroups.com \\
Languages: & C \\
Students per group: & 2 (same groups as for K1) \\
\end{tabular}

\section{Abstract}

K2 project consists in developing XXX

\begin{enumerate}
  \item
    {\bf The event manager}\\
    XXX
  \item
    {\bf The time manager}\\
    XXX
\end{enumerate}

XXX

%
% event manager
%

\newpage

\section{\textbf{event} manager}

\begin{itemize}
  \item {\bf Overview}\\

    The event manager in kaneton is used to hook exceptions, IRQ and
    software interrupts and to redirect them to the correct ISR
    (\emph{Interrupt Service Routine}).

    There are two possibilities when redirecting events:
    \begin{itemize}
      \item
	Callbacks. Callbacks are function that can be registered for a
	given event and called when the event occurs.
      \item
	Messages. IPC can be thrown on events. \textbf{At this point
	of the project, these kind of hooks must not be implemented}.
    \end{itemize}

  \item {\bf Assignments}\\

    In K2 you will have to develop the low-level part of the event
    manager for Intel IA-32 architecture.

    Low-level includes that you will write some code in the
    machine-dependent part of the manager. But for the first time, you
    will also have to write significant part of the IA-32 library
    (\emph{libia32}).

    For example, the functions used to fill the interrupt vector table
    (called IDT on IA-32) or to initialize the PIC will be placed in
    libia32.

    When receinving events, your kernel \textbf{must} save and restore
    the execution context, for the moment only the processor's
    registers need to be saved (address space switch is for K3).

  \item {\bf Interface}\\
\function{event\_show}{(i\_event \argument{id})}
	 {
	   This function displays information on an event object.
	 }

\function{event\_dump}{(void)}
	 {
	   This function displays information on all the event objects.
	 }

\function{event\_reserve}{(i\_event \argument{id},
                           e\_event\_type \argument{type},
                           u\_event\_handler \argument{handler})}
	 {
	   This function installs an event handler.

	   \argument{type} can be :
	   \begin{itemize}
	     \item
	       \textbf{EVENT\_FUNCTION}: XXX
	     \item
	       \textbf{EVENT\_MESSAGE}: XXX
	   \end{itemize}

	   The union \argument{handler} contains XXX
	 }

\function{event\_release}{(i\_event \argument{id})}
	 {
	   This function releases an event handler.
	 }

\function{event\_get}{(i\_event \argument{id},
                       o\_event** \argument{o})}
	 {
	   This function returns in \argument{o} the event object
	   corresponding to \argument{id}.
	 }

\function{event\_init}{(void)}
	 {
	   This function initializes the event manager.
	 }

\function{event\_clean}{(void)}
	 {
	   This function cleans the event manager.
	 }
  \item {\bf {Files}}\\

    \begin{tabular}{| l | l |}
      \hline
      machine-independent & {\em kaneton/core/event/event.c}\\
      &  {\em kaneton/include/core/event.h}\\\hline
      machine-dependent & {\em kaneton/core/arch/ibm-pc.ia32-virtual/event.c}\\
      & {\em kaneton/include/arch/ibm-pc.ia32-virtual/core/event.h}\\\hline
      libarch & {\em libs/libia32/pmode/idt.c}\\
      & {\em libs/libia32/include/pmode/idt.h}\\
      & {\em libs/libia32/interrupt/*.c}\\
      & {\em libs/libia32/include/interrupt/*.h}\\\hline
    \end{tabular}
\end{itemize}


%
% tine manager
%

\newpage

\section{\textbf{time} manager}
\begin{itemize}
  \item {\bf Overview}\\

    The timer manager is helpful to create one-shot or repeated
    periodical actions. Like in the event manager, the action
    performed can be either a callback or a message (\textbf{only
    callbacks must be supported for K2}).

  \item {\bf Assignments}\\

    Your work is to develop the whole timer manager.

    The component required to measure time is called the PIT on
    IA-32. Code used to program the PIT must be placed in the libia32.

  \item {\bf Interface}\\
\function{timer\_show}{(i\_timer \argument{id})}
	 {
	   This function displays information on a timer object.
	 }

\function{timer\_dump}{(void)}
	 {
	   This function displays information on all the timers.
	 }

\function{timer\_reserve}{(t\_type \argument{type},
                           u\_timer\_handler \argument{handler},
                           t\_uint32 \argument{delay},
                           t\_uint32 \argument{repeat},
                           i\_timer* \argument{id})}
	 {
	   This function reserves a timer which will expire in
	   \argument{delay} microseconds.

	   The arguments \argument{type} and \argument{handler} works
	   the same way as for \emph{event\_reserve}.

	   The \argument{repeat} argument specifies if the timer
	   must be re-inserted once expired.
	 }

\function{timer\_release}{(i\_timer \argument{id})}
	 {
	   This function releases a timer object.
	 }

\function{timer\_delay}{(i\_timer \argument{id},
                         t\_uint32 \argument{delay})}
	 {
	   This function updates the delay.
	 }

\function{timer\_repeat}{(i\_timer \argument{id},
                          t\_uint32 \argument{repeat})}
	 {
	   This function updates the repeat property.
	 }

\function{timer\_modify}{(i\_timer \argument{id},
                          t\_uint32 \argument{delay},
                          t\_uint32 \argument{repeat})}
	 {
	   This function combines the effect of the two previous one.
	 }

\function{timer\_get}{(i\_timer \argument{id},
                       o\_timer** \argument{o})}
	 {
	   This function returns in \argument{o} the timer object
	   corresponding to \argument{id}.
	 }

\function{timer\_init}{(void)}
	 {
	   This function initializes the timer manager.
	 }

\function{timer\_clean}{(void)}
	 {
	   This function cleans the timer manager.
	 }
  \item {\bf Files}\\

    \begin{tabular}{| l | l |}
      \hline
      machine-independent & {\em kaneton/core/time/timer.c}\\
      &  {\em kaneton/include/core/timer.h}\\\hline
      machine-dependent & {\em kaneton/core/arch/ibm-pc.ia32-virtual/timer.c}\\
      & {\em kaneton/include/arch/ibm-pc.ia32-virtual/core/timer.h}\\\hline
      libarch & {\em libs/libia32/time/timer.c}\\
      &  {\em libs/libia32/include/time/pit.h}\\\hline
    \end{tabular}

\end{itemize}

%
% advanced topics
%

\newpage

\section{Bonuses}

kaneton microkernel is first of all a pedagogical project which do not
aims at being optimized. That is why, when nothing is specified, you
always will implement the simplest algorithms.\\
\\
Nevertheless, we will always encourage students who want to write
additional bonuses, as far as they respect the following rules:

\begin{enumerate}
  \item Bonuses will be evaluated only if a basic implementation is
  actually working.
  \item Bonuses must be either picked from the following list, or
  accepted by the kaneton team.\\
\end{enumerate}

Bonuses ideas:
\begin{itemize}
\item More accurate timer using the APIC
\item Managing priority among interrupts
\item Managing nested interrupts
\end{itemize}
