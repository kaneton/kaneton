%%
%% licence       kaneton licence
%%
%% project       kaneton
%%
%% file          /home/buckman/kaneton/view/books/assignments-k2/k2.tex
%%
%% created       matthieu bucchianeri   [tue feb  7 11:49:56 2006]
%% updated       matthieu bucchianeri   [wed mar 14 23:46:36 2007]
%%

%
% k3
%

\chapter{K3: tasks \& scheduling}

%
% informations
%

\begin{tabular}{p{7cm}l}
Duration: & 2 weeks \\
Directory name: & kaneton/ \\
In charge: & Matthieu Bucchianeri \& Renaud Voltz\\
Mailing-list: & kaneton-students@googlegroups.com \\
Languages: & C \\
Students per group: & 2 (same groups as for previous stages) \\
\end{tabular}

\section{Abstract}

K3 project consists in giving kaneton the ability to execute
tasks. Threads are implemented in kernel-land. The scheduling model is
time-sharing with fixed priorities.

The concerned managers are:

\begin{enumerate}
  \item
    {\bf The task manager}\\
    This manager works on the PCB (Process Control Block) of every
    tasks. This PCB is very simple and made of a few properties, a
    parent identifier, a set of chlidren, an address space identifier
    and a set of threads.
  \item
    {\bf The thread manager}\\
    The thread object is composed of the parent task identifier, stack
    information and scheduling properties like priority. The thread
    manager manage both this part of the thread object plus the
    machine-dependent object made of the thread's execution context.
  \item
    {\bf The sched manager}\\ This manager provides an implementation
    of the scheduler. The scheduler is called periodically (on timer
    for example) to allocate the microprocessor's time.
\end{enumerate}

Your work for this stage of kaneton is to provide a working
time-sharing execution environment both for kernel-land threads and
user-land threads.

\textbf{Important}: do no forget the FIXME in the machine-dependent
part of the as manager, near the end of the file.

Remember that you can add code even if there is no FIXME.


%
% task manager
%

\newpage

\section{\textbf{task} manager}

\begin{itemize}
  \item {\bf Overview}\\

    The \textbf{task manager} provides a complete interface for the
    task objects manipulation.

    A \textbf{task object} \textit{o\_task} describes a complete
    execution entity. Nevertheless, a task object is never scheduled
    since a task is not an active entity (threads are).

    A task is composed of an address space (\textit{i\_as}) and threads
    (set of \textit{i\_thread}).

  \item {\bf Assignments}\\

    No assignments. No modification of the task manager is
    required. The following interface is given as information.

  \item {\bf Interface}\\

\function{task\_show}{(i\_task \argument{id})}
	 {
	   This function displays information on the task \argument{id}.
	 }

\function{task\_dump}{(void)}
	 {
	   This function displays information on every task.
	 }

\function{task\_clone}{(i\_task \argument{old},
                        i\_task* \argument{new})}
	 {
	   This function clones a task.

	   This function must take care of cloning everything necessary
	   including the address space and the threads.
	 }

\function{task\_reserve}{(t\_class \argument{class},
                          t\_behav \argument{behav},
                          t\_prior \argument{prior},
                          i\_task* \argument{id})}
	 {
	   This function reserves a task object with the given
	   properties: \argument{class}, \argument{behav} and
	   \argument{prior}.

	   Note that once reserved, the task is marked as stopped.

	   Task classes include:

	   \begin{itemize}
	     \item
	       \emph{TASK\_CLASS\_CORE}: the tasks executes with
	       supervisor privileges.
	     \item
	       \emph{TASK\_CLASS\_PROGRAM}: the tasks executes as a
	       classical program with user privileges.
	     \item
	       Other classes must not be supported and will not be
	       tested.
	   \end{itemize}

	   Task behavior is used to force a priority interval. Values
	   are (from higher priorities towards lower):

	   \begin{enumerate}
	     \item \emph{TASK\_BEHAV\_CORE}
	     \item \emph{TASK\_BEHAV\_REATIME}
	     \item \emph{TASK\_BEHAV\_INTERACTIVE}
	     \item \emph{TASK\_BEHAV\_TIMESHARING}
	     \item \emph{TASK\_BEHAV\_BACKGROUND}
	   \end{enumerate}

	   The default priority of a task is
	   \emph{TASK\_PRIOR\_$<<$behav$>>$}.
	 }

\function{task\_release}{(i\_task \argument{id})}
	 {
	   This function releases the task object \argument{id}.
	 }

\function{task\_priority}{(i\_task \argument{id},
                           t\_prior \argument{prior})}
	 {
	   This function updates the task's priority to \argument{prior}.

	   The priority must be in the interval corresponding to the
	   task behavior, between \emph{TASK\_LPRIOR\_$<<$behav$>>$} and
	   \emph{TASK\_HPRIOR\_$<<$behav$>>$}.
	 }

\function{task\_state}{(i\_task \argument{id},
                        t\_state \argument{sched})}
	 {
	   This function starts or stop a task (this means all its
	   threads).

	   Values for \argument{sched} are:

	   \begin{itemize}
	     \item
	       \emph{SCHED\_STATE\_RUN}: run the task.
	     \item
	       \emph{SCHED\_STATE\_STOP}: stop the task.
	   \end{itemize}
	 }

\function{task\_wait}{(i\_task \argument{id},
                       t\_opts \argument{opts},
                       t\_wait* \argument{wait})}
	 {
	   This function waits for state change in one or more tasks
	   depending on the options \argument{opts}.

	   \notice{This feature is not yet implemented.}
	 }

\function{task\_get}{(i\_task \argument{id},
                      o\_task** \argument{o})}
	 {
	   This function returns in \argument{o} the task object corresponding
	   to \argument{id}.
	 }

\function{task\_init}{(void)}
	 {
	   This function initializes the task manager.
	 }

\function{task\_clean}{(void)}
	 {
	   This function cleans the task manager.
	 }

  \item {\bf {Files}}\\

    \begin{tabular}{| l | l |}
      \hline
      machine-independent & {\em kaneton/core/task/task.c}\\
      &  {\em kaneton/include/core/task.h}\\\hline
      machine-dependent & {\em kaneton/core/arch/ibm-pc.ia32-virtual/task.c}\\
      & {\em kaneton/include/arch/ibm-pc.ia32-virtual/core/task.h}\\\hline
      libarch & {\em libs/libia32/task/*.c}\\
      & {\em libs/libia32/include/task/*.h}\\\hline
    \end{tabular}
\end{itemize}


%
% thread manager
%

\newpage

\section{\textbf{thread} manager}
\begin{itemize}
  \item {\bf Overview}\\

    The \textbf{thread manager} manages the real active execution
    context called threads.

    A \textbf{thread object} is an active entity which describes the
    current state of an execution context including the
    \textit{program counter}, the \textit{stack pointer} etc..

    Indeed, a thread is composed of a current \textit{program counter}
    which keeps the next instruction address to execute and the
    \textit{stack pointer} which keeps the stack address. With these
    two characteristics, a thread can be described.

    Needless to say, some additional architecture-dependent properties
    are required to fully describe a thread context.

  \item {\bf Assignments}\\

    XXX

  \item {\bf Interface}\\

\function{thread\_show}{(i\_thread \argument{id})}
	 {
	   This function displays information on the thread \argument{id}.
	 }

\function{thread\_dump}{(void)}
	 {
	   This function displays information on all the threads.
	 }

\function{thread\_give}{(i\_task \argument{task},
                         i\_thread \argument{id})}
	 {
	   This function gives the thread object \argument{id} to the
	   task \argument{task}.
	 }

\function{thread\_clone}{(i\_task \argument{task},
                          i\_thread \argument{old},
                          i\_thread* \argument{new})}
	 {
	   This function clones the task \argument{old} into a new one
	   \argument{new}.

	   This new thread, having the exact same properties as \argument{old},
	   will be held by the task \argument{task}.
	 }

\function{thread\_reserve}{(i\_task \argument{task},
                            t\_prior \argument{prior},
                            i\_thread* \argument{id})}
	 {
	   This function reserves a thread for the task \argument{task}
	   given the default thread priority \argument{prior}.

	   Note that once reserved, the thread is marked as stopped.

	   The priority must be in the interval \emph{THREAD\_LPRIOR},
	   \emph{THREAD\_HPRIOR}.
	 }

\function{thread\_release}{(i\_thread \argument{id})}
	 {
	   This function releases the thread object \argument{id}.
	 }

\function{thread\_priority}{(i\_thread \argument{id},
                             t\_prior \argument{prior})}
	 {
	   This function updates the current thread priority
	   to \argument{prior}.

	   Values for \argument{sched} are:

	   \begin{itemize}
	     \item
	       \emph{SCHED\_STATE\_RUN}: run the task.
	     \item
	       \emph{SCHED\_STATE\_STOP}: stop the task.
	   \end{itemize}
	 }

\function{thread\_state}{(i\_thread \argument{id},
                          t\_state \argument{sched})}
	 {
	   XXX
	 }

\function{thread\_wait}{(i\_thread \argument{id},
                         t\_opts \argument{opts},
                         t\_wait* \argument{wait})}
	 {
	   This function acts like the function \textbf{task\_wait}().

	   This function waits for the thread's state to change depending on
	   the options \argument{opts}.

	   \notice{This feature is not yet implemented.}
	 }

\function{thread\_get}{(i\_thread \argument{id},
                        o\_thread** \argument{o})}
	 {
	   This function returns in \argument{o} the thread object
	   corresponding to \argument{id}.
	 }

\function{thread\_flush}{(i\_task \argument{task})}
	 {
	   This function removes every thread that belongs to the
	   task object \argument{task}.
	 }

\function{thread\_stack}{(i\_thread \argument{id},
                          t\_stack \argument{size})}
	 {
	   This function allocates a stack of \argument{size} bytes
	   for the thread \argument{id}.

	   XXX
	 }

\function{thread\_load}{(i\_thread \argument{id},
                         t\_thread\_context \argument{context})}
	 {
	   This function loads a new execution context in the thread
	   object \argument{id}.

	   A thread execution context \textit{t\_thread\_context}
	   only contains the \textit{program counter} and the
	   \textit{stack pointer}.

	   XXX
	 }

\function{thread\_store}{(i\_thread \argument{id},
                          t\_thread\_context* \argument{context})}
	 {
	   This function stores in \argument{context} the current
	   thread execution context of the thread object \argument{id}.

	   XXX
	 }

\function{thread\_init}{(void)}
	 {
	   This function initializes the thread manager.
	 }

\function{thread\_clean}{(void)}
	 {
	   This function cleans the thread manager.
	 }

  \item {\bf Files}\\

    \begin{tabular}{| l | l |}
      \hline
      machine-independent & {\em kaneton/core/thread/thread.c}\\
      &  {\em kaneton/include/core/thread.h}\\\hline
      machine-dependent & {\em kaneton/core/arch/ibm-pc.ia32-virtual/thread.c}\\
      & {\em kaneton/include/arch/ibm-pc.ia32-virtual/core/thread.h}\\\hline
      libarch & {\em libs/libia32/task/*.c}\\
      &  {\em libs/libia32/include/task/*.h}\\\hline
    \end{tabular}

\end{itemize}


%
% sched manager
%

\newpage

\section{\textbf{sched} manager}
\begin{itemize}
  \item {\bf Overview}\\

    XXX

  \item {\bf Assignments}\\

    \textbf{Note about priorities}: the task priority will not be
    used. Only priorities of thread are used for scheduling.

  \item {\bf Interface}\\

\function{sched\_dump}{(void)}
	 {
	   This function displays the scheduler state.
	 }

\function{sched\_quantum}{(t\_quantum \argument{quantum})}
	 {
	   This function sets the scheduler quantum to \argument{quantum}.

	   XXX
	 }

\function{sched\_yield}{(i\_cpu \argument{cpuid})}
	 {
	   This function permits the current task to relinquish
	   the processor voluntarily.

	   Don't care about the argument \argument{cpuid}.
	 }

\function{sched\_add}{(i\_thread \argument{thread})}
	 {
	   This function adds a runnable thread to the scheduler.
	 }

\function{sched\_remove}{(i\_thread \argument{thread})}
	 {
	   This function remove a thread from the scheduler.
	 }

\function{sched\_update}{(i\_thread \argument{thread})}
	 {
	   This function asks the scheduler to update the thread
	   \argument{thread} in its internal data structures since
	   for example the thread's priority just changed.
	 }

\function{sched\_current}{(i\_thread* \argument{thread})}
	 {
	   This function returns in \argument{thread} the identifier
	   of the thread currently executed.
	 }

\function{sched\_switch}{(void)}
	 {
	   This function just schedules a new elected thread.

	   \textbf{Note}: the machine-dependent code of this function
	   takes an additional parameter.

	   \function{ia32\_sched\_switch}{(i\_thread \argument{elected})}
		    {
		      The argument \argument{elected} is the new
		      thread to run.
		    }
	 }

\function{sched\_init}{(void)}
	 {
	   This function initializes the scheduler.
	 }

\function{sched\_clean}{(void)}
	 {
	   This function cleans the scheduler.
	 }

  \item {\bf Files}\\

    \begin{tabular}{| l | l |}
      \hline
      machine-independent & {\em kaneton/core/sched/sched.c}\\
      &  {\em kaneton/include/core/sched.h}\\\hline
      machine-dependent & {\em kaneton/core/arch/ibm-pc.ia32-virtual/sched.c}\\
      & {\em kaneton/include/arch/ibm-pc.ia32-virtual/core/sched.h}\\\hline
      libarch & {\em libs/libia32/task/*.c}\\
      &  {\em libs/libia32/include/task/*.h}\\\hline
    \end{tabular}

\end{itemize}

%
% advanced topics
%

\newpage

\section{Bonuses}

kaneton microkernel is first of all a pedagogical project which do not
aims at being optimized. That is why, when nothing is specified, you
always will implement the simplest algorithms.\\
\\
Nevertheless, we will always encourage students who want to write
additional bonuses, as far as they respect the following rules:

\begin{enumerate}
  \item Bonuses will be evaluated only if a basic implementation is
  actually working.
  \item Bonuses must be either picked from the following list, or
  accepted by the kaneton team.\\
\end{enumerate}

Bonuses ideas:
\begin{itemize}
\item
  Implement a better scheduler. Feel free to implement any other
  algorithm. You can try the multi-level feedback queue explained
  during the lesson.

\item
  Add dynamic priorities.

\item
  Implement support for Floating Point Unit (FPU) contexts. The FPU
  context must be saved only when required.
\end{itemize}
