%
% ---------- header -----------------------------------------------------------
%
% project       kaneton
%
% license       kaneton
%
% created       julio guerra   [sat mar 22 12:33:00 2014]
%
%
% ---------- setup ------------------------------------------------------------
%

%
% path
%

\def\path{../../..}

%
% template
%

\input{\path/template/examclass.tex}

\newcommand{\class}{NSE}
\newcommand{\examdate}{2014}
\newcommand{\timelimit}{3h}
\newcommand{\school}{EPITA}

%
% exam
%
\begin{document}

%
% cover header
%

\begin{center}
  {\LARGE Noyaux et Systèmes d'Exploitation}\\
  \vspace{1cm}
  \textbf{Durée: 3 heures}\\
  \textbf{Documents et calculatrices interdits}\\
  \scriptsize{Les résultats des calculs sous forme non-développée sont admis.}\\
  \scriptsize{Les questions bonus donnent des points bonus sommés à la note finale du partiel.}\\
  \scriptsize{Une copie bien présentée sera toujours mieux notée qu'une autre.}
\end{center}
\vspace{1cm}

%
% ---------- questions --------------------------------------------------------
%

\begin{questions}

%
% architecture
%
\titledquestion{Architecture}
Face à l'euphorie de la communauté devant linux, A. Tanenbaum écrit en 1992 que "linux est obsolète". L. Torvalds intervient alors et marque le début d'un long débat à propos de l'architecture des OS: monolithique pour linux (Torvalds), micro-noyau pour minix (Tanenbaum). Tanembaum affirme que les "micro-noyaux ont gagné" face aux vieux noyaux monolithiques, or linux réintroduit une architecture monolithique.

\begin{parts}
  % q
  \part[4] Quels sont les arguments de A. Tanembaum en faveur des architectures micro-noyau?

  % q
  \part[4] Quels sont les arguments de L. Torvalds en faveur des architectures monolithiques?
\end{parts}

%
% boot
%
\titledquestion{Boot}

\begin{parts}
  \part Firmware
  \begin{subparts}
    % q
    \subpart Quel est le rôle d'un firmware?

    % q
    \subpart Pourquoi les firmwares sont-ils en ROM (Read-Only Memory)?

    % q
    \subpart Quelle est généralement la premère tâche réalisée par un firmware en ROM?

    % q
    \subpart Quelle est l'interface firmware/bootloader sur les ordinateurs IBM-PC?\\
      Le BIOS fait office de firmware dans ce cas.
  \end{subparts}

  \part{Bootloader}
  \begin{subparts}
    % q
    \subpart Quel est le rôle d'un bootloader?

    % q
    \subpart Pourquoi les bootloaders historiques des ordinateurs IBM-PC se décomposent-ils en plusieurs binaires?

    % q
    \subpart Proposer une interface bootloader/firmware sur laquelle pourra se reposer votre OS.
  \end{subparts}

  % q
  \bonuspart[1]
Soit un système pouvant démarrer sous différents modes, maintenance et opérationnel, en fonction de la position d'un interrupteur. Proposer les interfaces firmware/bootloader et bootloader/OS permettant de réaliser ce sytème. Chaque mode à son propre binaire en ROM. Le mode maintenance permet de télécharger un nouveau binaire pour le mode opérationnel.
\end{parts}

%
% interruptions
%
\titledquestion{Interruptions}

\begin{parts}
  % q
  \part Donner une solution apportée par les interruptions (1 pt).

  % q
  \part La fonction de traitement des interruptions d'un ordinateur requiert 2 ms (temps de commutation des processus inclus) par top d'horloge. La fréquence de l'horloge est de 60 Hz. Quel est le pourcentage de temps que le processeur consacre à l'horloge? Commenter.

  % q
  \bonuspart[1] Comment sont gérées les interruptions dans un contexte multi-coeur?
\end{parts}

%
% memoire
%
\titledquestion{Mémoire}

\begin{parts}
  % q
  \part Donner deux différences entre la ségmentation et la pagination.

  % q
  \part[1] Quel est l'inconvénient de la technique de mirroring?

  % q
  \part[4] Proposer une alternative au mirroring sans en perdre l'avantage majeur.

  % q
  \part L'un des avantages des processus légers (threads) est qu'ils évitent de vider la TLB lors d'un changement de contexte entre des processus légers d'un même processus.
  \begin{subparts}
    % q
    \subpart[1] Comment est indexée une telle TLB (se vidant lors d'un changement de contexte de processus) ?
    \begin{solution}
      Avec l'adresse virtuelle sans l'offset.
    \end{solution}

    % q
    \subpart[1] Proposez une modification simple à cette indexation afin d'éviter la vidange de la TLB en cas de changement de contexte entre processus.
    \begin{solution}
      Ajout d'un identifiant d'espace d'adressage.
    \end{solution}
  \end{subparts}

  % q
  \part Sur une architecture ayant des adresses virtuelles de 32 bits, \textbf{dessiner} les mappings (association pages virtuelles/pages physique) permettant:
  \begin{subparts}
    \subpart[1] au kernel de s'exécuter dans un mode d'adressage réel 16 bits.
    \subpart[1] à deux processus de partager un buffer.
    \subpart[1] d'utiliser la technique de "copy-on-write" après une fork.
  \end{subparts}

  % q
  \bonuspart[1] Comment permettre le partage de code (bibliothèque partagée) grâce à la ségmentation?
\end{parts}

%
% Multi-tache / Ordonnancement %
%
\titledquestion{Multi-tâche \& Ordonnancement}

\begin{parts}

  % q processus
  \part
  \begin{subparts}
    % q
    \subpart[2] Comment sont catégorisées les tâches que l'on retrouve dans les systèmes généraux? Quelles sont leur caractéristique?
    \begin{solution}
      \begin{itemize}
      \item Interactif: beaucoup d'E/S => exécution courte (réveil, traitement, nouvelle E/S) => rend la main vite.  1 point
      \item Traitement | Batch | Traitement par lot: utilisation du CPU intensive (e.g. calcul mathématique, etc.). 1 point
      \end{itemize}
    \end{solution}

    % q
    \subpart[2] Quels sont leur objectif?
    \begin{solution}
      \begin{itemize}
      \item Intéractif: temps de réponse le plus faible possible. (1 point)
      \item Batch: temps d'exécution (jusqu'à complétude) le plus faible possible - exécution la plus rapide que possible - exécution la moins interrompue que possible.
      \end{itemize}
    \end{solution}

    % q
    \subpart[2] Proposer une heuristique simple permettant de déterminer à quelle catégorie appartient un processus.
    \begin{solution}
      Plusieurs réponses possibles:
      \begin{itemize}
      \item Mémorisation des temps d'exécution => une tâche avec un temps d'exécution faible est interactive, une tâche avec un temps d'exécution grand est “batch”.
      \item Mémorisation des nombre de blocage avant la fin du quantum => une tâche avec beaucoup de blocage est interactive, une tâche avec peu de blocage est batch.
      \item n'importe quoi de correct :)
      \end{itemize}
    \end{solution}
  \end{subparts}

  % q
  \part Les ordonnanceurs circulaires mémorisent la liste des processus prêts et chaque processus n'apparaît qu'une seule fois dans cette liste.
  \begin{subparts}
    %q
    \subpart[1] Que se passerait-il si un processus y apparaissait deux fois?

    %q
    \subpart[1] Pourquoi permettrait-on l'insertion multiple d'un processus dans cette liste?
  \end{subparts}
  \begin{solution}
    Il serait élu deux fois plutôt qu'une à chaque tour complet de la liste des processus. Intéressant pour favoriser des processus pour implémenter un système primitif à priorité.
  \end{solution}

  % q
  \part[2] La plupart des ordonnanceurs circulaires utilisent un quantum fixe. Donnez un argument en faveur d'un petit quantum et un autre en faveur d'un grand quantum, ainsi que la catégorie de processus favorisé.
  \begin{solution}
    \begin{itemize}
    \item Petit quantum => temps de réponse élevé. Favorise les processus interactifs.  (1 point)
    \item Grand quantum => temps CPU utile élevé. Favorise les processus batch. (1 point)
    \end{itemize}
  \end{solution}

\end{parts}

%
% concurrence
%
\titledquestion{Concurrence}
\begin{parts}

  %q
  \part[1] TODO

\end{parts}

%
% virtualisation
%
\titledquestion{Virtualisation}
\begin{parts}

  %q
  \part[1] En quoi consiste la translation dynamique de code?

\end{parts}

\end{questions}

%
% grading table
%
\gradingtable

\end{document}
