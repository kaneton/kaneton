%
% ---------- header -----------------------------------------------------------
%
% project       kaneton
%
% license       kaneton
%
% created       julio guerra   [sat mar 15 09:44:00 2014]
%
%
% ---------- setup ------------------------------------------------------------
%

%
% path
%

\def\path{../../..}

%
% template
%

\input{\path/template/exam.tex}

%
% document
%
\usepackage[utf8]{inputenc}
\usepackage{enumitem}
\usepackage{geometry}
\newgeometry{margin=2cm}

\begin{document}

%
% title
%

\title{Noyaux et Systèmes d'Exploitation}

%
% header
%

\lhead{\scriptsize{EPITA\_ING2 - 2014\_S4 - NSE}}
\rhead{}

%
% title
%

\maketitle

%
% indentation
%

\indentation{}

%
% --------- information -------------------------------------------------------
%

\begin{center}

\textbf{Durée: 3 heures}\\
\textbf{Documents et calculatrice interdits}\\
\scriptsize{Les résultats des calculs sous forme non-développée sont admis.}\\
\scriptsize{Les questions bonus donnent des points bonus sommés à la note finale du partiel.}\\
\scriptsize{Une copie bien présentée sera toujours mieux notée qu'une autre.}

\end{center}

%
% --------- text --------------------------------------------------------------
%

%
% architecture
%

\section{{Architecture}
         {\hfill{} \normalfont{\scriptsize{N points}}}}


\subsection{Linux is obsolete}

Face à l'euphorie de la communauté devant linux, A. Tanenbaum écrit en 1992 que "linux est obsolète". L. Torvalds intervient alors et marque le début d'un long débat à propos de l'architecture des OS: monolithique pour linux (Torvalds), micro-noyau pour minix (Tanenbaum). Tanembaum affirme que les "micro-noyaux ont gagné" face aux vieux noyaux monolithiques, or linux réintroduit une architecture monolithique.

\begin{enumerate}
\item Quels sont les arguments de A. Tanembaum en faveur des architectures micro-noyau?
\item Quels sont les arguments de L. Torvalds en faveur des architectures monolithiques?
\end{enumerate}

%
% boot
%

\section{{Boot}
         {\hfill{} \normalfont{\scriptsize{N points}}}}

\subsection{Firmware}

\begin{enumerate}
\item Quel est le rôle d'un firmware?
\item Pourquoi les firmwares sont-ils en ROM (Read-Only Memory)?
\item Quelle est généralement la premère tâche réalisée par un firmware en ROM?
\item Quelle est l'interface firmware/bootloader sur les ordinateurs IBM-PC?\\
      Le BIOS fait office de firmware dans ce cas.
\end{enumerate}

\subsection{Bootloader}
\begin{enumerate}
\item Quel est le rôle d'un bootloader?
\item Pourquoi les bootloaders historiques des ordinateurs IBM-PC se décomposent-ils en plusieurs binaires?
\item Proposer une interface bootloader/firmware sur laquelle pourra se reposer votre OS.
\end{enumerate}

\subsection*{Bonus:}
Soit un système pouvant démarrer sous différents modes, maintenance et opérationnel, en fonction de la position d'un interrupteur. Proposer les interfaces firmware/bootloader et bootloader/OS permettant de réaliser ce sytème.\\
Chaque mode à son propre binaire en ROM. Le mode maintenance permet de télécharger un nouveau binaire pour le mode opérationnel.

% Interruptions %
\section{{Interruptions}
         {\hfill{} \normalfont{\scriptsize{N points}}}}

\begin{enumerate}
% Q
\item Donner une solution apportée par les interruptions (1 pt).

% Q
\item La fonction de traitement des interruptions d'un ordinateur requiert 2 ms (temps de commutation des processus inclus) par top d'horloge. La fréquence de l'horloge est de 60 Hz. Quel est le pourcentage de temps que le processeur consacre à l'horloge? Commenter.

\end{enumerate}


\subsection*{Bonus:}
Comment sont gérées les interruptions dans un contexte multi-coeur?

% Memoire %
\section{{Mémoire}
         {\hfill{} \normalfont{\scriptsize{M pts}}}}

\begin{enumerate}

% Q
\item Donner deux différences entre la ségmentation et la pagination.

% Q
\item Quel est l'inconvénient de la technique de mirroring? (1 pt)

% Q
\item Proposer une alternative au mirroring sans en perdre l'avantage majeur. (4 pt)

% Q
\item L'un des avantages des processus légers (threads) est qu'ils évitent de vider la TLB lors d'un changement de contexte entre des processus légers d'un même processus.
\begin{enumerate}
  \item Comment est indexée une telle TLB (se vidant lors d'un changement de contexte de processus) ? (1 pt)
  \item Proposez une modification simple à cette indexation afin d'éviter la vidange de la TLB en cas de changement de contexte entre processus. (1 pt)
\end{enumerate}

% R
\begin{correction}
\begin{enumerate}[label=(\alph*)]
\item Avec l'adresse virtuelle sans l'offset.
\item Ajout d'un identifiant d'espace d'adressage.
\end{enumerate}
\end{correction}

% Q
\item Sur une architecture ayant des adresses virtuelles de 32 bits, \textbf{dessiner} les mappings (association pages virtuelles/pages physique) permettant:
\begin{enumerate}[label=(\alph*)]
\item au kernel de s'exécuter dans un mode d'adressage réel 16 bits. (1 pt)
\item à deux processus de partager un buffer. (1 pt)
\item d'utiliser la technique de "copy-on-write" après une fork. (1 pt)
\end{enumerate}

\subsection*{Bonus:}
Comment permettre le partage de code (bibliothèque partagée) grâce à la ségmentation?

% fin de la partie Mémoire
\end{enumerate}


% Multi-tache / Ordonnancement %
\section{{Multi-tâche \& Ordonnancement}
         {\hfill{} \normalfont{\scriptsize{N points}}}}

\begin{enumerate}

% Q
\item Expliquez pourquoi l'implémentation du changement de contexte de
      kaneton induit une perte de performance certaine. Comment remédier à
      ce problème? Vous pourrez exposer des exemples d'implémentation dans
      d'autres noyaux.


% Q
\item Comment sont catégorisées les tâches que l'on retrouve dans les systèmes généraux? Quelles sont leur caractéristique? (2 points)

% R
\begin{correction}
\begin{itemize}
  \item Interactif: beaucoup d'E/S => exécution courte (réveil, traitement, nouvelle E/S) => rend la main vite.  1 point
  \item Traitement | Batch | Traitement par lot: utilisation du CPU intensive (e.g. calcul mathématique, etc.). 1 point
\end{itemize}
\end{correction}


% Q
\item Quels sont leur objectif? (2 points)

% R
\begin{correction}
\begin{itemize}
  \item Intéractif: temps de réponse le plus faible possible. (1 point)
  \item Batch: temps d'exécution (jusqu'à complétude) le plus faible possible - exécution la plus rapide que possible - exécution la moins interrompue que possible. (1 point)
\end{itemize}
\end{correction}


% Q
\item Proposez une heuristique simple permettant de déterminer à quelle catégorie appartient un processus. (2 points)

% R
\begin{correction}
Plusieurs réponses possibles:
\begin{itemize}
  \item Mémorisation des temps d'exécution => une tâche avec un temps d'exécution faible est interactive, une tâche avec un temps d'exécution grand est “batch”.
  \item Mémorisation des nombre de blocage avant la fin du quantum => une tâche avec beaucoup de blocage est interactive, une tâche avec peu de blocage est batch.
  \item n'importe quoi de correct :)
\end{itemize}
\end{correction}


% Q
\item Les ordonnanceurs circulaires mémorisent la liste des processus prêts et chaque processus n'apparaît qu'une seule fois dans cette liste. Que se passerait-il si un processus y apparaissait deux fois (1 point)? Pourquoi permettrait-on l'insertion multiple d'un processus dans cette liste (1 point)?

% R
\begin{correction}
Il serait élu deux fois plutôt qu'une à chaque tour complet de la liste des processus. Intéressant pour favoriser des processus pour implémenter un système primitif à priorité.
\end{correction}


% Q
\item La plupart des ordonnanceurs circulaires utilisent un quantum fixe. Donnez un argument en faveur d'un petit quantum et un autre en faveur d'un grand quantum, ainsi que la catégorie de processus favorisé. (2 points)

% R
\begin{correction}
\begin{itemize}
  \item Petit quantum => temps de réponse élevé. Favorise les processus interactifs.  (1 point)
  \item Grand quantum => temps CPU utile élevé. Favorise les processus batch. (1 point)
\end{itemize}
\end{correction}


% Q
\item Cinq travaux, A à E, arrivent pratiquement en même temps dans un centre de calcul. Leur temps d'exécution respectif est estimé à 10, 6, 2, 4, 8 minutes. Leurs priorités (déterminées de manière externe) sont 3, 5, 2, 1 et 4, la valeur 5 correspondant à la priorité la plus élevée. Déterminez le temps moyen d'attente pour chacun des algorithmes d'ordonnancement suivants. Ne tenez pas compte du temps perdu lors de la commutation des processus.
  \begin{enumerate}
  \item Tourniquet (1 point)
  \item Ordonnancement avec priorité (1 point)
  \item Premier arrivé, premier servi (ordre d'arrivée: ordre alphabétique). (1 point)
  \item Plus court d'abord. (1 point)
  \end{enumerate}
Dans le cas (a) on fait l'hypothèse que le temps processeur est équitablement réparti entre les différents travaux. Dans les cas (b) à (d), on suppose que chaque travail est exécuté jusqu'à ce qu'il se termine. Les travaux n'effectuent pas d'E/S. Détaillez vos calculs (dessins/tableaux \& moyenne sous forme de quotient admis).

% R
\begin{correction}\\
P: Processus courant\\
T: Tour/Temps d’exécution depuis un 0 absolu.\\
E: temps d'exécution restant\\

\begin{enumerate}[label=(\alph*)]

\item Round Robin: la remarque sous-entend la préemption\\
      Timeline de l’execution: * = exécution terminée

      \begin{tabular}{|c||c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|}
      \hline
      P & A & B & C & D & E & A & B & C{*} & D & E & A & B & D & E & A & B & D{*} & E\tabularnewline
      \hline
      T & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 & 10 & 11 & 12 & 13 & 14 & 15 & 16 & 17 & 18\tabularnewline
      \hline
      E & 9 & 5 & 1 & 3 & 7 & 8 & 4 & 0 & 2 & 6 & 7 & 3 & 1 & 5 & 6 & 2 & 0 & 4\tabularnewline
      \hline
      \end{tabular}

      \begin{tabular}{|c||c|c|c|c|c|c|c|c|c|c|c|c|}
      \hline
      P & A & B & E & A & B{*} & E & A & E & A & E{*} & A & A{*}\tabularnewline
      \hline
      T & 19 & 20 & 21 & 22 & 23 & 24 & 25 & 26 & 27 & 28 & 29 & 30\tabularnewline
      \hline
      E & 5 & 1 & 3 & 4 & 0 & 2 & 3 & 1 & 2 & 0 & 1 & 0\tabularnewline
      \hline
      \end{tabular}

      Temps d’attente:\\
      C = 8 min\\
      D = 17 min\\
      B = 23 min\\
      E = 28 min\\
      A = 30 min\\
      Moyenne = (A + B + C + D + E) / 5 = 21,2 min

\item Priorité:\\
      \begin{tabular}{|c||c|c|c|c|c|}
      \hline
      P & B & E & A & C & D\tabularnewline
      \hline
      T & 6 & 6+8=14 & 14+10=24 & 24+2=26 & 26+4=30\tabularnewline
      \hline
      \end{tabular}\\
      Moyenne = (6 + 14 + 24 + 26 + 30) / 5 = 20 minutes

\item Premier arrivé, premier servi:\\
      \begin{tabular}{|c||c|c|c|c|c|}
      \hline
      P & A & B & C & D & E\tabularnewline
      \hline
      T & 10 & 10+6=16 & 16+2=18 & 18+4=22 & 22+8=30\tabularnewline
      \hline
      \end{tabular}\\
      Moyenne = (10 + 16 + 18 + 19 + 23) / 5 = 19,2 minutes

\item Plus court d’abord:\\
      \begin{tabular}{|c||c|c|c|c|c|}
      \hline
      P & C & D & B & E & A\tabularnewline
      \hline
      T & 2 & 2+4=6 & 6+6=12 & 12+8=20 & 20+10=30\tabularnewline
      \hline
      \end{tabular}\\
      Moyenne = (2 + 6 + 12 + 20 + 30)/5 = 14 minutes
\end{enumerate}
\end{correction}

% fin de multi-tache & ordonnancement
\end{enumerate}


% Concurrence %
\section{{Concurrence}
         {\hfill{} \normalfont{\scriptsize{X points}}}}

\begin{enumerate}

% Q
\item Supposez que vous ayez à concevoir l'architecture d'un ordinateur évolué où la commutation entre les processus serait faite par le matériel, et non par logiciel via le mécanisme d'interruption. Quelles seraient les informations nécessaires au processeur ? Décrivez le fonctionnement de la commutation effectuée par le matériel (2 points).

% R
\begin{correction}
\begin{itemize}
  \item Pour faire un contexte switch, le CPU a besoin des infomartions suivantes du processus à exécuter:
  \begin{itemize}
    \item Registres Généraux (1 point)
    \item Pointeurs sur pile et sur code (program counter, next instruction pointer...), stack pointer (1 point)
    \item Control Registers (1 point)
  \end{itemize}
  Fonctionnement du context switch HW moins souple qu'un SW: il ne sait pas ce qu'il execute, il sauvegarde donc tous les registres du processeurs, il doit aussi chercher les nouvelles données dans des structures bien définies.
\end{itemize}
\end{correction}


% Q
\item Quelle est la différence entre un thread kernel et un thread user-land ?

% fin de Concurrence
\end{enumerate}



% Virtualisation et IPC %
\section{{Virtualisation et IPC}
         {\hfill{} \normalfont{\scriptsize{X points}}}}

\begin{enumerate}

% Q
\item Après avoir défini ce qu'est une IPC, donner un exemple pertinent d'utilisation.

% Q
\item Expliquer les différentes méthodes de virtualisation.

% R
\begin{correction}
\begin{itemize}
\item PV : Paravirtualiser. Le système d'exploitation est au courant qu'il s'exécute dans une machine virtuelle et est modifé en conséquence pour coopérer avec l'hyperviseur.
\item HVM : Hardware Virtualized Machine. Le système d'exploitation peut s'éxécuter sans modification à l'intérieur d'une machine virtuelle.
\end{itemize}
\end{correction}


% Q
\item Expliquer les termes suivant: VT-x, VT-d, E820, EPT, NPT

\end{enumerate}

\end{document}
