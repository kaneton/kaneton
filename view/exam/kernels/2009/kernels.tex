%
% ---------- header -----------------------------------------------------------
%
% project       kaneton
%
% license       kaneton
%
% file          /home/mycure/kaneton/view/exam/kernels/2009/kernels.tex
%
% created       julien quintard   [mon may 14 21:56:41 2007]
% updated       julien quintard   [thu apr 30 13:36:36 2009]
%

%
% ---------- setup ------------------------------------------------------------
%

%
% path
%

\def\path{../../..}

%
% template
%

\input{\path/template/exam.tex}

%
% title
%

\title{Noyaux}

%
% document
%

\begin{document}

%
% title
%

\maketitle

%
% identation
%

\indentation{}

%
% --------- information -------------------------------------------------------
%

\begin{center}

\textbf{Documents Interdits}

\textbf{Dur\'ee 3 heures}

\scriptsize{Une copie bien pr\'esent\'ee sera toujours mieux not\'ee
            qu'une autre.}

\end{center}

%
% --------- text --------------------------------------------------------------
%

%
% premiere partie
%

\section{Premi\`ere Partie}
{\hfill{} \scriptsize{4 points/30 minutes}}

XXX[Francois]

%
% deuxieme partie
%

\section{Deuxi\`eme Partie}
{\hfill{} \scriptsize{6 points/50 minutes}}

XXX[Benoit]

%
% troisieme partie
%

\section{Troisi\`eme Partie}
{\hfill{} \scriptsize{5 points/45 minutes}}

XXX[Jean]

%
% quatrieme partie
%

\section{Quatri\`eme Partie}
{\hfill{} \scriptsize{45 minutes}}

%
% securite
%
\subsection{S\'ecurit\'e}
{\hfill{} \scriptsize{2.5 points}}

Un service d\'esire fournir \`a certains clients la possibilit\'e
d'effectuer des op\'erations via l'utilisation de \name{capabilities}.

\'Etant donn\'e que le service ne g\`ere aucun objet mais propose
aux clients d'effectuer un maximum de $13$ op\'erations diff\'erentes,
veuillez d\'efinir le format des \name{capabilities} \`a utiliser en
d\'ecrivant la taille et l'utilit\'e de chaque champ.

Enfin, vous d\'etaillerez le processus de v\'erification effectu\'e
par le service en question.

\begin{correction}

Consid\'erant un syst\`eme d'exploitation non r\'eparti, un champ sera
utilis\'e pour identifi\'e le service en question, un \texttt{i\_task}
sur $64$ bits par exemple. Un champ de $13$ bits sera utilis\'e pour
d\'ecrire les $13$ op\'erations autoris\'ees. Enfin, un champ \name{Check}
de $64$ bits, par exemple, sera utilis\'e pour s\'ecuriser la
\name{capability}.

Le processus de v\'erification consiste \`a r\'ecup\'erer le \name{Check}
d'origine \`a partir d'une structure interne au service, \`a appliquer un
\name{XOR} entre le \name{Check} d'origine et le champ \name{Operations}
de la \name{capability} re\c{c}ue pour enfin appliquer une fonction
\`a sens unique. Il suffit finalement de comparer le r\'esultat avec le
champ \name{Check} contenu dans la \name{capability}. Si ils sont
\'egaux, alors la \name{capability} est valide.

\end{correction}

%
% windows nt
%
\subsection{Windows NT}
{\hfill{} \scriptsize{2.5 points}}

Dans un texte structur\'e, d\'ecrivez les principes fondamentaux autour
desquels le noyau \name{NT} a \'et\'e con\c{c}u. En particulier, vous
\'enoncerez de mani\`ere claire les probl\'ematiques cibl\'ees par ce type de
noyau, puis vous mettrez l'accent sur les r\'eponses apport\'ees par \name{NT}
et son design.

Lorsque cela s'av\`ere pertinent, vous incluerez des d\'etails d'implantation.
\`A titre d'exemple, des comparaisons pourront \^etre faites avec d'autres
noyaux existants, tels que \name{Linux}.

\begin{correction}

Le noyau \name{NT} est con\c{c}u et d\'{e}velopp\'{e} au d\'{e}but des ann\'{e}es
1990 par une \'{e}quipe dirig\'{e}e par \name{Dave Cutler} (\name{DEC, VMS}). C'est
un noyau monolithique qualifi\'{e} par certains d'hybride du fait de la communication
par messages entre les drivers. Tous les drivers partagent le m\^{e}me espace d'adressage,
ce qui le diff\'{e}rencie donc d'un micronoyau. Le choix d'une communication par message
r\'{e}pond ainsi \`{a} une probl\'{e}matique de modularit\'{e}, et non d'isolation.

Depuis sa cr\'{e}ation, les aspects fondamentaux du noyau n'ont pas chang\'{e}
malgr\'{e} l'\'{e}volution des architectures: passage au multiprocesseur, multiplication
des resources \`{a} g\'{e}rer (plus de devices, plus de fichiers ouverts)... Ceci est
en quelque sorte la preuve de la flexibilit\'{e} du design, qui s'articule autour des
points suivants:

\begin{itemize}
  \item
    Mod\`{e}le d'IO asynchrones: le noyau g\`{e}re toutes les IOs de mani\`{e}re
    asynchrone. De ce fait, l'appel \`{a} une fonction synchrone (ie. \name{WriteFile})
    est implement\'{e} par dessus ce mod\`{e}le. L'int\'{e}r\^{e}t principal d'un
    mod\`{e}le asynchrone est de permettre l'ex\'{e}cution de code li\'{e} au cpu
    (\name{cpu bound}) en parall\`{e}le de l'attente de la completion d'une IO
    (\name{io bound}). Par exemple, une solution de chiffrement peut maintenir une liste
    de donn\'{e}es \`{a} chiffrer dans l'attente de la compl\'{e}tion d'une IO. On a de
    cette mani\`{e}re une progression globale du syst\`{e}me.
  \item
    Mod\`{e}le de thread 1:1: Chaque thread utilisateur est repr\'{e}sent\'{e} par
    un thread noyau. Puisque la programmation multithread\'{e}e est un mod\`{e}le
    largement adopt\'{e} par les programmeurs, un mapping 1:1 permet de gagner en
    performance en \'{e}vitant \`{a} un processus d'\^{e}tre bloqu\'{e} par un
    thread dans l'attente de la compl\'{e}tion d'une IO.
  \item
    Mod\`{e}le orient\'{e} objet: Toute resource est manipul\'{e}e par le noyau
    via une interface commune, celle d'objet. Cette interface comprend entre autre
    les proc\'{e}dures d'ouverture, de fermeture et de securit\'{e}. Chaque type de
    resource a un objet correspondant: \name{FILE\_OBJECT}, \name{DEVICE\_OBJECT},
    \name{DRIVER\_OBJECT} ... Un programme utilisateur manipule tous les objets
    par \name{HANDLE}.
  \item
    Le gestionnaire d'objet (\name{Object Manager}) centralise les aspects fondamentaux
    li\'{e}s \`{a} la gestion des resources, \`{a} savoir:
    \begin{itemize}
      \item
      Le nommage: la r\'{e}cup\'{e}ration d'une resource \`{a} partir d'un nom. Ce
      nom est structur\'{e} de la m\^{e}me fa\c{c}on qu'un chemin dans un syst\`{e}me
      de fichier. Il y a en g\'{e}n\'{e}ral un r\'{e}pertoire par type de resource,
      et les liens symboliques sont support\'{e}s. C'est de cette facon qu'une lettre
      (ie. \name{C:}) peut \^{e}tre li\'{e}e \`{a} un volume (ie. \name{/Device/HarddiskVolume0}).
      \item
      La recherche: la r\'{e}cup\'{e}ration de l'instance d'une resource \`{a} partir
      d'un \name{HANDLE}.
      \item
      la s\'{e}curit\'{e}: lorsqu'un processus utilisateur effectue une operation sur
      un objet (ie. ReadFile), le noyau doit valider cette operation. Pour ce faire,
      la proc\'{e}dure de s\'{e}curit\'{e} associ\'{e}e au type d'objet sera invoqu\'{e}e,
      et cela quel que soit le type d'objet. La fonction document\'{e}e est
      \name{ObReferenceObjectByHandle}. Cela permet une gestion du contr\^{o}le d'acc\`{e}s
      centralis\'{e}e et coh\'{e}rente, ce qui n'est pas le cas dans \name{Linux}.n
    \end{itemize}
  \item
    Mod\`{e}le de driver en stack: Pour permettre l'interaction entre les differents
    periph\'{e}riques, le noyau organise les drivers sous la forme de stack selon leur
    relation. \`{A} cette fin, le gestionnaire d'IO expose deux primitives:
    \begin{itemize}
      \item
      Une structure d\'{e}crivant les messages: \name{IRP} (Interrupt Request Packet),
      \item
      Une fonction de message passing: \name{IoCallDriver}.
    \end{itemize}
    De cette mani\`{e}re, des interactions dynamiques complexes peuvent etre modelis\'{e}es:
    solutions de stockage, chiffrement de disque, piles r\'{e}seau, syst\`{e}mes de fichier
    virtuels ...
    Ce mod\`{e}le permet \`{a} des drivers propri\'{e}taires de cohabiter, pour autant que
    chacun respecte l'ensemble des conventions impos\'{e}es, telles que le routage des
    messages aux drivers sous jaccents ansi que leur compl\'{e}tion.
\end{itemize}

Aussi, il est important de noter la qualit\'{e} du kit de d\'{e}vloppement de driver pour
\name{NT} (ie. \name{Windows Driver Kit}), ainsi que les outils associ\'{e}s: injection de
faute, analyse dynamique d'erreurs communes lors de la conception d'un driver...

\end{correction}

\end{document}
