%
% ---------- header -----------------------------------------------------------
%
% project       kaneton
%
% license       kaneton
%
% file          /home/mycure/kaneton/view/exam/mips/2008/mid/mid.tex
%
% created       julien quintard   [mon may 14 21:47:30 2007]
% updated       julien quintard   [mon apr 28 11:48:33 2008]
%

%
% path
%

\def\path{../../../..}

%
% template
%

\input{\path/template/exam.tex}

%
% header
%

\lhead{\scriptsize{2008}}

%
% title
%

\title{Examen d'Architecture des Microprocesseurs}

%
% authors
%

\author{\small{Julien Quintard}}

%
% document
%

\begin{document}

%
% title
%

\maketitle

%
% --------- information -------------------------------------------------------
%

\begin{center}

\textbf{Documents Autoris\'es}

\textbf{Dur\'ee 1 heure 30 minutes}

\scriptsize{Une copie bien pr\'esent\'ee avec des sch\'emas propres et
	    lisibles sera toujours mieux not\'ee qu'une autre.}

\end{center}

%
% --------- text --------------------------------------------------------------
%

%
% assembleur
%

\section{Assembleur - 6 points}

Pour cet exercice nous consid\'erons un processeur pipeline comme celui
\'etudi\'e en cours. N\'eanmoins les d\'ependances entre instructions
n'existent pas pour cet exercice. Autrement dit, pour cet exercice,
le CPI est \'egal \`a 1 dans tous les cas.

Veuillez \'ecrire le code assembleur optimis\'e de la fonction
\texttt{postillon()}\footnote{M\'ELANGE DE VINS DE DIFF\'ERENTS
                     PAYS DE LA COMMUNAUT\'E EUROP\'EENNE.}
qui effectue une copie de chaine de caract\`eres de la m\^eme
mani\`ere\footnote{Mis \`a part que le nom de la fonction a
                   beaucoup plus de style!}
que la fonction \texttt{strncpy()} de la biblioth\`eque C.

Puis \'evaluer les performances de votre code assembleur pour une chaine
de caract\`eres de longueur $N$ en calculant le nombre de cycles moyen
n\'ecessaire \`a l'ex\'ecution de votre fonction. Il pourra \^etre utile
de dissocier, pour le calcul des performances, les deux situations dans
lesquelles le processeur peut sortir de la boucle.

\`A noter que votre tr\`es respectable enseignant a r\'eussi, certes apr\`es
quelques heures de reflexions, \`a \'ecrire un code assembleur ne contenant que
$6$ instructions dans le boucle.

\begin{verbatim}
char*           postillon(char* dst, const char* src, unsigned int size)
{
  int           i;

  for (i = 0; i < size && src[i]; i++)
    dst[i] = src[i];
  dst[i] = 0;

  return (dst);
}
\end{verbatim}

Un code assembleur complet\footnote{... pas simplement la boucle.} avec une
\'equivalence C en commentaire de fin de ligne sera appr\'eci\'e.

\begin{correction}

  \begin{verbatim}
           Lw R5, 0(R29)                     ; dst
           Lw R6, 4(R29)                     ; src
           Lw R7, 8(R29)                     ; size

           Add R2, R0, R5                    ; R2: dst

           Add R16, R6, R7                   ; R16: pointeur fin de chaine

  Loop:    Lb R10, 0(R6)                     ; R10: *src

           Addiu R6, R6, 1                   ; src++

           Beq R10, R0, EndLoop              ; if (*src == '\0') goto EndLoop
           Sb R10, 0(R5)                     ; *dst = *src

           Bne R6, R16, Loop                 ; if (src != R16) goto Loop
           Addiu R5, R5, 1                   ; dst++

  EndLoop: Jr R31
           Nop
  \end{verbatim}

  Si $N < size$:

  \begin{center}
    \begin{eqnarray*}
      P & = & 5 + (6N + 4) + 2 \\
        & = & 11 + 6N
    \end{eqnarray*}
  \end{center}

  Si $N \geq size$

  \begin{center}
    \begin{eqnarray*}
      P & = & 5 + 6size + 2 \\
        & = & 7 + 6size
    \end{eqnarray*}
  \end{center}

\end{correction}

%
% vue simplifiee
%

\section{Vue simplifi\'ee - 4 points}

Dans cet exercice nous consid\'erons le microprocesseur pipeline $5$ \'etages
\'etudi\'e en cours incluant les d\'ependances entre instructions.

Veuillez, pour la boucle principale de votre fonction \texttt{postillon()},
d\'ecrire le pipeline en utilisant une vue simplifi\'ee.

Veuillez indiquer sur cette m\^eme vue simplifi\'ee les \textit{bypasses}
utilis\'es entre les instructions d\'ependantes.

Puis \'evaluer les performances de votre boucle en calculant le CPI et CPI
utile.

\begin{correction}

  \begin{center}
    \includegraphics[scale=0.8]{figures/correction-vue-simplifiee.pdf}

    \begin{math}
      CPI = \frac{7}{6}
    \end{math}

    \begin{math}
      CPIu = \frac{7}{6}
    \end{math}
  \end{center}

\end{correction}

%
% vue detaillee
%

\section{Vue D\'etaill\'ee - 6 points}

Veuillez d\'ecrire, via une vue d\'etaill\'ee, le pipeline pour la s\'equence
d'instructions suivantes:

\begin{verbatim}
Sll R4, R3, 2
Add R5, R4, R0
\end{verbatim}

Il vous est demand\'e de mettre en \'evidence les \textit{bypasses} utilis\'es
pour g\'erer les d\'ependances entre instructions.

Un sch\'ema clair sera tr\`es appr\'eci\'e notamment via l'utilisation
de diff\'erentes couleurs.

%
% questions de cours
%

\section{Questions de Cours - 4 Points}

\begin{enumerate}
  \item
    Consid\'erons l'ajout de l'instruction suivante:
    \texttt{Corbier Rt, Rs, I}.

    Imaginons que cette instruction puisse se coder dans deux formats
    d'instruction diff\'erents, \textbf{R} et \textbf{I}.

    En tant que concepteur du processeur RISC MIPS R3000, quel
    format choisireriez-vous pour l'instruction \texttt{Corbier} et pourquoi?

    \begin{correction}

      Puisque en tant que concepteurs nous avons le choix pour l'instruction
      \texttt{Corbier} entre le format \textbf{R} et le format \textbf{I};
      nous allons sans aucun doute choisir le format \textbf{R} car celui-ci
      dispose d'un champ d'extension d'opcode.

      Pour \'economiser les opcodes il nous faut donc utiliser au maximum
      le format \textbf{R} d\`es que possible.

    \end{correction}
  \item
    Dans quel cas $Immediate * 4$ et $Immediate << 2$ ne peuvent pas \^etre
    utilis\'es de la m\^eme mani\`ere?

    \begin{correction}

      Lorsque $Immediate$ est sign\'e.

    \end{correction}
  \item
    Pourquoi pensez vous que l'instruction \texttt{Nori} n'existe pas dans
    le jeu d'instructions.

    \begin{correction}

      Tout simplement parceque cette op\'eration peut \^etre effectu\'ee
      via d'autres instructions.

      Les concepteurs du processeur MIPS, en utilisant les MIXs et la
      loi d'Amdhal se sont rendus compte que cette instruction n'\'etait
      pas rentable et ne l'ont donc pas incluse dans le jeu d'instructions
      du microprocesseur.

      \`A noter que l'instruction \texttt{Nori Rt, Rs, I} peut
      \^etre effectu\'ee via les instructions suivantes:

      \begin{verbatim}
        Addiu Rd, R0, I
        Nor Rd, Rs, Rt
      \end{verbatim}

    \end{correction}
  \item
    Pourquoi l'instruction \texttt{Oriu} n'a pas de sens contrairement
    \`a l'instruction \texttt{Addiu}.

    \begin{correction}

      Tout simplement parceque l'instruction \texttt{Add} est une
      op\'eration arithm\'etique et peut donc s'utiliser avec des
      imm\'ediats sign\'es ou non.

      En revanche, l'instruction \texttt{Oriu} n'a aucun sens puisque
      l'instruction \texttt{Or} est une op\'eration logique. De ce fait
      l'imm\'ediat sera toujours consid\'er\'e comme non sign\'e.

      L'ajout du suffixe \textbf{u} n'a donc aucun sens pour cette instruction.

    \end{correction}
\end{enumerate}

\end{document}
