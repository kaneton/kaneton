#
# ---------- header -----------------------------------------------------------
#
# project       kaneton
#
# license       kaneton
#
# file          /home/mycure/kaneton/env/profile/profile.conf
#
# created       julien quintard   [mon may  7 20:33:41 2007]
# updated       julien quintard   [tue may  8 19:55:31 2007]
#

#
# ---------- information ------------------------------------------------------
#
# this file does not contain any configuration variable but instead
# briefly describe the configuration files organisation and syntax.
#

#
# the kaneton environment development aims at providing an easy and portable
# way for managing the kaneton microkernel project from a development point
# of view. therefore, the kaneton environment provides everything necessary
# for compiling, assembling, etc.. these tasks highly rely on the underlying
# running operating system as well as for the kaneton microkernel's target
# processor. moreover, the user could need to redefine some behaviours
# depending on its personal operating system configuration to use a
# specific C compiler for example.
#
# the kaneton development environment provides a layered organisation of
# profiles, each profile defining variables and functions used by the
# final environment engine. the goal of the layered model is to allow
# layers to override the definitions of lower layers.
#
# a configuration is composed of profiles including environment profile,
# kaneton profile and user profile. each profile can be composed of
# sub-profiles. user's shell variables are used to get access to the
# correct profiles and sub-profiles.
#
# let us start with the configuration of the microkernel with the kaneton
# profile. the KANETON_PLATEFORM and KANETON_ARCHITECTURE define the plateform
# and architecture sub-profiles respectively. these sub-profiles are part of
# the kaneton profile which describes the behaviour of the kaneton microkernel.
# then these profile and sub-profiles are usually used to parameterise
# the core and its plateform- and architecture-dependent parts.
#
# the environment profile is essentially composed of a behaviour sub-profile
# which describes how to perform the basic tasks: compiling, assembling,
# changing the current directory, displaying a message etc.. these tasks
# rely on the operating system currently running as well as on the
# target processor on which kaneton will be built for. for these reasons,
# there are several behaviour sub-profile. moreover, the C compiler binary
# file for building object files for PPC microprocessors will be different
# on a Linux operating system running over a Intel processor and on another
# Linux operating system running over a PPC processor. as a result, the
# host machines must be distinguished not only from the operating system
# but also from the microprocessor. for these reasons, the KANETON_HOST
# shell variable is used to identify a behaviour sub-profil. this shell
# variable is composed of two parts separated by a slash sign: the host
# operating system and the host microprocessor. if the microprocessor part
# is not precised, then the behavious is assumed to run and build object files
# running on the same processor. here are some examples of this KANETON_HOST
# variable: linux, linux.ppc, macosx.ia32, sunos.sparc64, bsd etc..
# in addition to that, each behaviour sub-profile can be extended by another
# architecture sub-profile for defining or re-defining variables and functions
# depending on the target architecture. this other sub-profile is accessed
# by the KANETON_ARCHITECTURE shell variable.
#
# note that the possibility to include files in the configuration syntax
# allows very similar behaviours to share a huge amount of definitions.
#
# the KANETON_USER variable defines the name of the user profile which
# describes the specific user behaviour.
#

#
# the kaneton environment engine first get all variable and function
# declarations and then process them following the layer ordering described
# below:
#
#   profile/							[lowest layer]
#   profile/environment
#   profile/environment/behaviour
#   profile/environment/behaviour/${KANETON_HOST}
#   profile/environment/behaviour/${KANETON_HOST}/${KANETON_ARCHITECTURE}
#   profile/kaneton
#   profile/kaneton/core
#   profile/kaneton/plateform
#   profile/kaneton/plateform/${KANETON_PLATEFORM}
#   profile/kaneton/architecture
#   profile/kaneton/architecture/${KANETON_ARCHITECTURE}
#   profile/user
#   profile/user/${KANETON_USER}				[highest layer]
#
# in this layered model, a variable defined in, for instance, behaviour can
# be overriden anywhere in the sub-layers including kaneton, kaneton/plateform,
# but also kaneton/architecture/${KANETON_ARCHITECTURE}, user etc..
#
# the environment and kaneton profiles are theoretically completed separated.
# however, the environment engine does not check such overridings, therefore
# the core configuration could override a variable previously defined in
# the behaviour profile.
#
# finally, the user profile can override any other definition.
#

#
# the environment engine looks in each profile for files suffixed by:
#   .desc: these files describe the variables defined by this profile
#   .conf: these files declare the variable defined by this profile
#   .mk: these files declare the make functions of this profile
#   .py: these files declare the python functions of this profile
#
# the engine supposes that there is no variable or function overriding in
# a single profile. more precisely, if there are more than a single
# configuration file in a directory, the engine cannot guarantee anything
# on the order these files will be processed. as a resultat, the overridings
# could differ depending on the processing order.
#

#
# the .mk and .py files must provide the whole make and python interface,
# respectively, but can also contain additional private functions.
#
# the configuration files .conf contain the variables declarations.
# the syntax of these files is explain below:
#
# to assign a value to a variable named VAR or override a previously
# defined variable VAR:
#
#   VAR = a value
#
# to complete a variable definition by appending something to a previously
# defined value:
#
#   VAR += a value which is appended to the previous VAR's content
#
# shell variables and environment variables can also be used. then a
# kaneton variable i.e. a variable defined by a lower layer is accessed
# like this:
#
#   VAR = something from ${ANOTHER_VAR}
#
# shell variables can also be accessed using parentheses instead of braces:
#
#   VAR = the shell currently used is $(SHELL)
#
# finally a configuration file can include another one using the following
# construct:
#
#   include ../an/other/file/far/../far/../away
#
# this is very useful to concentrate the definitions common to multiples
# sub-profiles in a single location.
#
# the description files .desc describe the variables contained in the
# configuration files .conf. The syntax of such descriptions files are
# explained next.
#
# each variable description is contained in a section which is enclosed
# between braces. a section contains specific fields which need to be
# defined.
#
# VAR
# {
#   [entry] an example variable
#
#   [type] state | set | any
#   <value1> a first possible value
#   <value2> another possible value
#
#   [description]
#   and then a description of the variable which will be displayed
#   in the configuration software.
# }
#
# in this syntax, the first token is the name of the variable, for instance,
# VAR. then, the name of the entry displayed in the configuration software
# is specified with the [entry] field.
#
# then, the [type] field specify the type of value the variable can take.
# 'state' stands for a binary state. in this case, there should only be
# two <> fields. 'set' stands for an unbounded number of values which are
# then specified between angle brakets. finally 'any' stands for any
# free value. in this case, no <> field should be specified.
#
# the value fields are composed of two parts. the first one between angle
# brakets define the value which will be stored in the variable if this
# option is used. the following part is the literal string displayed in
# the configuration software.
#
# finally, the [description] field contains the remaining text which is
# considered as a description of the variable. this description is very
# important to the end-user so it should always be provided.
#
