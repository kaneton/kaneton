#
# ---------- header -----------------------------------------------------------
#
# project       kaneton
#
# license       kaneton
#
# file          /home/mycure/kaneton/env/profile/profile.conf
#
# created       julien quintard   [mon may  7 20:33:41 2007]
# updated       julien quintard   [wed may  9 09:32:14 2007]
#

#
# ---------- information ------------------------------------------------------
#
# this file does not contain any configuration variable but instead
# briefly describe the configuration files organisation and syntax.
#

#
# the kaneton environment development aims at providing an easy and portable
# way for managing the kaneton microkernel project from a development point
# of view. therefore, the kaneton environment provides everything necessary
# for compiling, assembling, etc.. these tasks highly rely on the underlying
# running operating system as well as for the kaneton microkernel's target
# processor. moreover, the user could need to redefine some behaviours
# depending on its personal operating system configuration to use a
# specific C compiler for example.
#
# the kaneton development environment provides a layered organisation of
# profiles, each profile defining variables and functions used by the
# final environment engine. the goal of the layered model is to allow
# layers to override the definitions of lower layers.
#
# a configuration is composed of profiles including environment profile,
# kaneton profile and user profile. each profile can be composed of
# sub-profiles. user's shell variables are used to get access to the
# correct profiles and sub-profiles.
#
# let us start with the configuration of the microkernel with the kaneton
# profile. the KANETON_PLATEFORM and KANETON_ARCHITECTURE define the plateform
# and architecture sub-profiles respectively. these sub-profiles are part of
# the kaneton profile which describes the behaviour of the kaneton microkernel.
# then these profile and sub-profiles are usually used to parameterise
# the core and its plateform- and architecture-dependent parts.
#
# the environment profile is essentially composed of a behaviour sub-profile
# which describes how to perform the basic tasks: compiling, assembling,
# changing the current directory, displaying a message etc.. these tasks
# rely on the operating system currently running as well as on the
# target processor which kaneton will be built for. for these reasons,
# there are several behaviour sub-profiles.
#
# suppose we are running a Linux operating system and that kaneton will be
# built for running on a PPC microprocessor. in such a case, the C compiler
# binary will be different depending on the microprocessor Linux is running
# on. indeed, if Linux is running on a PPC microprocessor, then using the
# default compiler should produce PPC object files. this is the common way.
# on the other hand, it Linux is running on a different microprocessor, then
# a cross-compiler must be used to produce binary objects targeting another
# specific processor architecture.
#
# to avoid this issue, a behaviour sub-profile name is composed of two parts
# separated by a slash. the first part is the name of the operating system and
# the last one is a pair source and target processors separated by a dot.
# for example, linux/ia32.ppc names a behaviour running the Linux operating
# system on a Intel 32-bit processor which aims at building a kaneton
# microkernel for the PPC processor target architecture. needless to say
# that linux/ia32.ia32 represents a non cross-compiling environment.
#
# to avoid configuration duplications, it is common to see the configuration
# file of the behaviour profile to include files of the parent directory
# as shown below:
#
#   linux/
#     linux.desc			[these four files are not directly
#     linux.conf			 used by the kaneton environment
#     linux.mk				 engine and describe the classical
#     linux.py				 Linux operating system behaviour]
#     ia32.ia32/
#       virtual -> .			[these symbolic links are used to
#       optimised -> .			 ignore the specific architecture
#       smp -> .			 part]
#       ia32.desc -> ../linux.desc
#       ia32.conf -> ../linux.conf
#       ia32.mk -> ../linux.mk
#       ia32.py -> ../linux.py
#     ia32.mips64/
#       mips64.desc			[redefines the _CC_ variable to point
#       mips64.conf			 to the mips64-target-specific
#       mips64.mk			 compiler]
#       mips64.py
#
# to conclude, the behaviour sub-profile is accessed by the following
# construct:
#
#   profile/behaviour/${KANETON_HOST}/${KANETON_ARCHITECTURE}
#
# with, for instance, the following values:
#
#   KANETON_HOST = linux/ia32
#   KANETON_ARCHTECTURE = ia32/virtual
#
# note that the possibility to include files in the configuration syntax
# allows very similar behaviours to share a huge amount of definitions.
#
# the KANETON_USER variable defines the name of the user profile which
# describes the specific user behaviour.
#

#
# the kaneton environment engine first get all variable and function
# declarations and then process them following the layer ordering described
# below:
#
#   profile/							[lowest layer]
#   profile/environment
#   profile/environment/behaviour
#   profile/environment/behaviour/${KANETON_HOST}/${KANETON_ARCHITECTURE}
#   profile/kaneton
#   profile/kaneton/core
#   profile/kaneton/plateform
#   profile/kaneton/plateform/${KANETON_PLATEFORM}
#   profile/kaneton/architecture
#   profile/kaneton/architecture/${KANETON_ARCHITECTURE}
#   profile/user
#   profile/user/${KANETON_USER}				[highest layer]
#
# in this layered model, a variable defined in, for instance, behaviour can
# be overriden anywhere in the sub-layers including kaneton, kaneton/plateform,
# but also kaneton/architecture/${KANETON_ARCHITECTURE}, user etc..
#
# the environment and kaneton profiles are theoretically completed separated.
# however, the environment engine does not check such overridings, therefore
# the core configuration could override a variable previously defined in
# the behaviour profile.
#
# finally, the user profile can override any other definition.
#

#
# the environment engine looks in each profile for files suffixed by:
#   .desc: these files describe the variables defined by this profile
#   .conf: these files declare the variable defined by this profile
#   .mk: these files declare the make functions of this profile
#   .py: these files declare the python functions of this profile
#
# the engine supposes that there is no variable or function overriding in
# a single profile. more precisely, if there are more than a single
# configuration file in a directory, the engine cannot guarantee anything
# on the order these files will be processed. as a resultat, the overridings
# could differ depending on the processing order.
#

#
# the .mk and .py files must provide the whole make and python interface,
# respectively, but can also contain additional private functions.
#
# the configuration files .conf contain the variables declarations.
# the syntax of these files is explain below:
#
# to assign a value to a variable named VAR or override a previously
# defined variable VAR:
#
#   VAR = a value
#
# to complete a variable definition by appending something to a previously
# defined value:
#
#   VAR += a value which is appended to the previous VAR's content
#
# shell variables and environment variables can also be used. then a
# kaneton variable i.e. a variable defined by a lower layer is accessed
# like this:
#
#   VAR = something from ${ANOTHER_VAR}
#
# shell variables can also be accessed using parentheses instead of braces:
#
#   VAR = the shell currently used is $(SHELL)
#
# finally a configuration file can include another one using the following
# construct:
#
#   include ../an/other/file/far/../far/../away
#
# this is very useful to concentrate the definitions common to multiples
# sub-profiles in a single location.
#
# the description files .desc describe the variables contained in the
# configuration files .conf. The syntax of such descriptions files are
# explained next.
#
# each variable description is contained in a section which is enclosed
# between braces. a section contains specific fields which need to be
# defined.
#
# VAR
# {
#   [entry] an example variable
#
#   [type] state | set | any
#   <value1> a first possible value
#   <value2> another possible value
#
#   [description]
#   and then a description of the variable which will be displayed
#   in the configuration software.
# }
#
# in this syntax, the first token is the name of the variable, for instance,
# VAR. then, the name of the entry displayed in the configuration software
# is specified with the [entry] field.
#
# then, the [type] field specify the type of value the variable can take.
# 'state' stands for a binary state. in this case, there should only be
# two <> fields. 'set' stands for an unbounded number of values which are
# then specified between angle brakets. finally 'any' stands for any
# free value. in this case, no <> field should be specified.
#
# the value fields are composed of two parts. the first one between angle
# brakets define the value which will be stored in the variable if this
# option is used. the following part is the literal string displayed in
# the configuration software.
#
# finally, the [description] field contains the remaining text which is
# considered as a description of the variable. this description is very
# important to the end-user so it should always be provided.
#
