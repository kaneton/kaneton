--
 questions k1, kaneton:
   - a quoi sert machdep_data()
   - comment fonctionne le systeme d'appel de la partie dependante
   - 

--
 k3: rapport de modelisation sur les events

 ce serait une bonne idee car c'est relativement simple et en meme temps
 ca demande de la reflexion vu que c'est proche de l'archi.

--
 pour le probleme de dependance entre segments et malloc() il suffit d'avoir
 un cache d'objets segment dans le manager de segment. et le segment
 manager pioche dedans pour ajouter des segments. donc set_reserve()
 sans l'option ALLOC.

 il suffit de calculer la limite d'appels recursifs a segment et d'en
 deduire la taille du cache, par exemple 3, pour etre sur disons 5.

--
 Pour kaneton.pdf utiliser la template paper.tex OU en faire
 une nouvelle genre book.

 baisser la taille de police et eviter tout ce qui est \\ \vspace \hspace etc..
 car ca rend le code latex illisible.

--
 checker le bootloader, les regions puent du cul j'ai du me planter.
 revoir aussi la gestion des pt en interne. coder la surcouche map_reserve,
 ca pourra clarifier le code. *chiche*

--
 check as & co: en fait c debile de les mettre dans check/arch, il faudra les
 deplacer dans check/core/kaneton

--
 check bootloader: adapter le test 03 : jme suis goure dans l'assignments.
 donc faire un cas special pr cette fois et modifier assignments pour l'an
 prochain

--
 revoir segment : acces direct (read/write) et resize + split (regions).

--
 les images microkernel_examples_* dans seminar sont a passer au format xfig

--
 le cours intel a integrer a la tarball

--
 a la limite integrer l'option k des inge1 a la tarball kaneton

--
 il faut revoir set_locate_array pour les tableaux tries. il y a un bug.

--
 inventaire des fonctions a terminer :
  - as_clone
  - as_vaddr
  - ia32_region_release
  - ia32_as_release/flush  <<	pas sur qu'on libere les page tables
  - gdt_import 		<< eventuellement la virer
  - ldt_get_segment

 revoir aussi core/kaneton/debug/*, c'est un peu crade.

 peut etre changer les noms dans libia32 : t_segment -> o_ia32_segment

 revoir la klibc il y a beaucoup de XXX dedans.

--
 vraiment reflechir a un systeme de nommage. genre open(path) va en realite
 appeler vfs. lui il sait qu'il gere des FS donc il va demander au service
 de nom de chercher l'objet fs::path. l objet peut se trouver n importe
 ou peut etre sur une autre machine dans un fs distribue bref.

 et donc ensuite vfs recupere le chemin vers cet objet et fait une
 ouverture en envoyant un message au service/groupe qui gere cet objet.

 de plus grace a ce systeme il sera inutile de fournir une lib par
 service pour que le caller sache comment utiliser le service.

 la le caller demande juste au name server: "je cherche un service
 qui s'appelle surement comme ca, qui a telle version et qui fournit
 ca".

 de plus preciser que les capabilities sont generees par les servers
 de par leurs natures specifiques a chaque serveur mais que l'on
 pourrait egalement fournir une lib de gestion de capability par
 serveur. mais cette solution est trop inelegante pour etre utilisee
 dans kaneton. neanmoins elle fournirait de meilleur performance
 mais la frequence de generation de capability n'en vaut pas
 la chandelle.

--
 utiliser le programme sloccount pour compter le nombre de LOC
 de kaneton:

   MINIX 2.0.4: 20 000
   MINIX 3.0.0: 7 500
   MACH 3.0: 75 000

--
 fournir les meme fonctionalites que sleep/wakeup d'unix mais pour des
 process. ce serait utile genre un thread fait une operation et s'endort
 car elle attend de timeout. l autre thread recoit le message de timeout
 et reveille l autre thread.

--
 prevoir une surcouche au dessus de segment et region pour simplifier
 la vie de tout le monde genre: map_reserve(size) -> {segment,region}_reserve()

--
 pour eviter les deadlocks on autorisera uniquement les messages
 asynchrone partant du kernel. ca va bien avec ce que je pensais et de
 toute facon c'est seulement ce dont on a besoin donc ca bande.

--
 retoucher la moulinette et virer le script parse_res.py. revoir
 aussi pour le systeme de loading de modules.

 peut etre meme revoir en general la moulinette.

--
 creer un service monitor lance en premier apres mod qui recevra des
 messages du kernel comme par exemple: les messages de debug du kernel
 et des dumps etc..

--
 plutot que de faire un systeme de errno, et puisque toute la communication
 se fait par messages on pourrait imaginer que le message d'erreur (s'il
 existe se trouve dans la reponse) comme ca quand on fait un appel a une
 fonctinnalite d une autre machine sans trop savoir ce que le service
 de cette machine fournit on peut avoir des infos sur les erreurs.

--
 il faut prevoir que tout le demarrage des services via fichier de conf
 doit pouvoir etre fait en dynamique. par exemple si mod reserve un
 segment special (CATCH) pour le service tty (console) et bien il faut
 imaginer que si on lance ce meme serveur a la main une fois le systeme
 boote, soit le systeme de lui meme (via un fichier de conf) sait quels
 sont les objets dont il herite ou alors il faut prevoir des messages style
 segment_acquire() pour acquerir un segment specifique: la memoire video.

--
 envoye un message shutdown pour killer proprement une task.

--
 on pourrait imaginer que chaque service/driver accepte un message de type
 UPDATE et envoie sa capability task si jamais l'appellant est de confiance.

 de cette maniere on pourrait imaginer un service update qui enverrai
 UPDATE des qu une nouvell version d'un programme tournant existe. ainsi
 le service update stoppe la tache en question temporairement a un endroit
 precis et par exemple met a jour le code dynamiquement. c est complique
 mais ce serait pas mal.

--
 remarques sur le cours:

   le tout premier cours de remise a niveau devrait a lui seul durer presque
   3h tellement il faut tout revoir, espace d'adressage, adresses memoire,
   stack etc..: vraiment aborder, memoire physique, memoire virtuelle,
   mapping, bien insister mask bits, decalage, set, unset, align etc..
   aborder egalement brievement l adressage, le ELF: bss, data, rodata etc..

--
 Antoine Castaing, Nicolas Clermont et Damien Laniel.

 Nicolas Clermont a ete pris en stage de fin d'annee chez EADS
 dans un departement de developement de micronoyau embarque.

 leur demander leurs bookmarks, et dire que quand meme kaneton
 ca peut servir pour les gens que ca interesse vraiment.

--
 je crois qu il y a une solution pour l'auth de messages.

 un client A demande le droit d'envoye un msg a un autre B. le server
 auth accepte. celui ci demande au kernel (via une capability que seul lui
 detient) une capability de message pour A vers B. le kernel l'envoie donc
 au server auth. et ce dernier retransmet cette cap au client qui l'utilisera
 pour communiquer.

 au final il n y a pas de duplication de cap puisque seul les kernels les
 a. de plus le serveur auth peut tjs faire tourner des algos de detections
 d'abus, blacklist etc.. puisqu il sait quand meme qui a le droit de
 communiquer avec qui.

 ca bande!

 les cap ca defonce tout...

 a noter que Mach fournit la primitive send_one() utilise pour les RPC
 pour autoriser l envoi d'un seul message. a etudier!

 Mach est bcp d'autres utilise un systeme de port mais aussi un ensemble
 de ports. comme ca un serveur attend que sur un port et recoie une categorie
 de messages.

 pour kaneton on peut imaginer un truc similaire mais d'une autre maniere.

--
 definitivement:

  Amoeba: n'utilise pas de memoire virtuelle.
  V distributed system (Stanford Cheriton): toute communication par RPC
    (ca doit etre vachement lourd) de plus pas de notion de port mais
    on nomme le processus destination

  kaneton: toute communication par message meme sur le systeme distribue.
    on nomme egalement le process/groupe destination

 pour kaneton on utilisera une communication style MPI soit direct une
 lib existante soit on en refait une.

--
 region:
  * pouvoir mapper des parties de segment. revoir le proto de reserve.
   * voir pr l'union adresse / i
   * vtop et ptov
 tests:
  * changer les tests des sets pour plus considerer l'ordre

--
 virer tout affichage autre que warning et erreur dans le bootloader
 de sorte qu'on n'ait plus de structure t_cons dependante a passer

 include/arch/ia32-virtual/kaneton/init.h

--
 reiterer le coup du sondage sur les cours, le projet etc..

--
 pour tester la moulette avec un seul pc : QEMU, avec l'option "-serial pty"
 et changer en dur le device dans check.py.

--
 nettoyer conf.h, debug.h, check.h rendre tout ca coherent car la c'est
 un peu le bordel.

--
 peut etre devrait on penser les regions un peu plus pour tout faire avec:
  swap/paging etc..

--
 dans segment et surement dans d'autres: as, task, region

 on fait dans clean() un foreach ( segment_release ) c'est tres
 dangereux car l'iterator n'est pas sur d'etre correct. il faudrait
 changer ca et faire plutot un while (set_head) { segment_release }

--
 dans doc papers diviser par categories et faire que chaque personne
 qui lit ecrit un resume

--
 hevea -exec xxdate.exe kaneton.tex pour generer du html

 latex -> html: HeVeA

 ca aurait ete bien un make web mais bon c'est mort.

--
 as + thread => domain (sprite)

 machines proches forment des villages

--
 definir une interface pour les drivers de sorte qu'ils soient portable
 tres facilement, qu'ils ne fassent que des entree sorties. dans l'interface
 on fournira le systeme de communication + gestion des structures de donnees.

 a etudier!

--
 le systeme pue. si on fait un systeme hierarchique alors on pourra
 JAMAIS allouer un segment, une tache ou autre chose sur une autre machine
 sauf en passant pas un service supplementaire migrate par exemple.

 de plus il faut trouver un systeme pour liberer les objets allouer:

  1) systeme de time to live
       il faudrait checker tout le temps si un objet n'est plus utilise
       donc on aura 1 timer par objet. ce n'est donc pas envisageable.
       trop lourd, complique, lent.
  2) systeme de garbage collecting
       un peu dans le meme principe donc pas possible non plus.
  3) listing des objets alloues dans le kernel/server pour la desallocation
  4) listing des objets alloues dans le processus

 exemple:
   une tache alloue de la memoire partagee au groupe de memoire partagee
   donc la memoire est peut etre allouee sur une autre machine. si la
   tache meurt, elle DOIT prevenir les servers/groupes qui lui ont filer
   des objets dans notre cas on doit prevenir le groupe de memoire partagee
   de liberer la memoire.

   comment faire?

 1) on broadcast le fait qu'on est mort
 2) on envoie un message a chaque server a qui on a reserver un objet
    donc ca necessite de maintenir une liste de ces servers.

 attention: probleme de securite, il ne faut pas que quelqu'un se fasse
            passer pour nous et broadcast ce message.

 il reste deux solutions.

 1) on broadcast le fait qu'on est mort: systeme securise pour garantir
    l'authenticite du message
 2) avant de mourir le processus (ou son watchdog) appelle chaque server
    avec les capabilities pour liberer les donnees.

 la premiere est lourde mais finalement surement la plus simple a implementer.
 il suffit de trouver un moyen pour garantir l'authenticite.

 la seconde est plus clean au niveau de la notification mais par contre
 il faut garder une trace des objets reserves.

 ok c'est bon j'ai trouve :)

 faut pas le voir comme ca. ca ne peut pas etre automatique et etre elegant
 en meme temps. en fait jcrois que vianney faisait comme ca, il avait raison.

 lorsque qu'une tache reserve un objet, il le fait un point c'est tout.
   -> points positifs: interface de code simple puisque aucune gestion du
      cote client (c'etait une des contraintes)
 par contre le server qui a fournit lui demande au groupe notify d'enregistrer
 le couple: server/client pour que lorsque le client meurt il en soit
 averti. bien sur il sera plus pratique de s'enregistrer aupres de notify
 avant de repondre au client, au cas ou le client meurt entre la reponse
 et l'enregistrement.
 de plus on pourrait imaginer que le groupe notify avertisse egalement le
 client que le server est mort. ce serait pratique genre, il recoit le
 message, il stoppe tous ses threads, il s'endort pour quelque secondes,
 le temps que le server redemarre ou qu'un autre prenne le relai, puis
 il redemande les objets. (ca implique de partager les objets entre les
 threads, enfin ca c'est un detail du client).
   -> points positifs: pas de broadcast, systeme de capability entre le server
      et notify (faudra trouver), pas de liste crades dans le client, ni
      dans le server.
 ensuite quand la tache meurt, le service notify de sa machine le saura
 (comment? polling, message du kernel, message du client a notify avant de
 mourrir, bref!) et celui ci enverra un message au groupe notify pour
 le signaler.

 cette methode est je pense la plus elegante car ca passe pas ou groupe
 distribue, en plus c'est leger du cote client, du cote serveur il a le
 choix d'etre notifie ou non. bon son interface se complexifie un peu mais bon.
 il faut qu il gere un message de notify pour liberer un objet.

 !!! dans le cas du kernel cela n'arrange rien.
 il faut pouvoir faire en sorte que le kernel sache pour chaque objet quand
 est ce que son proprietaire est mort opur pouvoir les liberer. cela serait
 trop complique.

 3 solutions:

 1) systeme hierarchique de sorte qu'on ne puisse liberer qu'un objet
    qui libere en chaine tous les autres. dans ce cas on peut se demander
    a quoi ca sert de diviser les objets en une hierarchie. mais ca sert
    quand meme notammenet pour l'emulation, de fork par exemple.

 2) champ ownid dans chaque objet et on scanne tout le kernel des qu un
    process meurt pour liberer les objets appartenant au process

 3) objet object qui contiendrait un ensemble de sous objets genre segments,
    set, task, threads etc.. et libererait tout.

 une solution a tout ce merdier serait une systeme generique pour le kernel
 comme pour les servers/groups. la solution sera qu'apres chaque appel systeme
 (message de reservation d'objets) ca envoie un message au notifier pour lui
 dire d'avertir le mec qui gere l'objet quand on meurt. comme ca ca marche
 avec le kernel et avec les servers.

 finalement il faudrait revoir l'entite kernel peut etre pour annihiler
 cette idee de hierarchie de communication et faire que le kernel comme les
 autre peut communiquer. il faut juste trouver un moyen de l'implementer
 correctement car c'est sur qu'un message bloquant n'est pas possible
 dans les meme termes que les processus. de plus le kernel peut avoir
 envoye plusieurs message "bloquant", donc en quelque sorte le kernel ne
 peut faire que de l'asynchrone.

 cette question venait du fait que ca faisait chier de pas pouvoir reserver
 deux as comme ca separement sans avoir encore de tache a qui les assigner.
 le probleme etant qu il fallait pouvoir savoir quand detruire les objets
 car ces objets la n'avaient pas de liens avec la tache qui meurt.

 maintenant qu on a une solution, la question est, est ce que ca vaut le
 coup car ca va couter tres cher de faire de segment_reserve() puis
 segment_attach().

 solutions:

 1) abandonner cette idee et garder la hierarchie.
 2) on fournit une autre fonction qui fait les deux d'un coup pour
    que ce soit plus rapide dans la majeure partie des cas

 a noter que sur une machine, sur le microkernel, la communication est sure.
 on peut donc tout a fait se permettre des envois de messages sans
 acquittements.

 pour moi il faut garder le systeme hierarchique sinon ca fout tout par
 terre. on ne pourra plus recuperer une capability car ca se joue sur
 la hierarchy et ca fera bcp trop de suscribe aupres de notify (pour chaque
 objet reserve!!!).

 de plus penser a faire une capability core, qui sera notamment donnee
 a mod pour lui donner tous les droits. faire des capability sur les managers
 comme sur segment qui sera donne au service swap.

--
 trouver un moyen de gerer un systeme d'evenements intra kernel. soit
 comme unix soit on fait differemment. sleep/wakeup

 en fait le systeme des pthreads est vraiment pas mal avec les condition
 variables ayant un mutex associe.

--
 faire un truc bien opur le fichier de conf, systeme de commentaires etc..
 revoir la grammaire ...

--
 completer schedule avec les ECTS par cours et le nombre de semaines.

--
 pour donner un objet a une autre entite on utilise la hierarchie d'objets:


                  task

         as                  thread

 segment    regions


 ainsi on a:

   segment_give(t_asid, t_asid)
   as_give(t_tskid, t_tskid)
   thread_give(t_tskid, t_tskid)

 meme chose pour recuperer les capabilities:

   task_capility(&c_task); ou plutot task_self(&c_task);

   as_capility(c_task, c_as);
   thread_capability(c_task, c_thread);

 il faudrait dans le crt faire en sorte que c_task soit deja recuperee
 comme ca c'est plus simple.

--
 mycure todo:
  - lectures/kaneton a faire
  - cours os distribue?
  - cours linker loader
  - cours gmake

--
 revoir si on peut resoudre le systeme d inclusion recursive du preproc:
  peut etre en ne mettant que les types et prototypes entre les guards.

--
 un service demande au service dev de lui donner un acces sur tel ressource
 lui le fait avec le kernel car il a la capability. ensuite il sais dialoguer
 plus precisement soit car machdep soit "faut trouver comment nommer"
 et comme ca aucun service ne va se faire chier a nommer les periph a part
 dev.

--
 un seul swapper et on active ou non des options: network, hard drive etc..
 car un swapper ca stocke de la memoire sur un support secondaire qui peut
 etre n'importe quoi, une disquette, une clef usb etc..

--
 proposer deux sujets sur le vrai kaneton par exemple aux deux meilleurs
 groupes: integration du SMP, nommage, new archi etc..

--
 bouger le cours distributed-operating-systems dans kayou

--
 le fait de filer des params dans un fichier de conf implique qu on
 soit capable aussi de lancer ce meme service une fois le kernel boote.

 il faudra donc fournir un moyen de passer les meme params, capabilities
 inclues. il faudra ptet un filesystem pour mod assez complet.

--
 coder un programme C qui permettra de rajouter des options dans un ELF
 genre le nombre de processeurs etc.. ou des params kaneton: options,
 capabilities.

--
 sujets pour etudiants:
   - integration du smp dans kaneton: pour, contre? modifications?
   - complete naming scheme: objects

 mettre tous ces trucs dans seminars avec petite explication.

--
 systeme de nommage style: machine::service::subpart::object

 exemples:

    mybox::core::segment::1  // segment 1 du core
    yourbox::mod::*          // tous les modules de mod

 on pourrait imaginer un systeme de regexp :)

 ensuite si une tache comme une tache root demande une capability sur
 son espace d'adressage, c'est mod qui demandera a core la cap de l'as
 et qui la retournera.

 on pourrait imaginer encore plus loin

    mybox::core::task:: taskid == 1
    mybox::core::segment:: size >= 100 && size <= 200

--
 pour par exemple un driver, il faudra qu il soit capable de communiquer
 avec le hard autrement dit de se rajouter une trap.

 pour cela il faudra dans mod lui filer soit une cap precise sur l'evenement
 precise, soit une cap sur le gestionnaire d'evenements.

 soit il passera par le gestionnaire de dev qui lui saura si telle personne
 a le droit de se rajouter. (comment?)

--
 revoir conf.c et conf.h dans la partie user. le conf.h a la limite
 par contre le conf.c est un peu particulier.

--
 faire les logos: kaneton + kayou

--
 developer un kfs, un systeme de fichiers qui pourrait lister les objets
 du kernel: comme ca on pourrait acceder aux objects et ca resoudrait le
 lancement des services.

 ou mieux etudier Sprite et voir comment ils font eux avec leurs systeme
 de nommage.

--
 segment:

 il faudra rajouter dans le bootloader init.c un segment correspondant
 au dma: SEGMENT_TYPE_CATCH

 on pourrait imaginer dans le fichier de conf dire que telle zone
 est en mode catch et qu elle est catchable que par telle tache (avec
 tel nom par exemple)

--
 mieux decouper les drivers et modules en fonctions de leur types:

   drivers/
     block/
     char/
     ...

   services/
     ...

--
 dans le document assignments, explicite tout genre reprendre les commentaires
 des fonctions. enfin le truc c'est que l'etudiant se fasse pas nique
 parcequ on avait pas precise le role de la fonction set_clone() et des
 comportements en fonction des options: opts

--
 forme d'une presentation de k:
  . pourquoi une telle modelisation: pour/contre, autres systemes
  . que doit faire l'etudiant
  . comment
  . rendu?

--
 parser: params et args

 int		main(int argc, char** argv);

 ce sera conforme a un truc classique avec la forme:

   --verbose		1

 concernant les params, ce sont juste des arguments interpretes par le
 gestionnaire de modules.

 A REVOIR.

--
 une fois le gestionnaire de regions installe, essayer de faire un
 acces a l'adresse 0, normalement ca fait planter.

--
 continuer le cours sur loaders linkers de fab: linker.iecc.com

 un nouveau pourrait le faire.

--
 systeme de reboot automatique

--
 fonction de segments et regions pour faire p->v v->p

-- messages
 faire un msg_build(size) qui va creer un segment partage et renvoyer
 un segid cache dans un msgid. ensuite on fait msg_send(msgid). quand
 de l'autre cote il fait un msg_receive(*msgid) il recoit le msgid
 donc le segid pour le segment partage, il fait un truc style msg_pack()
 et ca lui mappe le segment partage et hop il accede au message qui peut
 donc a la fois etre de taille indeterminee, et le kernel ne manipule que
 des identifiants de message, rien d'autre donc facile a passer.

 pour les message, soit mettre aucune protection cad tout le monde peut
 communiquer avec tlm soit le mec qui recoit cree des filtres sur les
 emmeteurs et transmet ces filtres au kernel. comme ca il n'y aura verification
 que si le recepteur veut limiter les emmeteurs.

 on peut aussi considerer le cas avec une capability sur les messages mais
 ca ca risque de prendre du temps a verifier a chaque fois + problemes
 car serveur d'auth detient ces infos et doit les partager avec le kernel
 donc probleme.

 voir ca avec cedric.

-- swap
 faire du swap sur le reseau et sur le disque mais experimenter
 le reseau.

 <reflexion>
 le swapper (reseau ou disk) sera un service sinon c'est laid de base.

 le swapper doit obtenir des infos sur l'utilisation de zones memoire.

 habituellement il recupere les infos sur des pages mais dans kaneton
 tout se base sur des segments, les seuls objets memoire identifiables.

 donc deja de base on swappera des segments.

 ensuite sur intel par exemple on recupere les infos via la memoire
 virtuelle car c'est la MMU qui est capable de connaitre les acces memoire

 or si on se base d'un point de vue logique c est la memoire choses que les
 permissions. c'est implemente par la memoire virtuelle mais ca concerne
 des zones physiques.

 donc en realite on va dire, comme pour les perms, que les infos d'utilisation
 se trouve en relation avec des segments.

 donc, le swapper demandera au gestionnaire de segment son etat (taux
 d'utilisation de la memoire physique) toutes les N secondes. si ce taux
 est trop eleve il faut swapper des segments. il va donc demande au
 gestionnaire de segments de lui donner l'identifiant du segment le moins
 utilise. il va ensuite prendre le segment et le mettre sur disque.

 de plus il faudra marque le segment comme non-present mais egalement la
 region pour que la partie dep fasse ce qu il faut.

 attention: ok pour le mettre sur disque mais ensuite lorsqu il y aura un
 acces comment le recuperer? un systeme de pagger doit etre mis en place.

 attention: pour que le swapper puisse acceder comme il veut aux segment
 il faut qu il ait une capability pour chaque, ou alors une capability generale
 sur le gestionnaire de segment. il faut regler ce probleme pour pouvoir
 fournir des cap generic.

 attention: comment donner cette cap generique, a quel moment etc.. :(((

 attention: rajouter un type de segment: swap ou non-present

 attention: dans le cas d'un swapper reseau et disk ils vont se marcher dessus
   D: etat
   R: etat
   D: zone moins utilisee
   R: zone moins utilisee
   D: je prends cette zone pour la swappee
   R: je prends cette zone pour la swappee: ERROR zone inexistante
   etc.. tout le temps

 donc soit faire les deux en uns, soit faire des timer qui se chevauchent soit
 faire en sorte qu ils communiquent ou je sais pas.

 !!! bcp de problemes, ca sent le cul.
 </reflexion>

 <reflexion>
 autre solution, le crt cree un thread qui va checker tous les N l'etat
 de la memoire et demande un segment lui appartenant et peu utilise sur
 il faut swapper.

 bref que le user le fasse et qu il transmette les cap a un service swap
 a la limite.

 mais ca aussi pas terrible.

 ARFFFFFFFFFFF!
 </reflexion>

 bon on verra plus tard.

-- norme commit
  [core/kaneton/set/set_bpt.c]
    1) init function updated to properly handle set options.
    2) ...

  [core/kaneton/kaneton.c]
    1) ...

  -> les points 1,2,3 etc.. sont pas ordre d'importance

--
 lister les trucs qui reste a faire:

  4) integrer la moulinette dans l intra: boot automatique, tftp etc..
  10) retoucher cours intel, avec beamer bien etc.. images au bon format

--
 mettre toutes les regles de -old-/README dans kaneton.tex

--
 http://perso.wanadoo.fr/philippe.michel/qnx/

 http://xos.freezee.org/index.php?page=video

--
 rajouter la compression dans grub.sh et le stripping aussi
 avec option

-- vbe

http://xos.freezee.org/doc/video/GUI_TUT.PDF
http://my.execpc.com/~geezer/os/
http://glek.net/subversion/os/
http://www.vesa.org/Public/VBE/
http://66.249.93.104/search?q=cache:z5-PUmUi77IJ:www.inversereality.org/files/vesavideomodes.pdf+vbe2+pdf&hl=fr
http://ript.net/~spec/vbe2/

http://www.djm.co.za/spoon/grub/install.php
http://www.student.cs.uwaterloo.ca/~cs452/grub/

http://www.openbg.net/sto/os/xml/grub.html

http://rampex.ihep.su/Linux/linux_howto/html/tutorials/mini/Vesafb-5.html

http://www.mega-tokyo.com/forum/index.php?board=1;action=display;threadid=6186;start=0
http://bcos.hopto.org/index.html
http://www.google.com/search?hl=en&ie=UTF-8&q=vesa+programming

/* --------------------------------------------XXX-------------------------- */

typedef unsigned short dw;
typedef unsigned char db;
typedef unsigned int dd;

typedef struct vbe_modeinfoblock
{
  /* Mandatory information for all VBE revisions */
  dw mode_attributes;
  db win_a_attributes,win_b_attributes;
  dw win_granulatiry, win_size, win_a_segment, win_b_segment;
  dd win_func_ptr;
  dw bytes_per_scan_line;

  /* Mandatory information for VBE 1.2 and above */
  dw x_resolution, y_resolution;
  db x_char_size, y_char_size, number_of_planes, bits_per_pixel;
  db number_of_banks, memory_model, bank_size, number_of_image_pages;
  db reserved1;

  db red_mask_size ,red_field_position;
  db green_mask_size, green_field_position;
  db blue_mask_size, blue_field_position;
  db rsvd_mask_size, rsvd_field_position;
  db direct_color_mode_info;

  /* Mandatory information for VBE 2.0 and above */
  dd phys_base_ptr;
  dd reserved2;
  dw reserved3;

  /* Mandatory information for VBE 3.0 and above */
  dw lin_bytes_per_scan_line;
  db bnk_number_of_image_pages;
  db lin_number_of_image_pages;
  db lin_red_mask_size, lin_red_field_position;
  db lin_green_mask_size, lin_green_field_position;
  db lin_blue_mask_size, lin_blue_field_position;
  db lin_rsvd_mask_size, lin_rsvd_field_position;
  dd max_pixel_clock;
  db reserved4[189];

} __attribute((packed)) vbe_modeinfoblock_t;

void vesa(void* v)
{
  vbe_modeinfoblock_t* mib = v;

  int* video_base;

  int x_resolution, y_resolution, bits_per_pixel;

  video_base = (int *)mib->phys_base_ptr;
  x_resolution = mib->x_resolution;
  y_resolution = mib->y_resolution;
  bits_per_pixel = mib->bits_per_pixel;

  _main_();
}

/* code here */

#define SCREEN_WIDTH 320
#define SCREEN_HEIGHT 200

unsigned char *VGA = (unsigned char *)0xA0000;
unsigned char *dbl_buffer;

typedef struct tagBITMAP /* the structure for a bitmap. */
{
  unsigned int width;
  unsigned int height;
  unsigned char *data;
} BITMAP;

typedef struct tagRECT
{
  long x1;
  long y1;
  long x2;
  long y2;
} RECT;

void init_dbl_buffer(void)
{
  dbl_buffer = (unsigned char *) malloc (SCREEN_WIDTH * SCREEN_HEIGHT);
  if (dbl_buffer == NULL)
    {
      printf("Not enough memory for double buffer.\n");

      /* XXX */
      /*
      getch();
      exit(1);
      */
      while (1);
    }
}

void update_screen(void)
{
#ifdef VERTICAL_RETRACE
  while ((inportb(0x3DA) & 0x08));
  while (!(inportb(0x3DA) & 0x08));
#endif
  memcpy(VGA, dbl_buffer, (unsigned int)(SCREEN_WIDTH * SCREEN_HEIGHT));
}

void setpixel (BITMAP *bmp, int x, int y, unsigned char color)
{
  bmp->data[y * bmp->width + x];
}

/* Draws a filled in rectangle IN A BITMAP. To fill a full bitmap call as drawrect (&bmp, 0, 0, bmp.width, bmp.height, color);*/

void drawrect(BITMAP *bmp, unsigned short x, unsigned short y, unsigned short x2, unsigned short y2, unsigned char color)
{
  unsigned short tx, ty;
  for (ty = y; ty < y2; ty++)
    for (tx = x; tx < x2; tx++)
      setpixel (bmp, tx, ty, color);
}

void draw_bitmap_old(BITMAP *bmp, int x, int y)
{
  int j;
  unsigned int screen_offset = (y << 8) + (y << 6) + x;
  unsigned int bitmap_offset = 0;
  for(j = 0; j < bmp->height; j++)
    {
      memcpy(&dbl_buffer[screen_offset], &bmp->data[bitmap_offset], bmp->width);
      bitmap_offset += bmp->width;
      screen_offset += SCREEN_WIDTH;
    }
}

void _main_(void)
{

  /* XXX */
  {
    int i;

    for (i = 0; i < 4000; i++)
      VGA[i] = 0xff;
  }
  /* XXX */

  /* You must clear the double buffer every time to avoid evil messes (go ahead and try without this, you will see) */

  memset (dbl_buffer, 0, SCREEN_WIDTH * SCREEN_HEIGHT);
  /* DRAW ALL BITMAPS AND DO GUI CODE HERE */
  /* Draws the double buffer */

  update_screen();
}

/* /code here */


/* code here -> reboot ---- ------------------------------------------------ */

typedef unsigned short WORD;
typedef unsigned char BYTE;
typedef unsigned int DWORD;

/* Structure for VESA BIOS EXTENTION mode information as defined by VESA */
typedef struct tagSVGAMODEINFO
{

  /* mandatory information for all VBE verson */
  WORD modeattributes;          /* Mode attributes  */
  BYTE winattributes;           /* Window A attributes */
  BYTE winbattributes;          /* Window B attributes */
  WORD wingranularity;          /* Window granularity */
  WORD winsize;              /* Window size */
  WORD winasegment;           /* Window A start segment */
  WORD winbsegment;           /* Window B segment  */
  DWORD winfuncptr;           /* pointer to window function */
  WORD bytesperscanline;        /* Bytes per scanline  */


  /* Mandatory information for VBE 1.2 and higher */
  WORD xresolution;           /* Horizontal resolution in pixels */
  WORD yresolution;           /* Vertical resolution in pixel */
  BYTE xcharsize;              /* Character cell width in pixels */
  BYTE ycharsize;              /* Character cell height in pixels */
  BYTE numberofplanes;        /* Number of memoryplanes  */
  BYTE bitsperpixel;           /* bits per pixel  */
  BYTE numberofbanks;           /* Number of banks  */
  BYTE numberofimagepages;     /* Number of images  */
  BYTE reserved1;              /* Reserved for page function */

  /* Direct color fields */
  BYTE redmasksize;            /* size of direct color red mask in bits */
  BYTE redfieldposition;        /* Bit position of lsb of red mask */
  BYTE greenmasksize;          /* size of direct color green mask in bits */
  BYTE greenfieldposition;     /* Bit position of lsb of green mask */
  BYTE bluemasksize;            /* size of direct color blue mask in bits */
  BYTE bluefieldposition;        /* Bit position of lsb of blue mask */
  BYTE rsvdmasksize;            /* size of direct color reserved mask in bits */
  BYTE reservedfieldposition;     /* Bit position of lsb of reserved mask */
  BYTE directcolormodeinfo;    /* Direct color mode attributes  */

  /* Mandatory information for VBE 2.0 and above    */
  DWORD physbaseptr;           /* Physical addres for flat frame buffer */
  DWORD offscreenmemoffset;     /* Pointer to start of off screen memory */
  WORD offscreenmemsize;        /* Amount of offscreen memory in 1kb units */
  char reserved2[206];        /* Reserved */
} SVGAMODEINFO;

char font_a[]= {0x00, /* 00000000 */
		0x00, /* 00000000 */
		0x00, /* 00000000 */
		0x00, /* 00000000 */
		0x00, /* 00000000 */
		0x78, /* 01111000 */
		0x0c, /* 00001100 */
		0x7c, /* 01111100 */
		0xcc, /* 11001100 */
		0xcc, /* 11001100 */
		0xcc, /* 11001100 */
		0x76, /* 01110110 */
		0x00, /* 00000000 */
		0x00, /* 00000000 */
		0x00, /* 00000000 */
		0x00};

unsigned long  RGBA_black = 0x00000000;

#define CHAR_HEIGHT    16
#define CHAR_WIDTH    8

unsigned long *framebuffer;

SVGAMODEINFO *vbe_mode_info;

void show_character(char *font, unsigned long *VRAM,
		    unsigned long color, int rowlength);

int vbe_init(multiboot_info_t *mbi)
{
  int i, j;

  printf("init VBE ... ");

  if(mbi->flags & (1 << 11))
    {
      vbe_mode_info = (SVGAMODEINFO *)mbi->vbe_mode_info;

      framebuffer = (unsigned long *)vbe_mode_info->physbaseptr;

      if(framebuffer != NULL)
	{
	  int offset = 0;

	  for(j=0; j < 600; j++)
	    {
	      for(i=0; i < 800; i++)
		{
		  offset = 800*j + i;
		  framebuffer[offset] = RGBA_black;
		}
	    }
	  show_character(font_a,framebuffer,0xFFFFFFFF, 800);
	}
    }
  return 0;
}

void show_character(char *font, unsigned long *VRAM,
		    unsigned long color, int rowlength)
{
  int i, j;

  for (i=0;i<CHAR_HEIGHT;i++,VRAM+=rowlength)
    {
      unsigned long *row=VRAM;

      for (j=1<<CHAR_WIDTH;j!=0;j=j>>1)
	{
	  if (font[i]&j) *row=color;
	  row++;
	}
    }
}

/* /code here -> reboot ---- ----------------------------------------------- */
