--
 il y a 2 nouveaux managers :

 io, qui gere les permissions des I/O
     il se contente d'appeller le machdep

 cpu, qui gere le multi processeur.
     pour l'instant il gere juste un set de processeur en coordination
     avec  sched. tout  les trucs  interessant restent  à  faire (load
     balancing, migration, IPI)

 j'ai rajouté  un champ a  t_init pour initialiser dans  le bootloader
 une table de processeurs. j'ai aussi terminé le bootloader ia32-smp.
 j'ai modifié  le scheduler pour qu'il  gere ses files  de threads par
 processeurs (pour 1 proc: 1 thread en cours +  1 file ready +  1 file
 expired).

 a faire : ecrire les parties correspondantes dans le book kaneton, et
 s'assurer que l'interface de io et cpu collera bien.

--
 le système est  trop lent. a chaque tick, on resoud  les timers et on
 appelle les fonctions associées.

 on  appelle  aussi  sched_switch,   qui  fait  plein  de  set_get  et
 tout. c'est lent. pas moyen de regler le timer avec une frequence
 vraiment précise...

 la le truc a atteint ses  limites, on peut plus rajouter de code dans
 la gestion des  event, timer  et du  scheduler sous  peine  de devoir
 ralentir encore le timer (qui est a 200 Hz pour l'instant).

 quand au stats manager, il  est tout simplement inutilisable car trop
 lent.  (j'ai testé  et tout plante avec).  la  sauvegarde du contexte
 complet (incluant  TOUT les registres du proc y compris  ceux MMX SSE
 &co) ne  peut pas non plus  marcher dans ces conditions (trop d'acces
 mémoire).  mais bon ca on pourra trafiquer sans probleme.

--
 probleme du malloc:  a priori c'est ok. mais  l'idéal serait en effet
 de faire un set special qui ne poserait pas ce problème.

--
 mettre a jour la doc: u_ notamment dans coding style

--
 Choses a finir (matthieu)

 * finir task
   + wait et clone
 * revoir as_clone, et en fait toute la chaine de *_clone
 * fignoler la gestion de la mémoire
   + tester region_coalesce, region_resize et map_resize.
 * tests
   + as/03
   + time/01, time/02, time/03
   + task/01, task/02, task/03, task/04, task/05, task/06
 * revoir dans ia32_as_reserve les choses a mapper
   + refaire le ELF, et mapper que handler et handler_data

 Bugs connus et TODO mineurs :

 * region_reserve: checks pour OPT_FORCE
 * segment_resize : cas particuliers (1er/dernier segments)
 * segment_*: plutot que faire des appels a segment_perms, modifier
   direct le champ (trop couteux sinon).
   => OU PAS: ca dependra de l'archi :-/

 * region_split : ne marche pas

 * ia32_region_reserve : cas particulier (pt vide)
 * sched_update: optimiser car ca pue
 * ia32_sched_yield
 * probleme du context_switch avec les registres SSE
 * set_array_locate : dicho desactivée

 Autre :

 * faire des tests pour time et refaire des tests plus poussés pour event
 * revoir les timers dans stats
 * faire un vrai realloc

--
 + moulinette triche
 + norme dans books/kaneton

--
 enlever QUICKSTART et expliquer ce qu'il faut sur le site

--
 verifier que dans chaque manager il y a:

   machdep_include()
   tous les machdep_call()

   la variable globale correspondante au manager

--
 au lancement du core, celui-ci genere un nombre sur 64-bit.

 ce nombre va devenir son machine-id.

 de plus son node-id va etre calcule de la maniere suivante:

   node-id = hash(machine-id + 0)

 ou '+' designe la concatenation de donnees.

 plus tard, chaque tache pourra simplement calcule son node-id avec:

   node-id = hash(machine-id + task-id)

 ainsi chaque tache du systeme reparti aura un node-id unique et de plus
 les cores a leurs lancements auront un id, ce qui est requis pour la
 generation des capabilities.

--
 finalement on va surement avoir besoin de mapper les modules pour que
 le core puisse extraire le premier module et le lancer.

--
 tous les profiles machines sauf gnu-unix sont foireux

 il faudra les mettre a jour enfin les refaire plutot

--
 virer les CFLAGS = ___kernel c'est trop laid/specifique

--
 revoir la doc: apparamment les etudiants ne comprennent pas instinctivement
 qu il y a trois parties bien distinctes: core, machdep, libarch

--
 refaire la moulinette de tests pour qu elle soit propre

--
 pour resoudre les forward declarations, normalement faire comme set.h
 et ca marche, cad forward declarer tous les types d'un .h AVANT de
 faire les includes recursifs.

--
 ce serait interessant de rajouter un ensemble 'slab' qui ne se baserait
 pas sur malloc.

 ca montrerait la possibilite du set manager et en plus on pourrait faire
 des tests de perf avec le slab.

--
 etudier le SMP pour pouvoir faire evoluer kaneton vers ca.

 faire un cpu manager pour que les process puissent decider sur quels
 cpus ils peuvent tourner.

--
 probleme de nomenclature: chiche_get(o* o) ca marche pour recuperer un
 objet mais quand ce seront des programs userland, recuperer l objet
 entier ca ne les interesse pas, c'est lourd et c est pas le but.

 donc on devrait changer pour mettre a disposition des fonctions pour
 recuperer que certaines proprietes.

--
 revoir le bootloader:

  t_modules
  {
    + t_module* modules;
  }
  t_module
  {
    + void* content;
    + t_module* next;
  }

--
 les images microkernel_examples_* dans seminar sont a passer au format xfig

--
 il faut prevoir que tout le demarrage des services via fichier de conf
 doit pouvoir etre fait en dynamique. par exemple si mod reserve un
 segment special (CATCH) pour le service tty (console) et bien il faut
 imaginer que si on lance ce meme serveur a la main une fois le systeme
 boote, soit le systeme de lui meme (via un fichier de conf) sait quels
 sont les objets dont il herite ou alors il faut prevoir des messages style
 segment_acquire() pour acquerir un segment specifique: la memoire video.

--
 pour tester la moulette avec un seul pc : QEMU, avec l'option "-serial pty"
 et changer en dur le device dans check.py.

--
 nettoyer conf.h, debug.h, check.h rendre tout ca coherent car la c'est
 un peu le bordel.

 faire que tout ce qui touche a conf soit genere et qu il n y ait plus
 conf.c et conf.h

--
 hevea -exec xxdate.exe kaneton.tex pour generer du html

 latex -> html: HeVeA

 ca aurait ete bien un make web mais bon c'est mort.

--
 trouver un moyen de gerer un systeme d'evenements intra kernel. soit
 comme unix soit on fait differemment. sleep/wakeup

 en fait le systeme des pthreads est vraiment pas mal avec les condition
 variables ayant un mutex associe.

--
 segment:

 il faudra rajouter dans le bootloader init.c un segment correspondant
 au dma: SEGMENT_TYPE_CATCH

 on pourrait imaginer dans le fichier de conf dire que telle zone
 est en mode catch et qu elle est catchable que par telle tache (avec
 tel nom par exemple)

 en fait revoir le concept de catch car c'est quand meme pas clair encore.

-- norme commit
  [core/kaneton/set/set_bpt.c]
    1) init function updated to properly handle set options.
    2) ...

  [core/kaneton/kaneton.c]
    1) ...

  -> les points 1,2,3 etc.. sont pas ordre d'importance
