--
 promo 2007:

   groupe 1:

     - Enguerrand Raymond
     - David Lorin
     - Stephane Roissard

  groupe 2:

--
 je crois qu il y a une solution pour l'auth de messages.

 un client A demande le droit d'envoye un msg a un autre B. le server
 auth accepte. celui ci demande au kernel (via une capability que seul lui
 detient) une capability de message pour A vers B. le kernel l'envoie donc
 au server auth. et ce dernier retransmet cette cap au client qui l'utilisera
 pour communiquer.

 au final il n y a pas de duplication de cap puisque seul les kernels les
 a. de plus le serveur auth peut tjs faire tourner des algos de detections
 d'abus, blacklist etc.. puisqu il sait quand meme qui a le droit de
 communiquer avec qui.

 ca bande!

 les cap ca defonce tout...

 a noter que Mach fournit la primitive send_one() utilise pour les RPC
 pour autoriser l envoi d'un seul message. a etudier!

 Mach est bcp d'autres utilise un systeme de port mais aussi un ensemble
 de ports. comme ca un serveur attend que sur un port et recoie une categorie
 de messages.

 pour kaneton on peut imaginer un truc similaire mais d'une autre maniere.

--
 definitivement:

  Amoeba: n'utilise pas de memoire virtuelle.
  V distributed system (Stanford Cheriton): toute communication par RPC
    (ca doit etre vachement lourd) de plus pas de notion de port mais
    on nomme le processus destination

  kaneton: toute communication par message meme sur le systeme distribue.
    on nomme egalement le process/groupe destination

--
 groupes de 3/4. chef de groupe c'est lui qui doit uploader.

 k0: projet personnel

--
 region:
  * pouvoir mapper des parties de segment. revoir le proto de reserve.
   * region_init => limites vmem => #define dans env/machines
   * voir pr l'union adresse / i
   * vtop et ptov
 segment:
  * faire des fichiers segment differents selon le fit (segment_first.c)
  * inject: a l'init de la task kernel => mettre les segments prealloues
 tests:
  * changer les tests des sets pour plus considerer l'ordre

--
 a noter qu'on pourrait ptet ameliorer le systeme de region pour pouvoir mapper
 des parties de segments. c'est pas tres propre mais bon c'est surement
 faisable. a reflechir!

 ^-> ouais il faut pouvoir le faire.

--
 renaud: expliquer comment booter d'une disquette etc.. tout le bas
 niveau PC/Intel

--
 virer tout affichage autre que warning et erreur dans le bootloader
 de sorte qu'on n'ait plus de structure t_cons dependante a passer

 include/arch/ia32-virtual/kaneton/init.h

--
 enlever les includes libia32 et les mettre dans libs/libia32     << fait

 par contre laisser un repertoire core/include/arch/ia32-virtual pour les
 includes specifiques.

--
 ecrire des tests pour le bootloader ou on teste seulement la structure
 init recue.

--
 tristan: box pour kaneton

--
 reiterer le coup du sondage sur les cours, le projet etc..

--
 julien: penser a finir set_delete pour bpt

 matthieu:
   - voir pkoi la maj des registre segments fout la merde (dans le bootloader)
   - void pkoi cli/sti fout la merde
   - revoir les noms des typedef dans libia32. prefixer t_ia32_ ?
   - corriger printf pour gerer les trucs style %8.5d
   - faire le python pour les tests de stats
   - encore une question avec clone sur les sets : je clone mon set
      set qui a SET_OPT_FREE, ensuite je flush le premier set, donc
      les pointeurs du set clone sont pas valides... c'est l'echec clone

 pour tester la moulette avec un seul pc : QEMU, avec l'option "-serial pty"
 et changer en dur le device dans check.py.

--
 factoriser du code pour ia32 car on va avoir bcp de ressemblance entre
 ia32-virtual, ia32-segments et ia32-optimised. le mieux
 serait sans doute de rajouter dans libs/ une lib libia32 ou on
 fournirait toutes les fonctionnalites d'ia32.

--
 nettoyer conf.h, debug.h, check.h rendre tout ca coherent car la c'est
 un peu le bordel.

--
 peut etre devrait on penser les regions un peu plus pour tout faire avec:
  swap/paging etc..

--
 dans segment et surement dans d'autres: as, task, region

 on fait dans clean() un foreach ( segment_release ) c'est tres
 dangereux car l'iterator n'est pas sur d'etre correct. il faudrait
 changer ca et faire plutot un while (set_head) { segment_release }

--
 make view-paper.kaneton : . -> /
 make view-ship.sol

--
 dans doc papers diviser par categories et faire que chaque personne
 qui lit ecrit un resume

--
 peut etre passer en enum si on a le temps et l'envie:

 enum error
  {
    ERROR_NONE
    ERROR_UNKNOWN
    -> error specifique pour chaque gestionnaire
  }

--
 pifi: 18
 les autres: 13

 donner les notes a l'adm

--
 ajouter set_pop set_push etc..

--
 bien redire: le header emacs doit etre utilise. la licence doit etre
 kaneton, et le developeur doit etre le meme nom que KANETON_USER.

 les headers ne doivent pas contenir de pseudo.

--
 hevea -exec xxdate.exe kaneton.tex pour generer du html

 latex -> html: HeVeA

 ca aurait ete bien un make web mais bon c'est mort.

--
 as + thread => domain (sprite)

 machines proches forment des villages

--
 definir une interface pour les drivers de sorte qu'ils soient portable
 tres facilement, qu'ils ne fassent que des entree sorties. dans l'interface
 on fournira le systeme de communication + gestion des structures de donnees.

 a etudier!

--
 le systeme pue. si on fait un systeme hierarchique alors on pourra
 JAMAIS allouer un segment, une tache ou autre chose sur une autre machine
 sauf en passant pas un service supplementaire migrate par exemple.

 de plus il faut trouver un systeme pour liberer les objets allouer:

  1) systeme de time to live
       il faudrait checker tout le temps si un objet n'est plus utilise
       donc on aura 1 timer par objet. ce n'est donc pas envisageable.
       trop lourd, complique, lent.
  2) systeme de garbage collecting
       un peu dans le meme principe donc pas possible non plus.
  3) listing des objets alloues dans le kernel/server pour la desallocation
  4) listing des objets alloues dans le processus

 exemple:
   une tache alloue de la memoire partagee au groupe de memoire partagee
   donc la memoire est peut etre allouee sur une autre machine. si la
   tache meurt, elle DOIT prevenir les servers/groupes qui lui ont filer
   des objets dans notre cas on doit prevenir le groupe de memoire partagee
   de liberer la memoire.

   comment faire?

 1) on broadcast le fait qu'on est mort
 2) on envoie un message a chaque server a qui on a reserver un objet
    donc ca necessite de maintenir une liste de ces servers.

 attention: probleme de securite, il ne faut pas que quelqu'un se fasse
            passer pour nous et broadcast ce message.

 il reste deux solutions.

 1) on broadcast le fait qu'on est mort: systeme securise pour garantir
    l'authenticite du message
 2) avant de mourir le processus (ou son watchdog) appelle chaque server
    avec les capabilities pour liberer les donnees.

 la premiere est lourde mais finalement surement la plus simple a implementer.
 il suffit de trouver un moyen pour garantir l'authenticite.

 la seconde est plus clean au niveau de la notification mais par contre
 il faut garder une trace des objets reserves.

 ok c'est bon j'ai trouve :)

 faut pas le voir comme ca. ca ne peut pas etre automatique et etre elegant
 en meme temps. en fait jcrois que vianney faisait comme ca, il avait raison.

 lorsque qu'une tache reserve un objet, il le fait un point c'est tout.
   -> points positifs: interface de code simple puisque aucune gestion du
      cote client (c'etait une des contraintes)
 par contre le server qui a fournit lui demande au groupe notify d'enregistrer
 le couple: server/client pour que lorsque le client meurt il en soit
 averti. bien sur il sera plus pratique de s'enregistrer aupres de notify
 avant de repondre au client, au cas ou le client meurt entre la reponse
 et l'enregistrement.
 de plus on pourrait imaginer que le groupe notify avertisse egalement le
 client que le server est mort. ce serait pratique genre, il recoit le
 message, il stoppe tous ses threads, il s'endort pour quelque secondes,
 le temps que le server redemarre ou qu'un autre prenne le relai, puis
 il redemande les objets. (ca implique de partager les objets entre les
 threads, enfin ca c'est un detail du client).
   -> points positifs: pas de broadcast, systeme de capability entre le server
      et notify (faudra trouver), pas de liste crades dans le client, ni
      dans le server.
 ensuite quand la tache meurt, le service notify de sa machine le saura
 (comment? polling, message du kernel, message du client a notify avant de
 mourrir, bref!) et celui ci enverra un message au groupe notify pour
 le signaler.

 cette methode est je pense la plus elegante car ca passe pas ou groupe
 distribue, en plus c'est leger du cote client, du cote serveur il a le
 choix d'etre notifie ou non. bon son interface se complexifie un peu mais bon.
 il faut qu il gere un message de notify pour liberer un objet.

 !!! dans le cas du kernel cela n'arrange rien.
 il faut pouvoir faire en sorte que le kernel sache pour chaque objet quand
 est ce que son proprietaire est mort opur pouvoir les liberer. cela serait
 trop complique.

 3 solutions:

 1) systeme hierarchique de sorte qu'on ne puisse liberer qu'un objet
    qui libere en chaine tous les autres. dans ce cas on peut se demander
    a quoi ca sert de diviser les objets en une hierarchie. mais ca sert
    quand meme notammenet pour l'emulation, de fork par exemple.

 2) champ ownid dans chaque objet et on scanne tout le kernel des qu un
    process meurt pour liberer les objets appartenant au process

 3) objet object qui contiendrait un ensemble de sous objets genre segments,
    set, task, threads etc.. et libererait tout.

 une solution a tout ce merdier serait une systeme generique pour le kernel
 comme pour les servers/groups. la solution sera qu'apres chaque appel systeme
 (message de reservation d'objets) ca envoie un message au notifier pour lui
 dire d'avertir le mec qui gere l'objet quand on meurt. comme ca ca marche
 avec le kernel et avec les servers.

 finalement il faudrait revoir l'entite kernel peut etre pour annihiler
 cette idee de hierarchie de communication et faire que le kernel comme les
 autre peut communiquer. il faut juste trouver un moyen de l'implementer
 correctement car c'est sur qu'un message bloquant n'est pas possible
 dans les meme termes que les processus. de plus le kernel peut avoir
 envoye plusieurs message "bloquant", donc en quelque sorte le kernel ne
 peut faire que de l'asynchrone.

 cette question venait du fait que ca faisait chier de pas pouvoir reserver
 deux as comme ca separement sans avoir encore de tache a qui les assigner.
 le probleme etant qu il fallait pouvoir savoir quand detruire les objets
 car ces objets la n'avaient pas de liens avec la tache qui meurt.

 maintenant qu on a une solution, la question est, est ce que ca vaut le
 coup car ca va couter tres cher de faire de segment_reserve() puis
 segment_attach().

 solutions:

 1) abandonner cette idee et garder la hierarchie.
 2) on fournit une autre fonction qui fait les deux d'un coup pour
    que ce soit plus rapide dans la majeure partie des cas

 a noter que sur une machine, sur le microkernel, la communication est sure.
 on peut donc tout a fait se permettre des envois de messages sans
 acquittements.

 pour moi il faut garder le systeme hierarchique sinon ca fout tout par
 terre. on ne pourra plus recuperer une capability car ca se joue sur
 la hierarchy et ca fera bcp trop de suscribe aupres de notify (pour chaque
 objet reserve!!!).

 de plus penser a faire une capability core, qui sera notamment donnee
 a mod pour lui donner tous les droits. faire des capability sur les managers
 comme sur segment qui sera donne au service swap.

--
 trouver un moyen de gerer un systeme d'evenements intra kernel. soit
 comme unix soit on fait differemment. sleep/wakeup

 en fait le systeme des pthreads est vraiment pas mal avec les condition
 variables ayant un mutex associe.

--
 faire un truc bien opur le fichier de conf, systeme de commentaires etc..
 revoir la grammaire ...

--
 completer schedule avec les ECTS par cours et le nombre de semaines.

--
 pour donner un objet a une autre entite on utilise la hierarchie d'objets:


                  task

         as                  thread

 segment    regions


 ainsi on a:

   segment_give(t_asid, t_asid)
   as_give(t_tskid, t_tskid)
   thread_give(t_tskid, t_tskid)

 meme chose pour recuperer les capabilities:

   task_capility(&c_task); ou plutot task_self(&c_task);

   as_capility(c_task, c_as);
   thread_capability(c_task, c_thread);

 il faudrait dans le crt faire en sorte que c_task soit deja recuperee
 comme ca c'est plus simple.

--
 mycure todo:
  - mips architecture
  - lectures/kaneton a faire
  - kaneton.tex et assignments.tex a ecrire
  - cours os distribue?
  - cours linker loader
  - cours gmake + systeme compile kaneton (dev-env)

--
 revoir si on peut resoudre le systeme d inclusion recursive du preproc:
  peut etre en ne mettant que les types et prototypes entre les guards.

--
 un service demande au service dev de lui donner un acces sur tel ressource
 lui le fait avec le kernel car il a la capability. ensuite il sais dialoguer
 plus precisement soit car machdep soit "faut trouver comment nommer"
 et comme ca aucun service ne va se faire chier a nommer les periph a part
 dev.

--
 buckman: cours makefile, fin cours dev-env avec explication du
  systeme de compil kaneton + seminaire.

--
 un seul swapper et on active ou non des options: network, hard drive etc..
 car un swapper ca stocke de la memoire sur un support secondaire qui peut
 etre n'importe quoi, une disquette, une clef usb etc..

--
 permettre aux etudiants de choisir leur archi: mips, intel, amd, sparc ...

--
 revoir la console car ca deconne. faire des tests avec la moulinette tiens.

--
 detecter taille de fenetre -> [PROTO] .../chiche/

--
 oceansize premiere partie de porcupine tree

--
 proposer deux sujets sur le vrai kaneton par exemple aux deux meilleurs
 groupes: integration du SMP, nommage, new archi etc..

--
 bouger le cours distributed-operating-systems dans kayou

--
 le fait de filer des params dans un fichier de conf implique qu on
 soit capable aussi de lancer ce meme service une fois le kernel boote.

 il faudra donc fournir un moyen de passer les meme params, capabilities
 inclues. il faudra ptet un filesystem pour mod assez complet.

--
 coder un programme C qui permettra de rajouter des options dans un ELF
 genre le nombre de processeurs etc.. ou des params kaneton: options,
 capabilities.

--
 sujets pour etudiants:
   - integration du smp dans kaneton: pour, contre? modifications?
   - complete naming scheme: objects

 mettre tous ces trucs dans seminars avec petite explication.

--
 systeme de nommage style: machine::service::subpart::object

 exemples:

    mybox::core::segment::1  // segment 1 du core
    yourbox::mod::*          // tous les modules de mod

 on pourrait imaginer un systeme de regexp :)

 ensuite si une tache comme une tache root demande une capability sur
 son espace d'adressage, c'est mod qui demandera a core la cap de l'as
 et qui la retournera.

 on pourrait imaginer encore plus loin

    mybox::core::task:: taskid == 1
    mybox::core::segment:: size >= 100 && size <= 200

--
 il faudrait resoudre ce probleme de user. le kernel ne doit pas gerer
 les users. comment faire ???

 peut etre sommes nous obliges de rajouter un ownid?

 solution: le kernel ne gere que des taches, et le user ne sera qu un truc
 au dessus gere surement par un service enfin on verra on s'en branle.

--
 pour par exemple un driver, il faudra qu il soit capable de communiquer
 avec le hard autrement dit de se rajouter une trap.

 pour cela il faudra dans mod lui filer soit une cap precise sur l'evenement
 precise, soit une cap sur le gestionnaire d'evenements.

 soit il passera par le gestionnaire de dev qui lui saura si telle personne
 a le droit de se rajouter. (comment?)

--
 revoir conf.c et conf.h dans la partie user. le conf.h a la limite
 par contre le conf.c est un peu particulier.

--
 faire les logos: kaneton + kayou

--
 developer un kfs, un systeme de fichiers qui pourrait lister les objets
 du kernel: comme ca on pourrait acceder aux objects et ca resoudrait le
 lancement des services.

 ou mieux etudier Sprite et voir comment ils font eux avec leurs systeme
 de nommage.

--
 segment:

 il faudra rajouter dans le bootloader init.c un segment correspondant
 au dma: SEGMENT_TYPE_CATCH

 on pourrait imaginer dans le fichier de conf dire que telle zone
 est en mode catch et qu elle est catchable que par telle tache (avec
 tel nom par exemple)

--
 mieux decouper les drivers et modules en fonctions de leur types:

   drivers/
     block/
     char/
     ...

   services/
     ...

--
 dans le document assignments, explicite tout genre reprendre les commentaires
 des fonctions. enfin le truc c'est que l'etudiant se fasse pas nique
 parcequ on avait pas precise le role de la fonction set_clone() et des
 comportements en fonction des options: opts

--
 forme d'une presentation de k:
  . pourquoi une telle modelisation: pour/contre, autres systemes
  . que doit faire l'etudiant
  . comment
  . rendu?

--
 parser: params et args

 int		main(int argc, char** argv);

 ce sera conforme a un truc classique avec la forme:

   --verbose		1

 concernant les params, ce sont juste des arguments interpretes par le
 gestionnaire de modules.

 A REVOIR.

--
 une fois le gestionnaire de regions installe, essayer de faire un
 acces a l'adresse 0, normalement ca fait planter.

--
 continuer le cours sur loaders linkers de fab: linker.iecc.com

 un nouveau pourrait le faire.

--
 systeme de reboot automatique

--
 fonction de segments et regions pour faire p->v v->p

-- messages
 faire un msg_build(size) qui va creer un segment partage et renvoyer
 un segid cache dans un msgid. ensuite on fait msg_send(msgid). quand
 de l'autre cote il fait un msg_receive(*msgid) il recoit le msgid
 donc le segid pour le segment partage, il fait un truc style msg_pack()
 et ca lui mappe le segment partage et hop il accede au message qui peut
 donc a la fois etre de taille indeterminee, et le kernel ne manipule que
 des identifiants de message, rien d'autre donc facile a passer.

 pour les message, soit mettre aucune protection cad tout le monde peut
 communiquer avec tlm soit le mec qui recoit cree des filtres sur les
 emmeteurs et transmet ces filtres au kernel. comme ca il n'y aura verification
 que si le recepteur veut limiter les emmeteurs.

 on peut aussi considerer le cas avec une capability sur les messages mais
 ca ca risque de prendre du temps a verifier a chaque fois + problemes
 car serveur d'auth detient ces infos et doit les partager avec le kernel
 donc probleme.

 voir ca avec cedric.

-- swap
 faire du swap sur le reseau et sur le disque mais experimenter
 le reseau.

 <reflexion>
 le swapper (reseau ou disk) sera un service sinon c'est laid de base.

 le swapper doit obtenir des infos sur l'utilisation de zones memoire.

 habituellement il recupere les infos sur des pages mais dans kaneton
 tout se base sur des segments, les seuls objets memoire identifiables.

 donc deja de base on swappera des segments.

 ensuite sur intel par exemple on recupere les infos via la memoire
 virtuelle car c'est la MMU qui est capable de connaitre les acces memoire

 or si on se base d'un point de vue logique c est la memoire choses que les
 permissions. c'est implemente par la memoire virtuelle mais ca concerne
 des zones physiques.

 donc en realite on va dire, comme pour les perms, que les infos d'utilisation
 se trouve en relation avec des segments.

 donc, le swapper demandera au gestionnaire de segment son etat (taux
 d'utilisation de la memoire physique) toutes les N secondes. si ce taux
 est trop eleve il faut swapper des segments. il va donc demande au
 gestionnaire de segments de lui donner l'identifiant du segment le moins
 utilise. il va ensuite prendre le segment et le mettre sur disque.

 de plus il faudra marque le segment comme non-present mais egalement la
 region pour que la partie dep fasse ce qu il faut.

 attention: ok pour le mettre sur disque mais ensuite lorsqu il y aura un
 acces comment le recuperer? un systeme de pagger doit etre mis en place.

 attention: pour que le swapper puisse acceder comme il veut aux segment
 il faut qu il ait une capability pour chaque, ou alors une capability generale
 sur le gestionnaire de segment. il faut regler ce probleme pour pouvoir
 fournir des cap generic.

 attention: comment donner cette cap generique, a quel moment etc.. :(((

 attention: rajouter un type de segment: swap ou non-present

 attention: dans le cas d'un swapper reseau et disk ils vont se marcher dessus
   D: etat
   R: etat
   D: zone moins utilisee
   R: zone moins utilisee
   D: je prends cette zone pour la swappee
   R: je prends cette zone pour la swappee: ERROR zone inexistante
   etc.. tout le temps

 donc soit faire les deux en uns, soit faire des timer qui se chevauchent soit
 faire en sorte qu ils communiquent ou je sais pas.

 !!! bcp de problemes, ca sent le cul.
 </reflexion>

 <reflexion>
 autre solution, le crt cree un thread qui va checker tous les N l'etat
 de la memoire et demande un segment lui appartenant et peu utilise sur
 il faut swapper.

 bref que le user le fasse et qu il transmette les cap a un service swap
 a la limite.

 mais ca aussi pas terrible.

 ARFFFFFFFFFFF!
 </reflexion>

 bon on verra plus tard.

-- norme commit
  [core/kaneton/set/set_bpt.c]
    1) init function updated to properly handle set options.
    2) ...

  [core/kaneton/kaneton.c]
    1) ...

  -> les points 1,2,3 etc.. sont pas ordre d'importance

--
 lister les trucs qui reste a faire:

  1) moulinette de tests
  2) des tests pour set, as, segment, regions
  3) finir intra
  4) integrer la moulinette dans l intra: boot automatique, tftp etc..
  5) slides presentations kaneton [*]
  7) cours: cpp [*], inline assembly [*], gnu make
  8) presentation kaneton, tarball etc.. -> develpment-tree
     cours revisions: C, asm, etc.. faire quelques slides [*]
  9) cours noyaux
  10) retoucher cours intel, avec beamer bien etc.. images au bon format
  12) finir le code de kaneton jusqu'aux regions
  13) moulinette de decoupage de code [*]
  14) decouper le code: make export-0 et commenter chaque partie pour que
      les etudiants sachent quoi coder environ juste avec les commentaires
    . k0: bootstrap [*]
    . k1: bootloader [*]
    . k2: id, set, as, segment

--
 mettre toutes les regles de -old-/README dans kaneton.tex

--
 http://perso.wanadoo.fr/philippe.michel/qnx/

 http://xos.freezee.org/index.php?page=video

--
 rajouter la compression dans grub.sh et le stripping aussi
 avec option

-- vbe

http://xos.freezee.org/doc/video/GUI_TUT.PDF
http://my.execpc.com/~geezer/os/
http://glek.net/subversion/os/
http://www.vesa.org/Public/VBE/
http://66.249.93.104/search?q=cache:z5-PUmUi77IJ:www.inversereality.org/files/vesavideomodes.pdf+vbe2+pdf&hl=fr
http://ript.net/~spec/vbe2/

http://www.djm.co.za/spoon/grub/install.php
http://www.student.cs.uwaterloo.ca/~cs452/grub/

http://www.openbg.net/sto/os/xml/grub.html

http://rampex.ihep.su/Linux/linux_howto/html/tutorials/mini/Vesafb-5.html

http://www.mega-tokyo.com/forum/index.php?board=1;action=display;threadid=6186;start=0
http://bcos.hopto.org/index.html
http://www.google.com/search?hl=en&ie=UTF-8&q=vesa+programming

/* --------------------------------------------XXX-------------------------- */

typedef unsigned short dw;
typedef unsigned char db;
typedef unsigned int dd;

typedef struct vbe_modeinfoblock
{
  /* Mandatory information for all VBE revisions */
  dw mode_attributes;
  db win_a_attributes,win_b_attributes;
  dw win_granulatiry, win_size, win_a_segment, win_b_segment;
  dd win_func_ptr;
  dw bytes_per_scan_line;

  /* Mandatory information for VBE 1.2 and above */
  dw x_resolution, y_resolution;
  db x_char_size, y_char_size, number_of_planes, bits_per_pixel;
  db number_of_banks, memory_model, bank_size, number_of_image_pages;
  db reserved1;

  db red_mask_size ,red_field_position;
  db green_mask_size, green_field_position;
  db blue_mask_size, blue_field_position;
  db rsvd_mask_size, rsvd_field_position;
  db direct_color_mode_info;

  /* Mandatory information for VBE 2.0 and above */
  dd phys_base_ptr;
  dd reserved2;
  dw reserved3;

  /* Mandatory information for VBE 3.0 and above */
  dw lin_bytes_per_scan_line;
  db bnk_number_of_image_pages;
  db lin_number_of_image_pages;
  db lin_red_mask_size, lin_red_field_position;
  db lin_green_mask_size, lin_green_field_position;
  db lin_blue_mask_size, lin_blue_field_position;
  db lin_rsvd_mask_size, lin_rsvd_field_position;
  dd max_pixel_clock;
  db reserved4[189];

} __attribute((packed)) vbe_modeinfoblock_t;

void vesa(void* v)
{
  vbe_modeinfoblock_t* mib = v;

  int* video_base;

  int x_resolution, y_resolution, bits_per_pixel;

  video_base = (int *)mib->phys_base_ptr;
  x_resolution = mib->x_resolution;
  y_resolution = mib->y_resolution;
  bits_per_pixel = mib->bits_per_pixel;

  _main_();
}

/* code here */

#define SCREEN_WIDTH 320
#define SCREEN_HEIGHT 200

unsigned char *VGA = (unsigned char *)0xA0000;
unsigned char *dbl_buffer;

typedef struct tagBITMAP /* the structure for a bitmap. */
{
  unsigned int width;
  unsigned int height;
  unsigned char *data;
} BITMAP;

typedef struct tagRECT
{
  long x1;
  long y1;
  long x2;
  long y2;
} RECT;

void init_dbl_buffer(void)
{
  dbl_buffer = (unsigned char *) malloc (SCREEN_WIDTH * SCREEN_HEIGHT);
  if (dbl_buffer == NULL)
    {
      printf("Not enough memory for double buffer.\n");

      /* XXX */
      /*
      getch();
      exit(1);
      */
      while (1);
    }
}

void update_screen(void)
{
#ifdef VERTICAL_RETRACE
  while ((inportb(0x3DA) & 0x08));
  while (!(inportb(0x3DA) & 0x08));
#endif
  memcpy(VGA, dbl_buffer, (unsigned int)(SCREEN_WIDTH * SCREEN_HEIGHT));
}

void setpixel (BITMAP *bmp, int x, int y, unsigned char color)
{
  bmp->data[y * bmp->width + x];
}

/* Draws a filled in rectangle IN A BITMAP. To fill a full bitmap call as drawrect (&bmp, 0, 0, bmp.width, bmp.height, color);*/

void drawrect(BITMAP *bmp, unsigned short x, unsigned short y, unsigned short x2, unsigned short y2, unsigned char color)
{
  unsigned short tx, ty;
  for (ty = y; ty < y2; ty++)
    for (tx = x; tx < x2; tx++)
      setpixel (bmp, tx, ty, color);
}

void draw_bitmap_old(BITMAP *bmp, int x, int y)
{
  int j;
  unsigned int screen_offset = (y << 8) + (y << 6) + x;
  unsigned int bitmap_offset = 0;
  for(j = 0; j < bmp->height; j++)
    {
      memcpy(&dbl_buffer[screen_offset], &bmp->data[bitmap_offset], bmp->width);
      bitmap_offset += bmp->width;
      screen_offset += SCREEN_WIDTH;
    }
}

void _main_(void)
{

  /* XXX */
  {
    int i;

    for (i = 0; i < 4000; i++)
      VGA[i] = 0xff;
  }
  /* XXX */

  /* You must clear the double buffer every time to avoid evil messes (go ahead and try without this, you will see) */

  memset (dbl_buffer, 0, SCREEN_WIDTH * SCREEN_HEIGHT);
  /* DRAW ALL BITMAPS AND DO GUI CODE HERE */
  /* Draws the double buffer */

  update_screen();
}

/* /code here */


/* code here -> reboot ---- ------------------------------------------------ */

typedef unsigned short WORD;
typedef unsigned char BYTE;
typedef unsigned int DWORD;

/* Structure for VESA BIOS EXTENTION mode information as defined by VESA */
typedef struct tagSVGAMODEINFO
{

  /* mandatory information for all VBE verson */
  WORD modeattributes;          /* Mode attributes  */
  BYTE winattributes;           /* Window A attributes */
  BYTE winbattributes;          /* Window B attributes */
  WORD wingranularity;          /* Window granularity */
  WORD winsize;              /* Window size */
  WORD winasegment;           /* Window A start segment */
  WORD winbsegment;           /* Window B segment  */
  DWORD winfuncptr;           /* pointer to window function */
  WORD bytesperscanline;        /* Bytes per scanline  */


  /* Mandatory information for VBE 1.2 and higher */
  WORD xresolution;           /* Horizontal resolution in pixels */
  WORD yresolution;           /* Vertical resolution in pixel */
  BYTE xcharsize;              /* Character cell width in pixels */
  BYTE ycharsize;              /* Character cell height in pixels */
  BYTE numberofplanes;        /* Number of memoryplanes  */
  BYTE bitsperpixel;           /* bits per pixel  */
  BYTE numberofbanks;           /* Number of banks  */
  BYTE numberofimagepages;     /* Number of images  */
  BYTE reserved1;              /* Reserved for page function */

  /* Direct color fields */
  BYTE redmasksize;            /* size of direct color red mask in bits */
  BYTE redfieldposition;        /* Bit position of lsb of red mask */
  BYTE greenmasksize;          /* size of direct color green mask in bits */
  BYTE greenfieldposition;     /* Bit position of lsb of green mask */
  BYTE bluemasksize;            /* size of direct color blue mask in bits */
  BYTE bluefieldposition;        /* Bit position of lsb of blue mask */
  BYTE rsvdmasksize;            /* size of direct color reserved mask in bits */
  BYTE reservedfieldposition;     /* Bit position of lsb of reserved mask */
  BYTE directcolormodeinfo;    /* Direct color mode attributes  */

  /* Mandatory information for VBE 2.0 and above    */
  DWORD physbaseptr;           /* Physical addres for flat frame buffer */
  DWORD offscreenmemoffset;     /* Pointer to start of off screen memory */
  WORD offscreenmemsize;        /* Amount of offscreen memory in 1kb units */
  char reserved2[206];        /* Reserved */
} SVGAMODEINFO;

char font_a[]= {0x00, /* 00000000 */
		0x00, /* 00000000 */
		0x00, /* 00000000 */
		0x00, /* 00000000 */
		0x00, /* 00000000 */
		0x78, /* 01111000 */
		0x0c, /* 00001100 */
		0x7c, /* 01111100 */
		0xcc, /* 11001100 */
		0xcc, /* 11001100 */
		0xcc, /* 11001100 */
		0x76, /* 01110110 */
		0x00, /* 00000000 */
		0x00, /* 00000000 */
		0x00, /* 00000000 */
		0x00};

unsigned long  RGBA_black = 0x00000000;

#define CHAR_HEIGHT    16
#define CHAR_WIDTH    8

unsigned long *framebuffer;

SVGAMODEINFO *vbe_mode_info;

void show_character(char *font, unsigned long *VRAM,
		    unsigned long color, int rowlength);

int vbe_init(multiboot_info_t *mbi)
{
  int i, j;

  printf("init VBE ... ");

  if(mbi->flags & (1 << 11))
    {
      vbe_mode_info = (SVGAMODEINFO *)mbi->vbe_mode_info;

      framebuffer = (unsigned long *)vbe_mode_info->physbaseptr;

      if(framebuffer != NULL)
	{
	  int offset = 0;

	  for(j=0; j < 600; j++)
	    {
	      for(i=0; i < 800; i++)
		{
		  offset = 800*j + i;
		  framebuffer[offset] = RGBA_black;
		}
	    }
	  show_character(font_a,framebuffer,0xFFFFFFFF, 800);
	}
    }
  return 0;
}

void show_character(char *font, unsigned long *VRAM,
		    unsigned long color, int rowlength)
{
  int i, j;

  for (i=0;i<CHAR_HEIGHT;i++,VRAM+=rowlength)
    {
      unsigned long *row=VRAM;

      for (j=1<<CHAR_WIDTH;j!=0;j=j>>1)
	{
	  if (font[i]&j) *row=color;
	  row++;
	}
    }
}

/* /code here -> reboot ---- ----------------------------------------------- */
