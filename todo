--
 etendre le find des fichiers dans exporter.sh a core/ libs/ services/

 faire un make proto avant de faire le tar comme ca ca clean nos proto

--
 expliquer le systeme de decoupage: hierarchique inclusif

--
 bien commenter les fichiers car quand ce sera decoupe il faut que
 les etudiants sachent quoi faire

--
 systeme de reboot automatique

--
 segments: address -> id et tester avec bpt

--
 implementer des fonction *_print|show|view(id) qui affiche un element
 contrairement a dump() qui affiche tout

 ca pourrait etre utile pour le debug

--
 mkp: gerer t_bpt_addr(set), les fonctions statiques, les fonctions
 qui sont dans un commentaire etc..

--
 prevoir TP de remise a niveau: C (decalage, mask etc..), assembleur
 exos en assembleur nasm puis en asm inline etc..

-- messages
 faire un msg_build(size) qui va creer un segment partage et renvoyer
 un segid cache dans un msgid. ensuite on fait msg_send(msgid). quand
 de l'autre cote il fait un msg_receive(*msgid) il recoit le msgid
 donc le segid pour le segment partage, il fait un truc style msg_pack()
 et ca lui mappe le segment partage et hop il accede au message qui peut
 donc a la fois etre de taille indeterminee, et le kernel ne manipule que
 des identifiants de message, rien d'autre donc facile a passer.

 pour les message, soit mettre aucune protection cad tout le monde peut
 communiquer avec tlm soit le mec qui recoit cree des filtres sur les
 emmeteurs et transmet ces filtres au kernel. comme ca il n'y aura verification
 que si le recepteur veut limiter les emmeteurs.

 on peut aussi considerer le cas avec une capability sur les messages mais
 ca ca risque de prendre du temps a verifier a chaque fois + problemes
 car serveur d'auth detient ces infos et doit les partager avec le kernel
 donc probleme.

-- swap
 faire du swap sur le reseau et sur le disque mais experimenter
 le reseau

-- norme commit
  [core/kaneton/set/set_bpt.c]
    1) init function updated to properly handle set options.
    2) ...

  [core/kaneton/kaneton.c]
    1) ...

--
 rajouter des binaires dans env/linux/init pour le check

 mtools, gmake etc..

--
 essayer de faire compiler kaneton sur netbsd a l ecole:

--
 lister les trucs qui reste a faire:

  1) moulinette de tests
  2) des tests pour set, as, segment, regions
  3) finir intra
  4) integrer la moulinette dans l intra: boot automatique, tftp etc..
  5) slides presentations kaneton [*]
  6) slides presentation lse (rien a foutre)[*]
  7) cours: cpp [*], inline assembly [*], gnu make
  8) presentation kaneton, tarball etc.. -> develpment-tree
     cours revisions: C, asm, etc.. faire quelques slides
  9) cours noyaux
  10) retoucher cours intel, avec beamer bien etc.. images au bon format
  11) cours OS distribues
  12) finir le code de kaneton jusqu'aux regions
  13) moulinette de decoupage de code [*]
  14) decouper le code: make export-0 et commenter chaque partie pour que
      les etudiants sachent quoi coder environ juste avec les commentaires
    . bootstrap, bootloader: OK

--
 cours:

  . os distribues
  . linkers
  . archi

--
 mettre toutes les regles de -old-/README dans kaneton.tex

--
 faire le set de hash et tableau par solal au pire ou un inge1

--
 faire des tests sur les ensembles et sur les segments: jacob_s

--
 array: recherche dichotomique lorsqu il est trie

--
 expliquer les design patterns: factory (id, segment, set etc..)

--
 expliquer dans le readme comment generer les dep

--
 coder les fonctions clone: as_clone(), set_clone(), id_clone() etc..

 ca va etre vachement chiant de faire un set_clone(). pourtant tous les
 autres clone() vont forcement y faire appel.
 d'un autre cote une fois code ce sera trop simple de faire les autre

--
 http://perso.wanadoo.fr/philippe.michel/qnx/

 http://xos.freezee.org/index.php?page=video

--
 assert() a coder

--
 repartir les prototypes dans arch/ia32/machdep.h dans les autres fichiers.

--
 rajouter la compression dans grub.sh et le stripping aussi
 avec option

--
 faire la moulinette de decoupage en foncion de balises

-- vbe

http://xos.freezee.org/doc/video/GUI_TUT.PDF
http://my.execpc.com/~geezer/os/
http://glek.net/subversion/os/
http://www.vesa.org/Public/VBE/
http://66.249.93.104/search?q=cache:z5-PUmUi77IJ:www.inversereality.org/files/vesavideomodes.pdf+vbe2+pdf&hl=fr
http://ript.net/~spec/vbe2/

http://www.djm.co.za/spoon/grub/install.php
http://www.student.cs.uwaterloo.ca/~cs452/grub/

http://www.openbg.net/sto/os/xml/grub.html

http://rampex.ihep.su/Linux/linux_howto/html/tutorials/mini/Vesafb-5.html

http://www.mega-tokyo.com/forum/index.php?board=1;action=display;threadid=6186;start=0
http://bcos.hopto.org/index.html
http://www.google.com/search?hl=en&ie=UTF-8&q=vesa+programming

/* --------------------------------------------XXX-------------------------- */

typedef unsigned short dw;
typedef unsigned char db;
typedef unsigned int dd;

typedef struct vbe_modeinfoblock
{
  /* Mandatory information for all VBE revisions */
  dw mode_attributes;
  db win_a_attributes,win_b_attributes;
  dw win_granulatiry, win_size, win_a_segment, win_b_segment;
  dd win_func_ptr;
  dw bytes_per_scan_line;

  /* Mandatory information for VBE 1.2 and above */
  dw x_resolution, y_resolution;
  db x_char_size, y_char_size, number_of_planes, bits_per_pixel;
  db number_of_banks, memory_model, bank_size, number_of_image_pages;
  db reserved1;

  db red_mask_size ,red_field_position;
  db green_mask_size, green_field_position;
  db blue_mask_size, blue_field_position;
  db rsvd_mask_size, rsvd_field_position;
  db direct_color_mode_info;

  /* Mandatory information for VBE 2.0 and above */
  dd phys_base_ptr;
  dd reserved2;
  dw reserved3;

  /* Mandatory information for VBE 3.0 and above */
  dw lin_bytes_per_scan_line;
  db bnk_number_of_image_pages;
  db lin_number_of_image_pages;
  db lin_red_mask_size, lin_red_field_position;
  db lin_green_mask_size, lin_green_field_position;
  db lin_blue_mask_size, lin_blue_field_position;
  db lin_rsvd_mask_size, lin_rsvd_field_position;
  dd max_pixel_clock;
  db reserved4[189];

} __attribute((packed)) vbe_modeinfoblock_t;

void vesa(void* v)
{
  vbe_modeinfoblock_t* mib = v;

  int* video_base;

  int x_resolution, y_resolution, bits_per_pixel;

  video_base = (int *)mib->phys_base_ptr;
  x_resolution = mib->x_resolution;
  y_resolution = mib->y_resolution;
  bits_per_pixel = mib->bits_per_pixel;

  _main_();
}

/* code here */

#define SCREEN_WIDTH 320
#define SCREEN_HEIGHT 200

unsigned char *VGA = (unsigned char *)0xA0000;
unsigned char *dbl_buffer;

typedef struct tagBITMAP /* the structure for a bitmap. */
{
  unsigned int width;
  unsigned int height;
  unsigned char *data;
} BITMAP;

typedef struct tagRECT
{
  long x1;
  long y1;
  long x2;
  long y2;
} RECT;

void init_dbl_buffer(void)
{
  dbl_buffer = (unsigned char *) malloc (SCREEN_WIDTH * SCREEN_HEIGHT);
  if (dbl_buffer == NULL)
    {
      printf("Not enough memory for double buffer.\n");

      /* XXX */
      /*
      getch();
      exit(1);
      */
      while (1);
    }
}

void update_screen(void)
{
#ifdef VERTICAL_RETRACE
  while ((inportb(0x3DA) & 0x08));
  while (!(inportb(0x3DA) & 0x08));
#endif
  memcpy(VGA, dbl_buffer, (unsigned int)(SCREEN_WIDTH * SCREEN_HEIGHT));
}

void setpixel (BITMAP *bmp, int x, int y, unsigned char color)
{
  bmp->data[y * bmp->width + x];
}

/* Draws a filled in rectangle IN A BITMAP. To fill a full bitmap call as drawrect (&bmp, 0, 0, bmp.width, bmp.height, color);*/

void drawrect(BITMAP *bmp, unsigned short x, unsigned short y, unsigned short x2, unsigned short y2, unsigned char color)
{
  unsigned short tx, ty;
  for (ty = y; ty < y2; ty++)
    for (tx = x; tx < x2; tx++)
      setpixel (bmp, tx, ty, color);
}

void draw_bitmap_old(BITMAP *bmp, int x, int y)
{
  int j;
  unsigned int screen_offset = (y << 8) + (y << 6) + x;
  unsigned int bitmap_offset = 0;
  for(j = 0; j < bmp->height; j++)
    {
      memcpy(&dbl_buffer[screen_offset], &bmp->data[bitmap_offset], bmp->width);
      bitmap_offset += bmp->width;
      screen_offset += SCREEN_WIDTH;
    }
}

void _main_(void)
{

  /* XXX */
  {
    int i;

    for (i = 0; i < 4000; i++)
      VGA[i] = 0xff;
  }
  /* XXX */

  /* You must clear the double buffer every time to avoid evil messes (go ahead and try without this, you will see) */

  memset (dbl_buffer, 0, SCREEN_WIDTH * SCREEN_HEIGHT);
  /* DRAW ALL BITMAPS AND DO GUI CODE HERE */
  /* Draws the double buffer */

  update_screen();
}

/* /code here */


/* code here -> reboot ---- ------------------------------------------------ */

typedef unsigned short WORD;
typedef unsigned char BYTE;
typedef unsigned int DWORD;

/* Structure for VESA BIOS EXTENTION mode information as defined by VESA */
typedef struct tagSVGAMODEINFO
{

  /* mandatory information for all VBE verson */
  WORD modeattributes;          /* Mode attributes  */
  BYTE winattributes;           /* Window A attributes */
  BYTE winbattributes;          /* Window B attributes */
  WORD wingranularity;          /* Window granularity */
  WORD winsize;              /* Window size */
  WORD winasegment;           /* Window A start segment */
  WORD winbsegment;           /* Window B segment  */
  DWORD winfuncptr;           /* pointer to window function */
  WORD bytesperscanline;        /* Bytes per scanline  */


  /* Mandatory information for VBE 1.2 and higher */
  WORD xresolution;           /* Horizontal resolution in pixels */
  WORD yresolution;           /* Vertical resolution in pixel */
  BYTE xcharsize;              /* Character cell width in pixels */
  BYTE ycharsize;              /* Character cell height in pixels */
  BYTE numberofplanes;        /* Number of memoryplanes  */
  BYTE bitsperpixel;           /* bits per pixel  */
  BYTE numberofbanks;           /* Number of banks  */
  BYTE numberofimagepages;     /* Number of images  */
  BYTE reserved1;              /* Reserved for page function */

  /* Direct color fields */
  BYTE redmasksize;            /* size of direct color red mask in bits */
  BYTE redfieldposition;        /* Bit position of lsb of red mask */
  BYTE greenmasksize;          /* size of direct color green mask in bits */
  BYTE greenfieldposition;     /* Bit position of lsb of green mask */
  BYTE bluemasksize;            /* size of direct color blue mask in bits */
  BYTE bluefieldposition;        /* Bit position of lsb of blue mask */
  BYTE rsvdmasksize;            /* size of direct color reserved mask in bits */
  BYTE reservedfieldposition;     /* Bit position of lsb of reserved mask */
  BYTE directcolormodeinfo;    /* Direct color mode attributes  */

  /* Mandatory information for VBE 2.0 and above    */
  DWORD physbaseptr;           /* Physical addres for flat frame buffer */
  DWORD offscreenmemoffset;     /* Pointer to start of off screen memory */
  WORD offscreenmemsize;        /* Amount of offscreen memory in 1kb units */
  char reserved2[206];        /* Reserved */
} SVGAMODEINFO;

char font_a[]= {0x00, /* 00000000 */
		0x00, /* 00000000 */
		0x00, /* 00000000 */
		0x00, /* 00000000 */
		0x00, /* 00000000 */
		0x78, /* 01111000 */
		0x0c, /* 00001100 */
		0x7c, /* 01111100 */
		0xcc, /* 11001100 */
		0xcc, /* 11001100 */
		0xcc, /* 11001100 */
		0x76, /* 01110110 */
		0x00, /* 00000000 */
		0x00, /* 00000000 */
		0x00, /* 00000000 */
		0x00};

unsigned long  RGBA_black = 0x00000000;

#define CHAR_HEIGHT    16
#define CHAR_WIDTH    8

unsigned long *framebuffer;

SVGAMODEINFO *vbe_mode_info;

void show_character(char *font, unsigned long *VRAM,
		    unsigned long color, int rowlength);

int vbe_init(multiboot_info_t *mbi)
{
  int i, j;

  printf("init VBE ... ");

  if(mbi->flags & (1 << 11))
    {
      vbe_mode_info = (SVGAMODEINFO *)mbi->vbe_mode_info;

      framebuffer = (unsigned long *)vbe_mode_info->physbaseptr;

      if(framebuffer != NULL)
	{
	  int offset = 0;

	  for(j=0; j < 600; j++)
	    {
	      for(i=0; i < 800; i++)
		{
		  offset = 800*j + i;
		  framebuffer[offset] = RGBA_black;
		}
	    }
	  show_character(font_a,framebuffer,0xFFFFFFFF, 800);
	}
    }
  return 0;
}

void show_character(char *font, unsigned long *VRAM,
		    unsigned long color, int rowlength)
{
  int i, j;

  for (i=0;i<CHAR_HEIGHT;i++,VRAM+=rowlength)
    {
      unsigned long *row=VRAM;

      for (j=1<<CHAR_WIDTH;j!=0;j=j>>1)
	{
	  if (font[i]&j) *row=color;
	  row++;
	}
    }
}

/* /code here -> reboot ---- ----------------------------------------------- */

--
 500 heures -> 12 500 euros (budget ~10 000 euros)

 tarif: 25 euros de l heure
