--
 rajouter buckman au svn

--
 -VIEWER car viewer de base pour l'archi

--
 mettre une licence sur le code

 mettre a jour tous les headers pour pointer sur la licence.

--
 buckman: cours makefile, fin cours dev-env avec explication du
  systeme de compil kaneton + seminaire.

 gollum: faire compiler en sm netbsd

 dujardin: +cous archi-mips, budget?

--
 if (machdep...)
   LEAVE

--
 un seul swapper et on active ou non des options: network, hard drive etc..
 car un swapper ca stocke de la memoire sur un support secondaire qui peut
 etre n'importe quoi, une disquette, une clef usb etc..

--
 permettre aux etudiants de choisir leur archi: mips, intel, amd, sparc ...

--
 revoir interface de makefile car pas super performante. $(call version) chie.

 ignorer les options pour l'instant car plus tard: --no-newline etc..

--
 revoir la console car ca deconne. faire des tests avec la moulinette tiens.

--
 detecter taille de fenetre -> [PROTO] .../chiche/

--
 oceansize premiere partie de porcupine tree

--
 retoucher les fonctions shell pour que ca fonctionne bien avec des bons
 noms

--
 bugs dans stats car quand je l'active ca plante. faudrait revoir ca.

--
 revoir la generation de version.c

--
 trouver du matos a acheter avec le budget

--
 proposer deux sujets sur le vrai kaneton par exemple aux deux meilleurs
 groupes: integration du SMP, nommage, new archi etc..

--
 modifier le script export.sh

--
 dans design, il y a bcp trop de relations au distribue. il faut le splitter
 et mettre une partie dans kayou. une fois retouche et la partie microkernel
 isolee on pourra le mettre sur le site.

 revoir egalement seminar

--
 bouger le cours distributed-operating-systems dans kayou

--
 le fait de filer des params dans un fichier de conf implique qu on
 soit capable aussi de lancer ce meme service une fois le kernel boote.

 il faudra donc fournir un moyen de passer les meme params, capabilities
 inclues. il faudra ptet un filesystem pour mod assez complet.

--
 sujets pour etudiants:
   - integration du smp dans kaneton: pour, contre? modifications?
   - complete naming scheme: objects

 mettre tous ces trucs dans seminars avec petite explication.

--
 systeme de nommage style: machine::service::subpart::object

 exemples:

    mybox::core::segment::1  // segment 1 du core
    yourbox::mod::*          // tous les modules de mod

 on pourrait imaginer un systeme de regexp :)

 ensuite si une tache comme une tache root demande une capability sur
 son espace d'adressage, c'est mod qui demandera a core la cap de l'as
 et qui la retournera.

 on pourrait imaginer encore plus loin

    mybox::core::task:: taskid == 1
    mybox::core::segment:: size >= 100 && size <= 200

--
 il faudrait resoudre ce probleme de user. le kernel ne doit pas gerer
 les users. comment faire ???

 peut etre sommes nous obliges de rajouter un ownid?

--
 pour par exemple un driver, il faudra qu il soit capable de communiquer
 avec le hard autrement dit de se rajouter une trap.

 pour cela il faudra dans mod lui filer soit une cap precise sur l'evenement
 precise, soit une cap sur le gestionnaire d'evenements.

--
 utiliser les meme noms de fonctions pour make et shell

--
 faire des users:

  1) check: pour lancer la moulinette
  2) release: pour faire une demo ca nous aidera a noter et a voir ce qu ils
              ont fait en plus

--
 revoir conf.c et conf.h dans la partie user. le conf.h a la limite
 par contre le conf.c est un peu particulier.

--
 faire les logos: kaneton + kayou

--
 developer un kfs, un systeme de fichiers qui pourrait lister les objets
 du kernel: comme ca on pourrait acceder aux objects et ca resoudrait le
 lancement des services.

 ou mieux etudier Sprite et voir comment ils font eux avec leurs systeme
 de nommage.

 ca a eviter si systeme de nommage.

--
 segments: code complet + dump + show + partie dep (on refait)

 il faudra rajouter dans le bootloader init.c un segment correspondant
 au dma: SEGMENT_TYPE_CATCH

--
 faire le le schema pour cursus/schedule

--
 mieux decouper les drivers et modules en fonctions de leur types:

   drivers/
     block/
     char/
     ...

   services/
     ...

--
 dans le document assignments, explicite tout genre reprendre les commentaires
 des fonctions. enfin le truc c'est que l'etudiant se fasse pas nique
 parcequ on avait pas precise le role de la fonction set_clone() et des
 comportements en fonction des options: opts

--
 forme d'une presentation de k:
  . pourquoi une telle modelisation: pour/contre, autres systemes
  . que doit faire l'etudiant
  . comment
  . rendu?

--
 parser: params et args

 int		main(int argc, char** argv);

 ce sera conforme a un truc classique avec la forme:

   --verbose		1

 concernant les params, ce sont juste des arguments interpretes par le
 gestionnaire de modules.

--
 une fois le gestionnaire de regions installe, essayer de faire un
 acces a l'adresse 0, normalement ca fait planter.

--
 continuer le cours sur loaders linkers de fab: linker.iecc.com

--
 retoucher mkp.py pour qu'il marche: t_bpt_addr() addr
 -> et rajouter le chemin relatif de set_bpt.c dans
    core/include/kaneton/set.h
 mkp: gerer t_bpt_addr(set), les fonctions statiques, les fonctions
 qui sont dans un commentaire etc..

--
 systeme de reboot automatique

--
 fonction de segments et regions pour faire p->v v->p

-- messages
 faire un msg_build(size) qui va creer un segment partage et renvoyer
 un segid cache dans un msgid. ensuite on fait msg_send(msgid). quand
 de l'autre cote il fait un msg_receive(*msgid) il recoit le msgid
 donc le segid pour le segment partage, il fait un truc style msg_pack()
 et ca lui mappe le segment partage et hop il accede au message qui peut
 donc a la fois etre de taille indeterminee, et le kernel ne manipule que
 des identifiants de message, rien d'autre donc facile a passer.

 pour les message, soit mettre aucune protection cad tout le monde peut
 communiquer avec tlm soit le mec qui recoit cree des filtres sur les
 emmeteurs et transmet ces filtres au kernel. comme ca il n'y aura verification
 que si le recepteur veut limiter les emmeteurs.

 on peut aussi considerer le cas avec une capability sur les messages mais
 ca ca risque de prendre du temps a verifier a chaque fois + problemes
 car serveur d'auth detient ces infos et doit les partager avec le kernel
 donc probleme.

 voir ca avec cedric.

-- swap
 faire du swap sur le reseau et sur le disque mais experimenter
 le reseau.

 <reflexion>
 le swapper (reseau ou disk) sera un service sinon c'est laid de base.

 le swapper doit obtenir des infos sur l'utilisation de zones memoire.

 habituellement il recupere les infos sur des pages mais dans kaneton
 tout se base sur des segments, les seuls objets memoire identifiables.

 donc deja de base on swappera des segments.

 ensuite sur intel par exemple on recupere les infos via la memoire
 virtuelle car c'est la MMU qui est capable de connaitre les acces memoire

 or si on se base d'un point de vue logique c est la memoire choses que les
 permissions. c'est implemente par la memoire virtuelle mais ca concerne
 des zones physiques.

 donc en realite on va dire, comme pour les perms, que les infos d'utilisation
 se trouve en relation avec des segments.

 donc, le swapper demandera au gestionnaire de segment son etat (taux
 d'utilisation de la memoire physique) toutes les N secondes. si ce taux
 est trop eleve il faut swapper des segments. il va donc demande au
 gestionnaire de segments de lui donner l'identifiant du segment le moins
 utilise. il va ensuite prendre le segment et le mettre sur disque.

 de plus il faudra marque le segment comme non-present mais egalement la
 region pour que la partie dep fasse ce qu il faut.

 attention: ok pour le mettre sur disque mais ensuite lorsqu il y aura un
 acces comment le recuperer? un systeme de pagger doit etre mis en place.

 attention: pour que le swapper puisse acceder comme il veut aux segment
 il faut qu il ait une capability pour chaque, ou alors une capability generale
 sur le gestionnaire de segment. il faut regler ce probleme pour pouvoir
 fournir des cap generic.

 attention: comment donner cette cap generique, a quel moment etc.. :(((

 attention: rajouter un type de segment: swap ou non-present

 attention: dans le cas d'un swapper reseau et disk ils vont se marcher dessus
   D: etat
   R: etat
   D: zone moins utilisee
   R: zone moins utilisee
   D: je prends cette zone pour la swappee
   R: je prends cette zone pour la swappee: ERROR zone inexistante
   etc.. tout le temps

 donc soit faire les deux en uns, soit faire des timer qui se chevauchent soit
 faire en sorte qu ils communiquent ou je sais pas.

 !!! bcp de problemes, ca sent le cul.
 </reflexion>

 <reflexion>
 autre solution, le crt cree un thread qui va checker tous les N l'etat
 de la memoire et demande un segment lui appartenant et peu utilise sur
 il faut swapper.

 bref que le user le fasse et qu il transmette les cap a un service swap
 a la limite.

 mais ca aussi pas terrible.

 ARFFFFFFFFFFF!
 </reflexion>

 bon on verra plus tard sinon j'avancerai jamais le code!

-- norme commit
  [core/kaneton/set/set_bpt.c]
    1) init function updated to properly handle set options.
    2) ...

  [core/kaneton/kaneton.c]
    1) ...

  -> les points 1,2,3 etc.. sont pas ordre d'importance

--
 essayer de faire compiler kaneton sur netbsd a l ecole:

--
 lister les trucs qui reste a faire:

  1) moulinette de tests
  2) des tests pour set, as, segment, regions
  3) finir intra
  4) integrer la moulinette dans l intra: boot automatique, tftp etc..
  5) slides presentations kaneton [*]
  7) cours: cpp [*], inline assembly [*], gnu make
  8) presentation kaneton, tarball etc.. -> develpment-tree
     cours revisions: C, asm, etc.. faire quelques slides [*]
  9) cours noyaux
  10) retoucher cours intel, avec beamer bien etc.. images au bon format
  12) finir le code de kaneton jusqu'aux regions
  13) moulinette de decoupage de code [*]
  14) decouper le code: make export-0 et commenter chaque partie pour que
      les etudiants sachent quoi coder environ juste avec les commentaires
    . k0: bootstrap [*]
    . k1: bootloader [*]
    . k2: id, set, as, segment

--
 cours:

  . os distribues
  . linkers
  . archi

--
 mettre toutes les regles de -old-/README dans kaneton.tex

--
 faire le set de hash et tableau

--
 array: recherche dichotomique lorsqu il est trie

--
 http://perso.wanadoo.fr/philippe.michel/qnx/

 http://xos.freezee.org/index.php?page=video

--
 rajouter la compression dans grub.sh et le stripping aussi
 avec option

-- vbe

http://xos.freezee.org/doc/video/GUI_TUT.PDF
http://my.execpc.com/~geezer/os/
http://glek.net/subversion/os/
http://www.vesa.org/Public/VBE/
http://66.249.93.104/search?q=cache:z5-PUmUi77IJ:www.inversereality.org/files/vesavideomodes.pdf+vbe2+pdf&hl=fr
http://ript.net/~spec/vbe2/

http://www.djm.co.za/spoon/grub/install.php
http://www.student.cs.uwaterloo.ca/~cs452/grub/

http://www.openbg.net/sto/os/xml/grub.html

http://rampex.ihep.su/Linux/linux_howto/html/tutorials/mini/Vesafb-5.html

http://www.mega-tokyo.com/forum/index.php?board=1;action=display;threadid=6186;start=0
http://bcos.hopto.org/index.html
http://www.google.com/search?hl=en&ie=UTF-8&q=vesa+programming

/* --------------------------------------------XXX-------------------------- */

typedef unsigned short dw;
typedef unsigned char db;
typedef unsigned int dd;

typedef struct vbe_modeinfoblock
{
  /* Mandatory information for all VBE revisions */
  dw mode_attributes;
  db win_a_attributes,win_b_attributes;
  dw win_granulatiry, win_size, win_a_segment, win_b_segment;
  dd win_func_ptr;
  dw bytes_per_scan_line;

  /* Mandatory information for VBE 1.2 and above */
  dw x_resolution, y_resolution;
  db x_char_size, y_char_size, number_of_planes, bits_per_pixel;
  db number_of_banks, memory_model, bank_size, number_of_image_pages;
  db reserved1;

  db red_mask_size ,red_field_position;
  db green_mask_size, green_field_position;
  db blue_mask_size, blue_field_position;
  db rsvd_mask_size, rsvd_field_position;
  db direct_color_mode_info;

  /* Mandatory information for VBE 2.0 and above */
  dd phys_base_ptr;
  dd reserved2;
  dw reserved3;

  /* Mandatory information for VBE 3.0 and above */
  dw lin_bytes_per_scan_line;
  db bnk_number_of_image_pages;
  db lin_number_of_image_pages;
  db lin_red_mask_size, lin_red_field_position;
  db lin_green_mask_size, lin_green_field_position;
  db lin_blue_mask_size, lin_blue_field_position;
  db lin_rsvd_mask_size, lin_rsvd_field_position;
  dd max_pixel_clock;
  db reserved4[189];

} __attribute((packed)) vbe_modeinfoblock_t;

void vesa(void* v)
{
  vbe_modeinfoblock_t* mib = v;

  int* video_base;

  int x_resolution, y_resolution, bits_per_pixel;

  video_base = (int *)mib->phys_base_ptr;
  x_resolution = mib->x_resolution;
  y_resolution = mib->y_resolution;
  bits_per_pixel = mib->bits_per_pixel;

  _main_();
}

/* code here */

#define SCREEN_WIDTH 320
#define SCREEN_HEIGHT 200

unsigned char *VGA = (unsigned char *)0xA0000;
unsigned char *dbl_buffer;

typedef struct tagBITMAP /* the structure for a bitmap. */
{
  unsigned int width;
  unsigned int height;
  unsigned char *data;
} BITMAP;

typedef struct tagRECT
{
  long x1;
  long y1;
  long x2;
  long y2;
} RECT;

void init_dbl_buffer(void)
{
  dbl_buffer = (unsigned char *) malloc (SCREEN_WIDTH * SCREEN_HEIGHT);
  if (dbl_buffer == NULL)
    {
      printf("Not enough memory for double buffer.\n");

      /* XXX */
      /*
      getch();
      exit(1);
      */
      while (1);
    }
}

void update_screen(void)
{
#ifdef VERTICAL_RETRACE
  while ((inportb(0x3DA) & 0x08));
  while (!(inportb(0x3DA) & 0x08));
#endif
  memcpy(VGA, dbl_buffer, (unsigned int)(SCREEN_WIDTH * SCREEN_HEIGHT));
}

void setpixel (BITMAP *bmp, int x, int y, unsigned char color)
{
  bmp->data[y * bmp->width + x];
}

/* Draws a filled in rectangle IN A BITMAP. To fill a full bitmap call as drawrect (&bmp, 0, 0, bmp.width, bmp.height, color);*/

void drawrect(BITMAP *bmp, unsigned short x, unsigned short y, unsigned short x2, unsigned short y2, unsigned char color)
{
  unsigned short tx, ty;
  for (ty = y; ty < y2; ty++)
    for (tx = x; tx < x2; tx++)
      setpixel (bmp, tx, ty, color);
}

void draw_bitmap_old(BITMAP *bmp, int x, int y)
{
  int j;
  unsigned int screen_offset = (y << 8) + (y << 6) + x;
  unsigned int bitmap_offset = 0;
  for(j = 0; j < bmp->height; j++)
    {
      memcpy(&dbl_buffer[screen_offset], &bmp->data[bitmap_offset], bmp->width);
      bitmap_offset += bmp->width;
      screen_offset += SCREEN_WIDTH;
    }
}

void _main_(void)
{

  /* XXX */
  {
    int i;

    for (i = 0; i < 4000; i++)
      VGA[i] = 0xff;
  }
  /* XXX */

  /* You must clear the double buffer every time to avoid evil messes (go ahead and try without this, you will see) */

  memset (dbl_buffer, 0, SCREEN_WIDTH * SCREEN_HEIGHT);
  /* DRAW ALL BITMAPS AND DO GUI CODE HERE */
  /* Draws the double buffer */

  update_screen();
}

/* /code here */


/* code here -> reboot ---- ------------------------------------------------ */

typedef unsigned short WORD;
typedef unsigned char BYTE;
typedef unsigned int DWORD;

/* Structure for VESA BIOS EXTENTION mode information as defined by VESA */
typedef struct tagSVGAMODEINFO
{

  /* mandatory information for all VBE verson */
  WORD modeattributes;          /* Mode attributes  */
  BYTE winattributes;           /* Window A attributes */
  BYTE winbattributes;          /* Window B attributes */
  WORD wingranularity;          /* Window granularity */
  WORD winsize;              /* Window size */
  WORD winasegment;           /* Window A start segment */
  WORD winbsegment;           /* Window B segment  */
  DWORD winfuncptr;           /* pointer to window function */
  WORD bytesperscanline;        /* Bytes per scanline  */


  /* Mandatory information for VBE 1.2 and higher */
  WORD xresolution;           /* Horizontal resolution in pixels */
  WORD yresolution;           /* Vertical resolution in pixel */
  BYTE xcharsize;              /* Character cell width in pixels */
  BYTE ycharsize;              /* Character cell height in pixels */
  BYTE numberofplanes;        /* Number of memoryplanes  */
  BYTE bitsperpixel;           /* bits per pixel  */
  BYTE numberofbanks;           /* Number of banks  */
  BYTE numberofimagepages;     /* Number of images  */
  BYTE reserved1;              /* Reserved for page function */

  /* Direct color fields */
  BYTE redmasksize;            /* size of direct color red mask in bits */
  BYTE redfieldposition;        /* Bit position of lsb of red mask */
  BYTE greenmasksize;          /* size of direct color green mask in bits */
  BYTE greenfieldposition;     /* Bit position of lsb of green mask */
  BYTE bluemasksize;            /* size of direct color blue mask in bits */
  BYTE bluefieldposition;        /* Bit position of lsb of blue mask */
  BYTE rsvdmasksize;            /* size of direct color reserved mask in bits */
  BYTE reservedfieldposition;     /* Bit position of lsb of reserved mask */
  BYTE directcolormodeinfo;    /* Direct color mode attributes  */

  /* Mandatory information for VBE 2.0 and above    */
  DWORD physbaseptr;           /* Physical addres for flat frame buffer */
  DWORD offscreenmemoffset;     /* Pointer to start of off screen memory */
  WORD offscreenmemsize;        /* Amount of offscreen memory in 1kb units */
  char reserved2[206];        /* Reserved */
} SVGAMODEINFO;

char font_a[]= {0x00, /* 00000000 */
		0x00, /* 00000000 */
		0x00, /* 00000000 */
		0x00, /* 00000000 */
		0x00, /* 00000000 */
		0x78, /* 01111000 */
		0x0c, /* 00001100 */
		0x7c, /* 01111100 */
		0xcc, /* 11001100 */
		0xcc, /* 11001100 */
		0xcc, /* 11001100 */
		0x76, /* 01110110 */
		0x00, /* 00000000 */
		0x00, /* 00000000 */
		0x00, /* 00000000 */
		0x00};

unsigned long  RGBA_black = 0x00000000;

#define CHAR_HEIGHT    16
#define CHAR_WIDTH    8

unsigned long *framebuffer;

SVGAMODEINFO *vbe_mode_info;

void show_character(char *font, unsigned long *VRAM,
		    unsigned long color, int rowlength);

int vbe_init(multiboot_info_t *mbi)
{
  int i, j;

  printf("init VBE ... ");

  if(mbi->flags & (1 << 11))
    {
      vbe_mode_info = (SVGAMODEINFO *)mbi->vbe_mode_info;

      framebuffer = (unsigned long *)vbe_mode_info->physbaseptr;

      if(framebuffer != NULL)
	{
	  int offset = 0;

	  for(j=0; j < 600; j++)
	    {
	      for(i=0; i < 800; i++)
		{
		  offset = 800*j + i;
		  framebuffer[offset] = RGBA_black;
		}
	    }
	  show_character(font_a,framebuffer,0xFFFFFFFF, 800);
	}
    }
  return 0;
}

void show_character(char *font, unsigned long *VRAM,
		    unsigned long color, int rowlength)
{
  int i, j;

  for (i=0;i<CHAR_HEIGHT;i++,VRAM+=rowlength)
    {
      unsigned long *row=VRAM;

      for (j=1<<CHAR_WIDTH;j!=0;j=j>>1)
	{
	  if (font[i]&j) *row=color;
	  row++;
	}
    }
}

/* /code here -> reboot ---- ----------------------------------------------- */

--
 500 heures -> 12 500 euros (budget ~10 000 euros)

 tarif: 25 euros de l heure
