%%
%% copyright quintard julien
%% 
%% kaneton
%% 
%% kn.tex
%% 
%% path          /home/mycure/data/research/projects/svn/kaneton/projects/kn
%% 
%% made by mycure
%%         quintard julien   [quinta_j@epita.fr]
%% 
%% started on    Tue Mar 29 02:00:12 2005   mycure
%% last update   Thu Apr  7 10:44:09 2005   mycure
%%

\documentclass[10pt,a4wide]{article}
\usepackage[english]{babel}
\usepackage{a4wide}
\usepackage{graphicx}
\usepackage{graphics}
\usepackage{fancyheadings}
\usepackage[T1]{fontenc}
\pagestyle{fancy}

\bibliographystyle{plain}

\lhead{\scriptsize{kaneton project}}
\rhead{k\ng}
\rfoot{\scriptsize{EPITA System Lab}}

\title{kaneton-\ng}

\author{Julien Quintard - \small{quinta\_j@epita.fr} \\
        Jean-Pascal Billaud - \small{billau\_j@epita.fr} \\ \\
	\small{last updated by} \\
	Julien Quintard - \small{quinta\_j@epita.fr}}

\date{\today}

\begin{document}
\maketitle

\section{Introduction}

\paragraph{}

Ce document est destin\'e \`a rassembler toutes les informations concernant
le projet en g\'en\'eral et non une tranche en particulier.

\paragraph{}

Nous aborderons ici toutes les probl\'ematiques li\'ees \`a la portabilit\'e,
la factorisation de code, l'\'etablissement d'interfaces simples mais
\'egalement la hi\'erarchie de votre projet etc..

\section{Portabilit\'e}

\paragraph{}

Une question importante que l'\'etudiant devrait se poser est:
Comment bien dissocier la partie ``machine dependent'' de la partie
``machine independent''? Comment lancer, par exemple, la fonction
\textbf{seg\_init}() sur l'architecture IA-32 mais par sur l'architecture
Sparc?

\paragraph{}

Tout d'abord une partie d\'ependante de l'architecture est d\'ecoup\'ee en
gestionnaires tout comme la partie ind\'ependante de l'architecture: pm, as,
task, sched etc..

\paragraph{}

Du point de vue de la partie d\'ependante de l'achitecture, chaque
gestionnaire est compos\'e d'une interface d\'ecrivant les actions
pouvant \^etre entreprises et bien entendu d'un ensemble de donn\'ees.

\paragraph{}

L'interface et les donn\'ees ne sont jamais acc\'ed\'ees directement
par la partie ind\'ependante de l'architecture mais plut\^ot via
trois op\'erations pr\'ed\'efinies: \textbf{machdep\_declare}(),
\textbf{machdep\_call}() et \textbf{machdep\_include}(); ces trois op\'erations
\'etant d\'efinies exclusivement par la partie d\'ependante de l'architecture,
g\'en\'eralement sous forme de \textit{macros}.

\paragraph{}

\hspace{1.5cm}\#define \textbf{machdep\_declare}(\_mng\_);

\paragraph{}

Cette fonction permet \`a la partie d\'ependante de l'architecture de rajouter
des d\'eclarations. Cela sera extr\^ement utile pour d\'eclarer des variables
\textit{extern} comme par exemple les interfaces d\'ependantes de l'architecture.

\paragraph{}

\hspace{1.5cm}\#define \textbf{machdep\_call}(\_mng\_,
                                              \_function\_,
                                              \_args\_...);

\paragraph{}

L'op\'eration \textbf{machdep\_call}() permet de faire appel \`a la
fonctionnalit\'e \textbf{\_function\_} offerte, ou non, par
la partie d\'ependante de l'architecture du gestionnaire
\textbf{\_mng\_}.

\paragraph{}

\hspace{1.5cm}\#define \textbf{machdep\_include}(\_object\_);

\paragraph{}

L'op\'eration \textbf{machdep\_include}() permet de demander \`a la partie
d\'ependante de l'architecture si celle-ci d\'esire inclure des donn\'ees
dans l'objet \textbf{object}.

\paragraph{}

Comme vous pouvez le constater, tout est fait pour que la partie ind\'ependante
ne soit pas au courant de ce que fait la partie d\'ependante. De plus
la partie d\'ependante peut d\'ecider d'impl\'ementer l'interface
et/ou d'inclure des donn\'ees. Voici quelques exemples plus parlant
qui montrent bien la libert\'e offerte \`a la partie d\'ependante
de l'architecture concernant l'impl\'ementation.

\paragraph{}

Attention, tous les exemples qui suivent ne repr\'esentent absolument
pas les r\'eelles structures et interfaces que vous devez impl\'ementer
durant les projets.

\paragraph{}

Il est important de noter qu'une interface est toujours d\'eclar\'ee en
utilisant le pr\'efixe \textbf{i\_} et qu'une structure d\'efinisant
des donn\'ees d\'ependantes et toujours pr\'efix\'ee par \textbf{d\_}.
L'utlisation de tels pr\'efixes permet de toujours s'y retrouver
tr\`es rapidement dans le code.

\paragraph{}

Imaginons une architecture \textit{imaginaire} sur laquelle aucune
partie d\'ependante de l'architecture ne serait n\'ecessaire,
\textbf{machdep\_declare}(), \textbf{machdep\_call}() et
\textbf{machdep\_include}() pourraient \^etre impl\'ement\'ees de la sorte:

\begin{verbatim}

-- include/ia-32/machdep.h

[...]

#define machdep_declare(_mng_)                                          \
  /* nothing */

[...]

#define machdep_call(_mng_, _function_, _args_...)                      \
  /* nothing */

#define machdep_include(_object_)                                       \
  /* nothing */

[...]

\end{verbatim}

\paragraph{}

Cet exemple est parlant car il montre bien que cette architecture ne veut
rien impl\'ementer. Pour cela, la partie d\'ependante de l'architecture
se contente de d\'efinir les trois op\'erations comme ``vides'' et le tour
est jou\'e. L'architecture ne d\'efinira absolument rien de plus.

\paragraph{}

En revanche sur une architecture dit \textit{normale}, l'impl\'ementation
ressemblerait plus \`a cela:

\begin{verbatim}

-- include/ia-32/machdep.h

[...]

#define machdep_declare(_mng_)                                          \
  machdep_declare_##_mng_()

[...]

#define machdep_call(_mng_, _function_, _args_...)                      \
  machdep_call_##_mng_(_function_, _args_)

#define machdep_include(_object_)                                       \
  machdep_include_##_object_()

[...]

\end{verbatim}

\paragraph{}

Ensuite libre \`a la partie d\'ependante d'un gestionnaire d'impl\'ementer
les fonctionnalit\'es: interface et/ou donn\'ees, comme le d\'emontre
l'exemple suivant:

\begin{verbatim}

-- include/ia-32/as.h

[...]

#define machdep_declare_as()                                            \
  /* nothing */

[...]

#define machdep_call_as(_function_)                                     \
  /* nothing */

#define machdep_include_as()                                            \
  d_machdep_as  machdep;

[...]

-- kaneton/ia-32/as.c

[...]

typedef struct  d_machdep_as
{
  t_paddr       pd;
}               d_machdep_as;

[...]

-- include/kaneton/as.h

[...]

typedef struct  t_as
{
  /*
   * physical's data structure
   * virtual's data structure
   *
   * ...
   */

  machdep_include(as);
}

[...]

\end{verbatim}

\paragraph{}

La structure \textbf{t\_as} ressemblera finalement \`a cela:

\begin{verbatim}

typedef struct  t_as
{
  /*
   * physical's data structure
   * virtual's data structure
   *
   * ...
   */

  d_machdep_as  machdep;
}

\end{verbatim}

\paragraph{}

Bien entendu le code ind\'ependant de l'architecture du kernel s'engage
\`a ne jamais nommer un champ de structure \textbf{machdep}, celui-ci
\'etant exclusivement r\'eserv\'e \`a la partie d\'ependante de l'architecture.
Plus g\'en\'eralement le kernel \'evitera de nommer des structures, champ,
variables contenant le mot machdep pour laisser la partie d\'ependante libre.

\paragraph{}

Vous aurez bien entendu compris que l'avantage d'un tel syst\`eme est la
possibilit\'e pour la partie d\'ependante de ne pas d\'eclarer inutilement
ni de donn\'ees ni d'interface.

\paragraph{}

Voyons d\'esormais l'utilisation de l'interface des parties d\'ependantes
de l'architecture. Dans l'exemple pr\'ec\'edent, la partie d\'ependante
du gestionnaire d'espace d'adressage ne fournissait aucune interface.
Voyons d\'esormais un exemple contraire.

\begin{verbatim}

-- include/ia-32/pm.h

[...]

#define machdep_declare_pm(_mng_)                                       \
  extern i_machdep_pm machdep_pm_interface

[...]

#define machdep_call_pm(_function_, _args_...)                          \
  if (machdep_pm_interface._function_ != NULL)                          \
    machdep_pm_interface._function_(_args_)

#define machdep_include_pm()                                            \
  /* nothing */

[...]

-- kaneton/ia-32/pm.c

[...]

typedef struct  s_machdep_pm
{
  void          (*pm_init)(t_paddr      start,
                           t_paddr      size);

  /*
   * pm_rsv, pm_attr, pm_rel, pm_clean
   *
   * ...
   */
}               i_machdep_pm;

i_machdep_pm    machdep_pm_interface =
{
  ia32_pm_init,
  ia32_pm_rsv,
  NULL,
  ia32_pm_rel,
  ia32_pm_clean,
};

void            ia32_pm_init(t_paddr    start,
                             t_paddr    size)
{
  seg_init();

  seg_add([...]);
  seg_add([...]);
  seg_add([...]);
  seg_add([...]);

  [...]
}

[...]

-- kaneton/pm.c

[...]

/*
 * describes the system's physical memory
 */

t_pm            pm;

[...]

machdep_declare(pm);

[...]

int             pm_init(t_paddr         start,
                        t_paddr         size)
{
  machdep_call(pm, pm_init, start, size);

  [...]

  return (0);
}

/*
 * pm_rsv, pm_attr, pm_rel, pm_clean
 *
 * ...
 */

[...]

\end{verbatim}

\paragraph{}

\`A noter que nous aurions pu simplifier les macros pour \'eviter l'utilisation
de \textit{\_args...\_} comme l'exemple ci-dessous le d\'emontre.

\begin{verbatim}

-- include/ia-32/pm.h

[...]

#define machdep_call_pm(_function_)                                     \
  if (machdep_pm_interface._function_ != NULL)                          \
    machdep_pm_interface._function_

[...]

-- kaneton/pm.c

/*
 * describes the system's physical memory
 */

t_pm            pm;

[...]

machdep_declare(pm);

[...]

int             pm_init(t_paddr         start,
                        t_paddr         size)
{
  machdep_call(pm, pm_init)(start, size);

  [...]

  return (0);
}

/*
 * pm_rsv, pm_attr, pm_rel, pm_clean
 *
 * ...
 */

[...]

\end{verbatim}

\paragraph{}

Pour ceux qui d\'esirent appeller des fonctions qui retournent des valeurs
il faut modifier encore un petit peu les macros pour que celles-ci retransmettent
les valeurs de retour \`a la partie ind\'ependante de l'architecture.
Voici les macros que vous devrez utiliser. \`A noter qu'il vous sera impossible
de vous dispenser de l'utilisation de \textit{\_args\_...} si vous d\'esirez
\'evaluer les valeurs de retour.

\begin{verbatim}

-- include/ia-32/pm.h

[...]

#define machdep_declare_pm(_mng_)                                       \
  extern i_machdep_pm machdep_pm_interface

[...]

#define machdep_call_pm(_function_, _args_...)                          \
  (                                                                     \
    {                                                                   \
      int         _r_= 0;                                               \
                                                                        \
      if (machdep_pm_interface._function_ != NULL)                      \
        _r_ = machdep_pm_interface._function_(_args_);                  \
      _r_;                                                              \
    }                                                                   \
  )

#define machdep_include_pm()                                            \
  /* nothing */

[...]

-- kaneton/ia-32/pm.c

[...]

typedef struct  s_machdep_pm
{
  int          (*pm_init)(t_paddr      start,
                          t_paddr      size);

  /*
   * pm_rsv, pm_attr, pm_rel, pm_clean
   *
   * ...
   */
}               i_machdep_pm;

i_machdep_pm    machdep_pm_interface =
{
  ia32_pm_init,
  ia32_pm_rsv,
  NULL,
  ia32_pm_rel,
  ia32_pm_clean,
};

int             ia32_pm_init(t_paddr    start,
                             t_paddr    size)
{
  seg_init();

  seg_add([...]);
  seg_add([...]);
  seg_add([...]);
  seg_add([...]);

  [...]

  return (0);
}

[...]

-- kaneton/pm.c

[...]

/*
 * describes the system's physical memory
 */

t_pm            pm;

[...]

machdep_declare(pm);

[...]

int             pm_init(t_paddr         start,
                        t_paddr         size)
{
  if (machdep_call(pm, pm_init, start, size) != 0)
    ; /* error detected in the machine dependant code */

  [...]

  return (0);
}

/*
 * pm_rsv, pm_attr, pm_rel, pm_clean
 *
 * ...
 */

[...]

\end{verbatim}

\`A vous de choisir la m\'ethode que vous pr\'ef\'erez. Cel\`a peut jouer
concernant les environnement de compilation qui n'accepteront peut \^etre pas
\textit{\_args\_...} mais \'egalement en fonction des fonctionnalit\'es que vous
d\'esirez, valeurs de retour ou pas.

\section{Organisation}

\paragraph{}

Voici une vue d'ensemble sur l'organisation des vos fichiers sources
afin de rendre les compilations plus simples en fonction de l'architecture.

\paragraph{}

\begin{verbatim}
/

    /include                              /* includes */
        /kaneton                          /* system's header files */
        /machdep   -----------+
        /sparc-64             |
        /ia-32    <-----------+
            machdep.h
            as.h
            pm.h
            vm.h
            task.h
            [...]
        [...]

    /kaneton                              /* kaneton core */
        /machdep   -----------+
        /sparc-64             |
        /ia-32    <-----------+
            as.c
            pm.c
            task.c
            sched.c
            [...]
        as.c
        pm.c
        task.c
        sched.c
        [...]

    /lib
        /klibc                            /* kaneton C library */
            /machdep   -------+
            /sparc-64         |
            /ia-32    <-------+
            [...]
        /ulibc                            /* unix-emulation C library */
        /crt                              /* C run time */
        /lds                              /* ld scripts */

    /drivers
        /tty
        /ide
        [...]

    /services
        /dev
        /vfs
        [...]

    /users
        /ls
        /sh
        [...]
\end{verbatim}

\end{document}
