-- spargo

reflechir au kernel comme a fait phix c'est a dire pour eviter
la propagation:
  . mettre les structures importantes dans l espace user avec protection
    systeme
  . avec ca le kernel est tres petit
  . on a juste a faire une copie de l'as et hop on peut l'envoyer
    sur le reseau

-- spargo

etudier tout le SMP pour faire un gestionnaire de CPU et pour pouvoir
specifier les cpu sur lesquels vont tourner les threads

-- k4

BEHAV_KERNEL, BEHAV_REALTIME, BEHAV_... /* comportements */
PRIOR_KERNEL, PRIOR_REALTIME, PRIOR_... /* priorites par defaut */
CLASS_KERNEL, CLASS_DRIVER, CLASS_SERVICE, CLASS_USER

-- k4

TASK_FOREACH et THREAD_FOREACH ce serait pas mal quand meme

-- k4

repenser des trucs:
	. gestionnaire cpu pour recuperer la tache en cours et la thread
	en cours
	. gestionnaire de sched plus coherent
	. gestionnaire de tasks aussi

-- k4

les "deamons" ont comme parent mod qui lui meme a comme parent le kernel.
donc mod joue un peu le role de init.

-- k4

dire que l'emulation de fork est crade car N threads = N-1 stacks perdues.

il y a des moyens pour parer cela:
	1) pour tous les threads virer les stacks
	   ca necessite un appel systeme pour le faire ou
	   bien un appel systeme pour passer tous les threads

de toute facon on emule fork donc on s en fout un peu

-- spargo

dire que les signaux nous semblent prehistorique comme d'autre concepts
posix. donc on a pas implementer de signaux. neanmoins ils peuvent etre
emules.

-- k? for vfs

vfs_clone() qui va dupliquer une table de l ancien pour le nouveau.
lors d'un open read write, on matte le caller et on matte ensuite
sa table associee. on a donc une table par caller.

-- k4

thread
{
  stack_addr
  stack_npages
  entry_point
};

-- spargo

il faudra faire des le debut en parallele:
	. un petit groupe qui s'occupe du core: mm, tasks etc...
	. une personne du reseau
	. une personne ou deux de pleins de petits trucs: fichier de conf,
	  emulation 64-bit sur intel etc..

-- k4

task_create() puis task_run() ou task_stop()

thread_store() pour sauvegarder le contexte

oh:

mod_load(tskid, thrid, modid);

-- k5

pas de thread de msg, seulement un appel pour connaitre la taille du prochain
msg et un appel pour le recuperer. comme ca un seul thread pourrait tres bien
faire un while(1) { get_msg; treat_msg; } ou alors suivre le modele que
nous conseillons avec une thread qui recupere les msg comme ca ca augmente
le parallelisme oou bien les threads demandent directement au kernel le
prochain msg.

si il n y a plus de msg, la thread est bloque et marque comme attendant un
msg. comme ca au fur et a mesure les threads se bloquent, attendant des msgs.

quand un nouveau msg arrive, la premiere thread attendant un msg trouvee
est reveillee et le msg delivered.

-- k4 - spargo

task_wait(taskid) pour attendre que la task meurt
thread_wait(thrid) pour attendre que le thread meurt
group_wait(grpid) pour attendre qu un groupe creve genre pour le recrer

=> on devrait faire plus general que juste pour la mort d'une entite.

task_getid()
thread_getid()

generalement on utilisera thread_wait()

-- spargo - k4

lors du srv_reg(id?, max_msgs);

-- k5

inutile d avoir une liste en user car le kernel suffit + le kernel bloque
le user si plus de message.

-- k4

int task_load(t_taskid taskid, t_modid modid);
	-> check if as + mm_rsv + copy

int task_unload(t_taskid taskid);
	/* pour ca il faut garder trace des pages utilisees par le binaire
	   l'avantage c'est qu'apres on peut recycler TRES facilement
	   les structures */

int task_reload(t_taskid taskid, t_modid modid);
	-> task_unload() + task_load()

int task_clean();

~~~~~

thread:

int thread_init();

--------------------
XXX CONTINUER CA XXX
--------------------

int thread_rsv(t_thrtype type, t_vaddr entry,
               t_uint32 nstkpages, t_thrid *thrid);
int thread_rel(thrid) [todo k4]

flags: THREAD_TYPE_NORMAL, THREAD_TYPE_MSG

thread_attach(taskid, thrid) [todo k4]
thread_detach(thrid) [todo k4]

int thread_clean();

~~~~~

typedef struct s_task
{
  char name[TASK_NAMESZ + 1]; /* XXX ??? */
  t_taskid taskid;
  t_state state; /* RUNNING, IO, etc.. */
  t_class class;
  t_uint32 nthreads;
  t_thread *threads;
} t_task;

typedef struct s_thread
{
  t_thrid thrid;
  t_type type;

  t_thread *prv;
  t_thread *nxt;
} t_thread;

-- spargo

pour le sharing c'est simple. on creer une structure contenant une adresse,
une taille et une liste de fonctions.

ensuite ben on appelle une fct pour lui specifier l'adresse de l objet
et sa taille. la structure contient egalement un lock.

ensuite on peut mettre des proprietes sur les objets: SHARED, COW

comme ca on peut tres bien marquer une .. XXX ..

XXX il faut reussir a faire comme du sharing sur des as mais avec
    des objets en listant les cas. style RO, ca veut dire que personne
    n'ecrira dedans donc les utilisateurs liront le truc UNE seule fois
    donc lire via un objet c est correct, le non-parallelisme n'intervenant
    qu une seule fois

-- spargo

meme process qui mappe n fois la meme page physique XXX objects [ok]
n process qui mappe n fois la meme page physique XXX objects [ok] 

. prevoir un objet manager

dans l'as de la task:

 pas: liste de zones appartenant 

[pm]
 . 0-4 asid0
 . 5-2 asid0
 . 12-4 asid1
 . 20-10 asobj

[as0]
 pas
  . 0-4
  . 5-2
 vas
  . 5-1

[asobj] /* object manager */ 

en resumer, "pas" decrit ce que l'asid detient comme zones physiques mais juste
addr-size, aucune propriete. l'avantage: si un veut detruire l'espace physique
utilise par un processus, le gestionnaire de mem physique n'aura qu'a parcourir
la liste et hop c'est rapide et niquel.
"vas" lui decrit juste les zones virtuelles utilisees, avec MAPPEE ou NON
et si MAPPEE l'addr physique qui correspond.

dans spargo il faudra faire autrement, cad limite le champ d'action pour
par exemple soit se faire chier un peu et faire comme ca soit ne pas se
faire chier et ne pas permettre vm_rsv sans mapping. enfin dans tous les
cas ca fait juste un FLAG en + cest pas si grave.

ce qui est puissant c'est que le swapper s'en branle GRAVE. au pire le
object manager peut mettre un flag OBJECT pour dire que cette zone
physique contient des objects donc a swapper en dernier.

dans tous les cas c'est mieux qu'avant car avant on se faisait chier
DANS LE PM_MNG a garder:

1) tous les mecs qui mappent une page pour que le swapper puisse
   facilement les marquer non-present si il swappait.
   ce qui faisait que le pm_mng gerait des addr virtuelles, ca puait un max.
2) maintenant le pm-mng ne s occupe que de gerer des zones physique avec
   des attributs et c est ce qu on veut.

au pire c'est peut etre inutile finallement de garder la correspondance
v -> p en hardware, il faut voir, car si c'est le cas on vire tout.

sinon on peut peut etre aussi faire une correspondance p -> v. il faut lister
les cas ou ca sert pour etre sur.

est ce que chaque vas doit garder traces des attributs? je pense que oui
ca parait logique.

quand on veut acceder a un objet:

msg
{
  cmd = OBJECT_CALL; /* sera surement inutile car dest=object mng */
  args
  {
    method;
    arg1;
    arg2;
    arg3;
    arg4;
  }
};

l'object manager recoit le msg et extrait la methode, puis deduit le nombre
d'args et les extrait pour ensuite appeller la fonction==methode.

-- spargo

faire une abstraction pour les io/ports avec le gestionnaire de device
car ppc ne dispose pas de inb oub il faut passer par le MMU pour lui
dire telle addr = tel device

-- k4

set de regs independent: fp pc
set de regs dependent: donc prevoir des machdep pour les operations style
                       load, save etc..

scheduler: sched_next, sched_save? ...

voir avec JP pour le scheduler comment il va marcher, quand il sera appelle.

thread_new(stacksize, eip);

-- k4

bonus +parser a integrer

-- k4

bonus: fichier de configuration a integrer

--

. page fault a gerer dans k4 enfin leur dire de le gerer pour killer le process

. durant k7 ils peuvent faire un petit fs en ram pour gerer les modules grub

-- ?

modeliser un systeme pour les exceptions generiques

--

 t_srv, t_srvid

---

as:

as_rsv(*asid) [ok]
as_rel(asid) [ok]

as_attach(taskid, asid) [todo k4]
as_detach(asid) [todo k4]

thread:

thread_rsv(*thrid) [todo k4]
thread_rel(thrid) [todo k4]

thread_attach(taskid, thrid) [todo k4]
thread_detach(thrid) [todo k4]

task:

task_rsv(*taskid) [todo k4]
task_rel(taskid) [todo k4]

task_load(taskid, modid) [todo k4]
	-> check + mm_rsv + copy + thread_rsv (main) + thread_attach

task_unload(taskid) [todo k4]
	/* pour ca il faut garder trace des pages utilisees par le binaire
	   l'avantage c'est qu'apres on peut recycler TRES facilement
	   les structures */

task_reload(taskid, modid) [todo k4]

-- k5

expliquer que le chainage de trap va permettre de faire du multicasting de
message mais egalement de gerer les conflits d'irq avec 2 periph utilisant
la meme irq.

dans tous les cas c est du multicast car les drivers regarderont juste si
c est bien leur periph qui a fait le msg.

et priorites via un systeme de classes + chainage dans le kernel des messages
sils ne peuvent pas etre achemines.

+ priorites du scheduler.

-- k4

t_as
{
  t_taskid taskid; /* dans k4 ou k5 */
  t_asid asid;
  [physical description]
  [virtual description]
}

-- k5

expliquer le systeme pour recueillir les int avec handler generic etc..

. dire dans k5 que desormais les handlers de traps devront gerer les messages

struct
{
  ia32_pm_init, -> seg_init() + seg_add() * 4
  ia32_pm_rsv,
  ia32_pm_rel,
  ia32_pm_clear,
}	t_pm_dep;

-- k5

expliquer que lorsque l'on fait un msg_init -> int_add() * N +
  wrapper etc..

--  k5

lors du trap_add() on recupere le PL par rapport au thread
et on en deduit le segid et hop int_add()

-- k5

expliquer la table de traps et faire en sorte qu on puisse register plusieurs
  handlers.

-- k4

schedule de threads

-- spargo

prevoir pour plusieurs processeurs, reprendre sur vianney

-- k5

trap avec priorites reduite: USER => bottom halves. si bcp de traps
de register sur un evenement alors les derniers registers se comporteront
comme des bottom halves du fait du nombre de personnes a reveiller.

-- k5

expliquer que dans tous les cas les handlers d interruptions seront des
INTGATE (ce qui facilite le portage) et que ensuite on dispatch. + bottom-h

-- spargo

virer tous les cas de write pendant un read et comme ca distribue tres
simple -> demander a laurent

-- spargo

il faudrait deja penser le systeme de groupe sur une seule machine et ensuite
pour le distribue ce serait pareil avec +machid

alors:

 - il faut pouvoir faire en sorte qu'une interruption lance plusieurs thread
 - il faut pouvoir faire qu un message arrive chez plusieurs personne pour
   un seul envoie -> broadcast

. un systeme de groupe est complique a envisage dans le seul ou implicitement
  c'est bizarre et explicitement c'est difficile de savoir a l avance qui va
  vouloir se joindre a son groupe pour eventuellement recevoir les messages
  du groupe.

. un systeme de ressource hardware et virtuelle c'est le bon truc sauf que
  ce n'est pas le bon nommage. finallement on veut acceder a un point
  de liaison qui se trouve etre finallement une trap.

. la question est donc comment creer, joindre et gerer ces points de liaisons.
  quels vont etre les noms de ces points, comment la gestion des traps va
  t elle evoluer pour utiliser ces points? comment les message vont etre
  crees pour utiliser ces points de liaison?

en fait les groups c est cool mais il faudrait que le createur du groupe
broadcast pour demander si des gens veulent rentrer. meme systeme que j avais
penser.

-- k5 - k4

trap_add(*trapid, thrid, eventid);

srv_add(*srvid, thrid);

-- k4

processus = la notion de processus n'existe pas dans LSE/OS. neanmoins nous
            utiliserons ce terme comme alias du mot "task" et plus
            particulierement pour les taches utilisateur.

-- k4

il faut etre root ou systeme pour ajouter des services/drivers

load(PL_SERVICE) /* service */
load(PL_USER); /* processus */

-- spargo

mutex: acquire + release, avec des noms de zones critiques. bien pour la
 memoire distribuee. mais peut etre peut on berner les autre a chopper une
 zone de merde pour faire de la merde sur une autre zone finallement. si
 c'est le cas, le coup des objets avec methodes c'est mieux car c'est du code
 sur qui sera execute et en plus au bon endroit, style sur la machine owner
 de la zone partagee.

-- spargo

nodeid

-- spargo

faire un schema d'un machine et aussi d'un reseau:

-- k5

\item gestionnaire de traps.

\subsection{Traps}

\paragraph{}

La gestion des interruptions est tr\`es importante car elle va permettre
\`a votre kernel de recevoir des messages provenant des p\'eriph\'eriques.

\paragraph{}

Le concept d'interruption et d'exception est encore une fois trop
sp\'ecifique \`a Intel. Il pourrait exister des architectures sur
lesquelles ces concepts sont confondus. Pour cette raison les exceptions
comme les interruptions seront consid\'er\'ees en tant que \textbf{trap}.

\paragraph{}

Une \textbf{trap} repr\'esentant une porte d'entr\'ee vers une t\^ache pour
les \'ev\`enements mat\'eriels, que ce soit un \'ev\`enement provenant
d'un p\'eriph\'erique comme du processeur.

\paragraph{}

La gestion de message inter-processus ne se base pas sur les traps
mais utilise un autre m\'ecanisme. Les traps sont exclusivement
r\'es\`erv\'ees \`a l'acheminement d'\`ev\`enement que nous
nommeront ``mat\'eriels''.

\paragraph{}

Il faut tout de m\^eme savoir que chaque \'ev\`enement mat\'eriel sera
transmis au handler sous forme de message. Lorsque vous ajouterez donc une
trap sur un tel \'ev\`enement, pensez que le thread qui sera r\'eveill\'e
devra \^etre capable de traiter un message en entr\'ee.

\paragraph{}

\hspace{1.5cm}int \textbf{trap\_init}(void);

\paragraph{}

Cette fonction initialise la gestion des traps.

\paragraph{}

\hspace{1.5cm}int \textbf{trap\_add}(t\_hwid \textbf{hwid},
                                     t\_thrid \textbf{thrid},
                                     t\_trapid \textbf{*trapid});

\paragraph{}

Cette fonction ajoute une trap qui d\'eclenchera l'ex\'ecution du thread
\textbf{thrid} lorsque l'\'ev\`ement \textbf{hwid} se manifestera.

\paragraph{}

Nous vous conseillons de faire en sorte qu'une fois la trap trait\'ee il
soit possible d'en recevoir une nouvelle. Ceci n'est qu'un conseil qu'il
faudra prendre en compte lors de l'\'elaboration du code de vos handlers
de messages.

\paragraph{}

Le param\`etre \textbf{hwid} peut sembler flou. En effet cet argument
repr\'esente un identifiant de ressource. Dans le cas d'Intel nous pouvons
imaginer que vos drivers vont interroger le controlleur PCI pour obtenir
l'IRQ correspondant \`a ce p\'eriph\'erique. Dans le cas d'Intel, cet
IRQ sera transmis en tant que \textbf{hwid} puisqu'il repr\'esente l'unique
identifiant de ressource disponible.

\paragraph{}

\hspace{1.5cm}int \textbf{trap\_modify}(t\_trapid \textbf{*trapid},
                               	        t\_thrid \textbf{thrid});

\paragraph{}

Cette fonction permet de modifier une trap d\'ej\`a enregistr\'ee.
Cette fonction met \'egalement \`a jour l'identifiant \textbf{trapid}.

\paragraph{}

\hspace{1.5cm}int \textbf{trap\_remove}(t\_trapid \textbf{trapid});

\paragraph{}

Permet d'effacer la trap du gestionnaire de traps.

\paragraph{}

\hspace{1.5cm}int \textbf{trap\_enable}(t\_trapid \textbf{trapid});

\paragraph{}

Permet d'activer la gestion de cette trap. \`A vous de d\'ecider si jamais
l'installation d'une trap l'active par d\'efaut.

\paragraph{}

\hspace{1.5cm}int \textbf{trap\_disable}(t\_trapid \textbf{trapid});

\paragraph{}

Permet de d\'esactiver la gestion de cette trap.

\paragraph{}

\hspace{1.5cm}int \textbf{trap\_clean}(void);

\paragraph{}

D\'etruit toute les traps enregistr\'ee.

-- k4

\subsection{t\_thrid}

\paragraph{}

Ce type repr\'esente un identifiant de thread. La gestion des threads ne
sera faite que dans k4 mais il est indispensable d'utiliser ce type
d\`es maintenant.

\paragraph{}

L'utilisation de ce type est requis pour l'installation de trap. Pour des
raisons \'evidentes il ne vous sera pas possible d'installer de trap
tant que les threads ne seront pas g\'er\'ees, mais cela n'est pas important.

\begin{verbatim}
typedef t_uint32        t_thrid;
\end{verbatim}

\subsection{t\_trapid}

\paragraph{}

Ce type repr\'esente un identifiant de trap.

\begin{verbatim}
typedef struct          s_trapid
{
  t_hwid                hwid;
  t_uint32              id;
}                       t_trapid;
\end{verbatim}

-- annees a venir

. automatisation de tests via moulinettes
. intra pour poser des questions (quoique peut etre inutile si moulinettes)
. faire en sorte qu on ne soit pas obliger de dl la tarball etc.. en salle
  rack car ca peut tricher et bon c'est vraiment de la merde.
