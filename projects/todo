-- spargo

pour le sharing c'est simple. on creer une structure contenant une adresse,
une taille et une liste de fonctions.

ensuite ben on appelle une fct pour lui specifier l'adresse de l objet
et sa taille. la structure contient egalement un lock.

ensuite on peut mettre des proprietes sur les objets: SHARED, COW

comme ca on peut tres bien marquer une .. XXX ..

XXX il faut reussir a faire comme du sharing sur des as mais avec
    des objets en listant les cas. style RO, ca veut dire que personne
    n'ecrira dedans donc les utilisateurs liront le truc UNE seule fois
    donc lire via un objet c est correct, le non-parallelisme n'intervenant
    qu une seule fois

-- spargo

meme process qui mappe n fois la meme page physique XXX objects [ok]
n process qui mappe n fois la meme page physique XXX objects [ok] 

. prevoir un objet manager

dans l'as de la task:

 pas: liste de zones appartenant 

[pm]
 . 0-4 asid0
 . 5-2 asid0
 . 12-4 asid1
 . 20-10 asobj

[as0]
 pas
  . 0-4
  . 5-2
 vas
  . 5-1

[asobj] /* object manager */ 

en resumer, "pas" decrit ce que l'asid detient comme zones physiques mais juste
addr-size, aucune propriete. l'avantage: si un veut detruire l'espace physique
utilise par un processus, le gestionnaire de mem physique n'aura qu'a parcourir
la liste et hop c'est rapide et niquel.
"vas" lui decrit juste les zones virtuelles utilisees, avec MAPPEE ou NON
et si MAPPEE l'addr physique qui correspond.

dans spargo il faudra faire autrement, cad limite le champ d'action pour
par exemple soit se faire chier un peu et faire comme ca soit ne pas se
faire chier et ne pas permettre vm_rsv sans mapping. enfin dans tous les
cas ca fait juste un FLAG en + cest pas si grave.

ce qui est puissant c'est que le swapper s'en branle GRAVE. au pire le
object manager peut mettre un flag OBJECT pour dire que cette zone
physique contient des objects donc a swapper en dernier.

dans tous les cas c'est mieux qu'avant car avant on se faisait chier
DANS LE PM_MNG a garder:

1) tous les mecs qui mappent une page pour que le swapper puisse
   facilement les marquer non-present si il swappait.
   ce qui faisait que le pm_mng gerait des addr virtuelles, ca puait un max.
2) maintenant le pm-mng ne s occupe que de gerer des zones physique avec
   des attributs et c est ce qu on veut.

quand on veut acceder a un objet:

msg
{
  cmd = OBJECT_CALL; /* sera surement inutile car dest=object mng */
  args
  {
    method;
    arg1;
    arg2;
    arg3;
    arg4;
  }
};

l'object manager recoit le msg et extrait la methode, puis deduit le nombre
d'args et les extrait pour ensuite appeller la fonction==methode.

--

. page fault a gerer dans k4 enfin leur dire de le gerer pour killer le process

. durant k7 ils peuvent faire un petit fs en ram pour gerer les modules grub

-- ?

modeliser un systeme pour les exceptions generiques

--

 t_srv, t_srvid

---

as:

as_rsv(*asid) [ok]
as_rel(asid) [ok]

as_attach(taskid, asid) [todo k4]
as_detach(asid) [todo k4]

thread:

thread_rsv(*thrid) [todo k4]
thread_rel(thrid) [todo k4]

thread_attach(taskid, thrid) [todo k4]
thread_detach(thrid) [todo k4]

task:

task_rsv(*taskid) [todo k4]
task_rel(taskid) [todo k4]

task_load(taskid, modid) [todo k4]
	-> check + mm_rsv + copy + thread_rsv (main) + thread_attach

task_unload(taskid) [todo k4]
	/* pour ca il faut garder trace des pages utilisees par le binaire
	   l'avantage c'est qu'apres on peut recycler TRES facilement
	   les structures */

task_reload(taskid, modid) [todo k4]

-- k5

expliquer que le chainage de trap va permettre de faire du multicasting de
message mais egalement de gerer les conflits d'irq avec 2 periph utilisant
la meme irq.

dans tous les cas c est du multicast car les drivers regarderont juste si
c est bien leur periph qui a fait le msg.

et priorites via un systeme de classes + chainage dans le kernel des messages
sils ne peuvent pas etre achemines.

+ priorites du scheduler.

-- k4

t_as
{
  t_taskid taskid; /* dans k4 ou k5 */
  t_asid asid;
  [physical description]
  [virtual description]
}

-- k5

expliquer le systeme pour recueillir les int avec handler generic etc..

. dire dans k5 que desormais les handlers de traps devront gerer les messages

struct
{
  ia32_pm_init, -> seg_init() + seg_add() * 4
  ia32_pm_rsv,
  ia32_pm_rel,
  ia32_pm_clear,
}	t_pm_dep;

-- k5

expliquer que lorsque l'on fait un msg_init -> int_add() * N +
  wrapper etc..

--  k5

lors du trap_add() on recupere le PL par rapport au thread
et on en deduit le segid et hop int_add()

-- 

expliquer la table de traps et faire en sorte qu on puisse register plusieurs
  handler pour les traps mais egalement pour les msgs

--

schedule de threads

-- spargo

prevoir pour plusieurs processeurs, reprendre sur vianney

--

trap avec priorites reduite: USER => bottom halves. si bcp de traps
de register sur un evenement alors les derniers registers se comporteront
comme des bottom halves du fait du nombre de personnes a reveiller.

-- trap

expliquer que dans tous les cas les handlers d interruptions seront des
INTGATE (ce qui facilite le portage) et que ensuite on dispatch. + bottom-h

-- spargo

virer tous les cas de write pendant un read et comme ca distribue tres
simplle -> demander a laurent

-- spargo

il faudrait deja penser le systeme de groupe sur une seule machine et ensuite
pour le distribue ce serait pareil avec +machid

alors:

 - il faut pouvoir faire en sorte qu'une interruption lance plusieurs thread
 - il faut pouvoir faire qu un message arrive chez plusieurs personne pour
   un seul envoie -> broadcast

. un systeme de groupe est complique a envisage dans le seul ou implicitement
  c'est bizarre et explicitement c'est difficile de savoir a l avance qui va
  vouloir se joindre a son groupe pour eventuellement recevoir les messages
  du groupe.

. un systeme de ressource hardware et virtuelle c'est le bon truc sauf que
  ce n'est pas le bon nommage. finallement on veut acceder a un point
  de liaison qui se trouve etre finallement une trap.

. la question est donc comment creer, joindre et gerer ces points de liaisons.
  quels vont etre les noms de ces points, comment la gestion des traps va
  t elle evoluer pour utiliser ces points? comment les message vont etre
  crees pour utiliser ces points de liaison?

en fait les groups c est cool mais il faudrait que le createur du groupe
broadcast pour demander si des gens veulent rentrer. meme systeme que j avais
penser.

--

trap_add(*trapid, thrid, eventid);

srv_add(*srvid, thrid);

-- k4 avec les classes

user = ne communique pas avec le hard

service = un processus qui "fournit un service" avec des privileges accrus.
          generalement ces processus recoivent des messages et execute une
          tache mais si ceux ci ne le font pas ils se nomment tout de meme
          services par rapport a leurs privileges. finallement un appelle
          service un processus qui sert le kernel dans ses taches.

driver = service mais qui communique en plus avec le hard

kernel = il peut communiquer avec tlm et a acces a tout

--

processus = la notion de processus n'existe pas dans LSE/OS. neanmoins nous
            utiliserons ce terme comme alias du mot "task" et plus
            particulierement pour les taches utilisateur.

--

il faut etre root ou systeme pour ajouter des services/drivers

load(PL_SERVICE) /* service */
load(PL_USER); /* processus */

-- spargo

mutex: acquire + release, avec des noms de zones critiques. bien pour la
 memoire distribuee. mais peut etre peut on berner les autre a chopper une
 zone de merde pour faire de la merde sur une autre zone finallement. si
 c'est le cas, le coup des objets avec methodes c'est mieux car c'est du code
 sur qui sera execute et en plus au bon endroit, style sur la machine owner
 de la zone partagee.

-- spargo

nodeid

-- spargo

faire un schema d'un machine et aussi d'un reseau:

-- k3

modifier les attr d une page virtuelle: rwx dans k3

-- k5

\item gestionnaire de traps.

\subsection{Traps}

\paragraph{}

La gestion des interruptions est tr\`es importante car elle va permettre
\`a votre kernel de recevoir des messages provenant des p\'eriph\'eriques.

\paragraph{}

Le concept d'interruption et d'exception est encore une fois trop
sp\'ecifique \`a Intel. Il pourrait exister des architectures sur
lesquelles ces concepts sont confondus. Pour cette raison les exceptions
comme les interruptions seront consid\'er\'ees en tant que \textbf{trap}.

\paragraph{}

Une \textbf{trap} repr\'esentant une porte d'entr\'ee vers une t\^ache pour
les \'ev\`enements mat\'eriels, que ce soit un \'ev\`enement provenant
d'un p\'eriph\'erique comme du processeur.

\paragraph{}

La gestion de message inter-processus ne se base pas sur les traps
mais utilise un autre m\'ecanisme. Les traps sont exclusivement
r\'es\`erv\'ees \`a l'acheminement d'\`ev\`enement que nous
nommeront ``mat\'eriels''.

\paragraph{}

Il faut tout de m\^eme savoir que chaque \'ev\`enement mat\'eriel sera
transmis au handler sous forme de message. Lorsque vous ajouterez donc une
trap sur un tel \'ev\`enement, pensez que le thread qui sera r\'eveill\'e
devra \^etre capable de traiter un message en entr\'ee.

\paragraph{}

\hspace{1.5cm}int \textbf{trap\_init}(void);

\paragraph{}

Cette fonction initialise la gestion des traps.

\paragraph{}

\hspace{1.5cm}int \textbf{trap\_add}(t\_hwid \textbf{hwid},
                                     t\_thrid \textbf{thrid},
                                     t\_trapid \textbf{*trapid});

\paragraph{}

Cette fonction ajoute une trap qui d\'eclenchera l'ex\'ecution du thread
\textbf{thrid} lorsque l'\'ev\`ement \textbf{hwid} se manifestera.

\paragraph{}

Nous vous conseillons de faire en sorte qu'une fois la trap trait\'ee il
soit possible d'en recevoir une nouvelle. Ceci n'est qu'un conseil qu'il
faudra prendre en compte lors de l'\'elaboration du code de vos handlers
de messages.

\paragraph{}

Le param\`etre \textbf{hwid} peut sembler flou. En effet cet argument
repr\'esente un identifiant de ressource. Dans le cas d'Intel nous pouvons
imaginer que vos drivers vont interroger le controlleur PCI pour obtenir
l'IRQ correspondant \`a ce p\'eriph\'erique. Dans le cas d'Intel, cet
IRQ sera transmis en tant que \textbf{hwid} puisqu'il repr\'esente l'unique
identifiant de ressource disponible.

\paragraph{}

\hspace{1.5cm}int \textbf{trap\_modify}(t\_trapid \textbf{*trapid},
                               	        t\_thrid \textbf{thrid});

\paragraph{}

Cette fonction permet de modifier une trap d\'ej\`a enregistr\'ee.
Cette fonction met \'egalement \`a jour l'identifiant \textbf{trapid}.

\paragraph{}

\hspace{1.5cm}int \textbf{trap\_remove}(t\_trapid \textbf{trapid});

\paragraph{}

Permet d'effacer la trap du gestionnaire de traps.

\paragraph{}

\hspace{1.5cm}int \textbf{trap\_enable}(t\_trapid \textbf{trapid});

\paragraph{}

Permet d'activer la gestion de cette trap. \`A vous de d\'ecider si jamais
l'installation d'une trap l'active par d\'efaut.

\paragraph{}

\hspace{1.5cm}int \textbf{trap\_disable}(t\_trapid \textbf{trapid});

\paragraph{}

Permet de d\'esactiver la gestion de cette trap.

\paragraph{}

\hspace{1.5cm}int \textbf{trap\_clean}(void);

\paragraph{}

D\'etruit toute les traps enregistr\'ee.

--

\subsection{t\_thrid}

\paragraph{}

Ce type repr\'esente un identifiant de thread. La gestion des threads ne
sera faite que dans k4 mais il est indispensable d'utiliser ce type
d\`es maintenant.

\paragraph{}

L'utilisation de ce type est requis pour l'installation de trap. Pour des
raisons \'evidentes il ne vous sera pas possible d'installer de trap
tant que les threads ne seront pas g\'er\'ees, mais cela n'est pas important.

\begin{verbatim}
typedef u_int32_t       t_thrid;
\end{verbatim}

\subsection{t\_trapid}

\paragraph{}

Ce type repr\'esente un identifiant de trap.

\begin{verbatim}
typedef struct          s_trapid
{
  t_hwid                hwid;
  u_int32_t             id;
}                       t_trapid;
\end{verbatim}

-- annees a venir

. automatisation de tests via moulinettes
. intra pour poser des questions (quoique peut etre inutile si moulinettes)
. faire en sorte qu on ne soit pas obliger de dl la tarball etc.. en salle
  rack car ca peut tricher et bon c'est vraiment de la merde.
