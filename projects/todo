-- spargo

utiliser des identifiants pour les regions de memoire que ce soit
physique comme virtuelle comme ca on peut les identifier.

une zone physique est nommee: "segment"
une zone virtuelle est nommee: "region" (XXX?XXX)

peut etre une troisieme classe "map" segment+region

une fois ces structures definies, on definit des identifiants:
  t_segid, t_regid, t_mapid

et donc la structure as devient:

t_segment
{
  t_paddr address;
  t_psize npages;

  t_owner owner;

  [...] /* protections, etc.. */
}

t_regid
{
  t_vaddr address;
  t_vsize npages;

  [...] /* etc.. */
}

t_mapid
{
  t_segid segment;
  t_regid regid;
}

t_as
{
  t_asid asid;
  t_tskid tskid;
  t_owner owner;
  t_modid modid;

  t_setid segments; /* set of segid */
  t_setid regions; /* set of regid */
  t_setid maps; /* set of mapid */
}

-- k4 - spargo

as_modid() pour recuperer le modid correspond a un as.
comme ca le gestionnaire de module peut connaitre le modid d un as pour
liberer les pages correspondantes au module

-- spargo

pensez que lorsqu on libere on voudrait bien recuperer un identifiant
pour pouvoir reutiliser l'espace libere.

-- spargo

penser que dans kaneton lorsqu un mm_rsv est fait apres on ne peut pas
"give" le truc car on ne connait pas l identifiant

-- k4

dans kaneton virer le crt de k7 et le mettre dans k4 et l expliquer

-- k7

au final rien a faire a part le libc, bien dire qu il faut la faire complete
sinon ca fera bcp de boulot pour les files systems et ils n auront pas le
temps.

-- spargo

plutot que task/thread_wait() qui attend que la tache meurt, on pourrait faire
task/thread_wait(status) qui attend que la tache passe en etat status.

comme ca on peut attendre que la tache meurt, mais on peut aussi attendre
qu'elle recoive un I/O etc..

reflechir a ca car c est + generique donc plus interessant

-- spargo

mettre la zone contenant le module avec une propriete MODULE. quoi que de
toute facon c'est une zone partagee donc on le sait donc ca sert surement a
rien.

-- spargo

le fait d'avoi les taches, as  et thread dissocies font qu on pourrait tres
bien prefabriquer des espaces d adressage par exemple pour les binaire
extremement utilies: ls etc.. mais egalement des tasks entieres prefabriquees.

-- k5

mutex_acq(); /* aquerit le lock */
mutex_rel(); /* libere le lock */

-- k5

wait, quel code renvoye si jamais la tache/thread est force d etre stoppe.

-- k5

+sondage

-- k5

t_eventid a approfondir

-- k[all]

rajouter dans chaque structure: machdep_include(XXX)

-- k2

rajouter t_pm pm dans les types

-- k5

reflechir au ptit bout de code pour eviter la propagation

-- k5

bien expliquer que jusqu a maintenant on faisait des interfaces c est a dire
des fonctions et que maintenant on va greffer des messages. le systeme
est simple, les variables sont construites on extrayant du message les valeurs
et les fonctions de l interface sont appelles, comme ca on ne modifie
rien au code existant et en PLUS, le kernel peut appeller des fonctions
dans son meme code, cad le kernel sans avoir besoin de creer un message
ce qui serait stupide.

-- k5

dire que en utilisant la libc, on peut par exemple passer -1 plutot
que faire un sched_tskid() lorsqu on appelle le gestionnaire de tasks.

lorsque le message arrivera, le gestionnaire de tasks saura que nous
parlons du tskid correspondant a la tache appellante.

-- sondage sur kaneton

comment son les cours
comment son les sujets
comment son les tps

difficultes?

idees?

commentaires?

-- k5

faire en sorte que si une personne de le class N veut envoyer un message
a une personne de la classe N-1 ca chie.

-- k5

timer_add()
timer_remove()

envoie de message lorsque le timer est ecoule

la encore il risque d'y avoir quelques problemes. le temps ne sera
vraiment pas precis car il pourra y avoir N process prioritaires dans
la run queue: driver, service etc..

-- spargo

reflechir au kernel comme a fait phix c'est a dire pour eviter
la propagation:
  . mettre les structures importantes dans l espace user avec protection
    systeme
  . avec ca le kernel est tres petit
  . on a juste a faire une copie de l'as et hop on peut l'envoyer
    sur le reseau

le truc cool de tout avoir dans l espace kernel c'est qu'on stocke
tout et donc pour faire des operations sur plusieurs trucs c est vachement
simple alors que sinon c est chiant avec le truc a phix.

pour eviter la propagation il faudra avoir une tite lib dependante
que tu fous en meme haute a la place du kernel. cette truc recoit
l'interruption et contexte switch pour passer la main au kernel. enfin
en gros contexte switch ici == changement de cr3 si on se demerde bien =
si apres le changement de cr3 les instructions executees sont correctes
dans le nouvel espace, celui du kernel.
en faisant ca, la lib ne sera jamais modifiee et donc pas de propagation.
pour pas se faire chier on pourrait reserver genre 1 page pour faire ca.
(attentoin ne pas reserver la derniere page pour faire des vaddr non valide
a -1).

pour pouvoir migrer c'est simple il suffit de faire une fonction
qui va faire des get dans chaque gestionnaire et donc former un package
ayant un format et decrivant la memoire. pas super complique, ca prend
un peu de temps mais c'est fatal.

-- spargo

etudier tout le SMP pour faire un gestionnaire de CPU et pour pouvoir
specifier les cpu sur lesquels vont tourner les threads

-- spargo

dire que les signaux nous semblent prehistorique comme d'autre concepts
posix. donc on a pas implementer de signaux. neanmoins ils peuvent etre
emules.

-- k? for vfs

vfs_clone() qui va dupliquer une table de l ancien pour le nouveau.
lors d'un open read write, on matte le caller et on matte ensuite
sa table associee. on a donc une table par caller.

-- spargo

il faudra faire des le debut en parallele:
	. un petit groupe qui s'occupe du core: mm, tasks etc...
	. une personne du reseau
	. une personne ou deux de pleins de petits trucs: fichier de conf,
	  emulation 64-bit sur intel etc..

-- k5

pas de thread de msg, seulement un appel pour connaitre la taille du prochain
msg et un appel pour le recuperer. comme ca un seul thread pourrait tres bien
faire un while(1) { get_msg; treat_msg; } ou alors suivre le modele que
nous conseillons avec une thread qui recupere les msg comme ca ca augmente
le parallelisme oou bien les threads demandent directement au kernel le
prochain msg.

si il n y a plus de msg, la thread est bloque et marque comme attendant un
msg. comme ca au fur et a mesure les threads se bloquent, attendant des msgs.

quand un nouveau msg arrive, la premiere thread attendant un msg trouvee
est reveillee et le msg delivered.

-- spargo

group_wait(grpid) pour attendre qu un groupe creve genre pour le recrer

=> on devrait faire plus general que juste pour la mort d'une entite.

-- spargo - k5

lors du srv_reg(id?, max_msgs);

-- k5

inutile d avoir une liste en user car le kernel suffit + le kernel bloque
le user si plus de message.

-- spargo

pour le sharing c'est simple. on creer une structure contenant une adresse,
une taille et une liste de fonctions.

ensuite ben on appelle une fct pour lui specifier l'adresse de l objet
et sa taille. la structure contient egalement un lock.

ensuite on peut mettre des proprietes sur les objets: SHARED, COW

comme ca on peut tres bien marquer une .. XXX ..

XXX il faut reussir a faire comme du sharing sur des as mais avec
    des objets en listant les cas. style RO, ca veut dire que personne
    n'ecrira dedans donc les utilisateurs liront le truc UNE seule fois
    donc lire via un objet c est correct, le non-parallelisme n'intervenant
    qu une seule fois

-- spargo

meme process qui mappe n fois la meme page physique XXX objects [ok]
n process qui mappe n fois la meme page physique XXX objects [ok] 

. prevoir un objet manager

dans l'as de la task:

 pas: liste de zones appartenant 

[pm]
 . 0-4 asid0
 . 5-2 asid0
 . 12-4 asid1
 . 20-10 asobj

[as0]
 pas
  . 0-4
  . 5-2
 vas
  . 5-1

[asobj] /* object manager */ 

en resumer, "pas" decrit ce que l'asid detient comme zones physiques mais juste
addr-size, aucune propriete. l'avantage: si un veut detruire l'espace physique
utilise par un processus, le gestionnaire de mem physique n'aura qu'a parcourir
la liste et hop c'est rapide et niquel.
"vas" lui decrit juste les zones virtuelles utilisees, avec MAPPEE ou NON
et si MAPPEE l'addr physique qui correspond.

dans spargo il faudra faire autrement, cad limite le champ d'action pour
par exemple soit se faire chier un peu et faire comme ca soit ne pas se
faire chier et ne pas permettre vm_rsv sans mapping. enfin dans tous les
cas ca fait juste un FLAG en + cest pas si grave.

ce qui est puissant c'est que le swapper s'en branle GRAVE. au pire le
object manager peut mettre un flag OBJECT pour dire que cette zone
physique contient des objects donc a swapper en dernier.

dans tous les cas c'est mieux qu'avant car avant on se faisait chier
DANS LE PM_MNG a garder:

1) tous les mecs qui mappent une page pour que le swapper puisse
   facilement les marquer non-present si il swappait.
   ce qui faisait que le pm_mng gerait des addr virtuelles, ca puait un max.
2) maintenant le pm-mng ne s occupe que de gerer des zones physique avec
   des attributs et c est ce qu on veut.

au pire c'est peut etre inutile finallement de garder la correspondance
v -> p en hardware, il faut voir, car si c'est le cas on vire tout.

sinon on peut peut etre aussi faire une correspondance p -> v. il faut lister
les cas ou ca sert pour etre sur.

est ce que chaque vas doit garder traces des attributs? je pense que oui
ca parait logique.

quand on veut acceder a un objet:

msg
{
  cmd = OBJECT_CALL; /* sera surement inutile car dest=object mng */
  args
  {
    method;
    arg1;
    arg2;
    arg3;
    arg4;
  }
};

l'object manager recoit le msg et extrait la methode, puis deduit le nombre
d'args et les extrait pour ensuite appeller la fonction==methode.

-- spargo

faire une abstraction pour les io/ports avec le gestionnaire de device
car ppc ne dispose pas de inb oub il faut passer par le MMU pour lui
dire telle addr = tel device

-- k7

. durant k7 ils peuvent faire un petit fs en ram pour gerer les modules grub

-- k5

t_srv, t_srvid

-- k5

expliquer que le chainage de trap va permettre de faire du multicasting de
message mais egalement de gerer les conflits d'irq avec 2 periph utilisant
la meme irq.

dans tous les cas c est du multicast car les drivers regarderont juste si
c est bien leur periph qui a fait le msg.

et priorites via un systeme de classes + chainage dans le kernel des messages
sils ne peuvent pas etre achemines.

+ priorites du scheduler.

-- k5

expliquer le systeme pour recueillir les int avec handler generic etc..

. dire dans k5 que desormais les handlers de traps devront gerer les messages

struct
{
  ia32_pm_init, -> seg_init() + seg_add() * 4
  ia32_pm_rsv,
  ia32_pm_rel,
  ia32_pm_clear,
}	t_pm_dep;

-- k5

expliquer que lorsque l'on fait un msg_init -> int_add() * N +
  wrapper etc..

--  k5

lors du trap_add() on recupere le PL par rapport au thread
et on en deduit le segid et hop int_add()

-- k5

expliquer la table de traps et faire en sorte qu on puisse register plusieurs
  handlers.

-- spargo

prevoir pour plusieurs processeurs, reprendre sur vianney

-- k5

trap avec priorites reduite: USER => bottom halves. si bcp de traps
de register sur un evenement alors les derniers registers se comporteront
comme des bottom halves du fait du nombre de personnes a reveiller.

-- k5

expliquer que dans tous les cas les handlers d interruptions seront des
INTGATE (ce qui facilite le portage) et que ensuite on dispatch. + bottom-h

-- spargo

virer tous les cas de write pendant un read et comme ca distribue tres
simple -> demander a laurent

-- spargo

il faudrait deja penser le systeme de groupe sur une seule machine et ensuite
pour le distribue ce serait pareil avec +machid

alors:

 - il faut pouvoir faire en sorte qu'une interruption lance plusieurs thread
 - il faut pouvoir faire qu un message arrive chez plusieurs personne pour
   un seul envoie -> broadcast

. un systeme de groupe est complique a envisage dans le seul ou implicitement
  c'est bizarre et explicitement c'est difficile de savoir a l avance qui va
  vouloir se joindre a son groupe pour eventuellement recevoir les messages
  du groupe.

. un systeme de ressource hardware et virtuelle c'est le bon truc sauf que
  ce n'est pas le bon nommage. finallement on veut acceder a un point
  de liaison qui se trouve etre finallement une trap.

. la question est donc comment creer, joindre et gerer ces points de liaisons.
  quels vont etre les noms de ces points, comment la gestion des traps va
  t elle evoluer pour utiliser ces points? comment les message vont etre
  crees pour utiliser ces points de liaison?

en fait les groups c est cool mais il faudrait que le createur du groupe
broadcast pour demander si des gens veulent rentrer. meme systeme que j avais
penser.

-- k5

trap_add(*trapid, thrid, eventid);

-- k?

leur faire faire un sujet de modelisation: fs.

encore mieux toute la fin du projet c'est de la modelisation par
leurs soins: ide, fs mais aussi un serveur de securite unix etc..

-- spargo

mutex: acquire + release, avec des noms de zones critiques. bien pour la
 memoire distribuee. mais peut etre peut on berner les autre a chopper une
 zone de merde pour faire de la merde sur une autre zone finallement. si
 c'est le cas, le coup des objets avec methodes c'est mieux car c'est du code
 sur qui sera execute et en plus au bon endroit, style sur la machine owner
 de la zone partagee.

-- spargo

nodeid

-- spargo

faire un schema d'un machine et aussi d'un reseau:

-- k5

\item gestionnaire de traps.

\subsection{Traps}

\paragraph{}

La gestion des interruptions est tr\`es importante car elle va permettre
\`a votre kernel de recevoir des messages provenant des p\'eriph\'eriques.

\paragraph{}

Le concept d'interruption et d'exception est encore une fois trop
sp\'ecifique \`a Intel. Il pourrait exister des architectures sur
lesquelles ces concepts sont confondus. Pour cette raison les exceptions
comme les interruptions seront consid\'er\'ees en tant que \textbf{trap}.

\paragraph{}

Une \textbf{trap} repr\'esentant une porte d'entr\'ee vers une t\^ache pour
les \'ev\`enements mat\'eriels, que ce soit un \'ev\`enement provenant
d'un p\'eriph\'erique comme du processeur.

\paragraph{}

La gestion de message inter-processus ne se base pas sur les traps
mais utilise un autre m\'ecanisme. Les traps sont exclusivement
r\'es\`erv\'ees \`a l'acheminement d'\`ev\`enement que nous
nommeront ``mat\'eriels''.

\paragraph{}

Il faut tout de m\^eme savoir que chaque \'ev\`enement mat\'eriel sera
transmis au handler sous forme de message. Lorsque vous ajouterez donc une
trap sur un tel \'ev\`enement, pensez que le thread qui sera r\'eveill\'e
devra \^etre capable de traiter un message en entr\'ee.

\paragraph{}

\hspace{1.5cm}int \textbf{trap\_init}(void);

\paragraph{}

Cette fonction initialise la gestion des traps.

\paragraph{}

\hspace{1.5cm}int \textbf{trap\_add}(t\_hwid \textbf{hwid},
                                     t\_thrid \textbf{thrid},
                                     t\_trapid \textbf{*trapid});

\paragraph{}

Cette fonction ajoute une trap qui d\'eclenchera l'ex\'ecution du thread
\textbf{thrid} lorsque l'\'ev\`ement \textbf{hwid} se manifestera.

\paragraph{}

Nous vous conseillons de faire en sorte qu'une fois la trap trait\'ee il
soit possible d'en recevoir une nouvelle. Ceci n'est qu'un conseil qu'il
faudra prendre en compte lors de l'\'elaboration du code de vos handlers
de messages.

\paragraph{}

Le param\`etre \textbf{hwid} peut sembler flou. En effet cet argument
repr\'esente un identifiant de ressource. Dans le cas d'Intel nous pouvons
imaginer que vos drivers vont interroger le controlleur PCI pour obtenir
l'IRQ correspondant \`a ce p\'eriph\'erique. Dans le cas d'Intel, cet
IRQ sera transmis en tant que \textbf{hwid} puisqu'il repr\'esente l'unique
identifiant de ressource disponible.

\paragraph{}

\hspace{1.5cm}int \textbf{trap\_modify}(t\_trapid \textbf{*trapid},
                               	        t\_thrid \textbf{thrid});

\paragraph{}

Cette fonction permet de modifier une trap d\'ej\`a enregistr\'ee.
Cette fonction met \'egalement \`a jour l'identifiant \textbf{trapid}.

\paragraph{}

\hspace{1.5cm}int \textbf{trap\_remove}(t\_trapid \textbf{trapid});

\paragraph{}

Permet d'effacer la trap du gestionnaire de traps.

\paragraph{}

\hspace{1.5cm}int \textbf{trap\_enable}(t\_trapid \textbf{trapid});

\paragraph{}

Permet d'activer la gestion de cette trap. \`A vous de d\'ecider si jamais
l'installation d'une trap l'active par d\'efaut.

\paragraph{}

\hspace{1.5cm}int \textbf{trap\_disable}(t\_trapid \textbf{trapid});

\paragraph{}

Permet de d\'esactiver la gestion de cette trap.

\paragraph{}

\hspace{1.5cm}int \textbf{trap\_clean}(void);

\paragraph{}

D\'etruit toute les traps enregistr\'ee.

-- k5

\subsection{t\_trapid}

\paragraph{}

Ce type repr\'esente un identifiant de trap.

\begin{verbatim}
typedef struct          s_trapid
{
  t_hwid                hwid;
  t_uint32              id;
}                       t_trapid;
\end{verbatim}

-- annees a venir

. automatisation de tests via moulinettes
. intra pour poser des questions (quoique peut etre inutile si moulinettes)
. faire en sorte qu on ne soit pas obliger de dl la tarball etc.. en salle
  rack car ca peut tricher et bon c'est vraiment de la merde.
