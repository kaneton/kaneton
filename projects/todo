-- spargo

pour le sharing c'est simple. on creer une structure contenant une adresse,
une taille et une liste de fonctions.

ensuite ben on appelle une fct pour lui specifier l'adresse de l objet
et sa taille. la structure contient egalement un lock.

ensuite on peut mettre des proprietes sur les objets: SHARED, COW

comme ca on peut tres bien marquer une .. XXX ..

XXX il faut reussir a faire comme du sharing sur des as mais avec
    des objets en listant les cas. style RO, ca veut dire que personne
    n'ecrira dedans donc les utilisateurs liront le truc UNE seule fois
    donc lire via un objet c est correct, le non-parallelisme n'intervenant
    qu une seule fois

--

. page fault a gerer dans k3

. durant k7 ils peuvent faire un petit fs en ram pour gerer les modules grub

--

 t_srv, t_srvid

---

as:

as_rsv(*asid) [ok]
as_rel(asid) [ok]

as_attach(taskid, asid) [todo k4]
as_detach(asid) [todo k4]

thread:

thread_rsv(*thrid) [todo k4]
thread_rel(thrid) [todo k4]

thread_attach(taskid, thrid) [todo k4]
thread_detach(thrid) [todo k4]

task:

task_rsv(*taskid) [todo k4]
task_rel(taskid) [todo k4]

task_load(taskid, modid) [todo k4]
	-> check + mm_rsv + copy + thread_rsv (main) + thread_attach

task_unload(taskid) [todo k4]
	/* pour ca il faut garder trace des pages utilisees par le binaire
	   l'avantage c'est qu'apres on peut recycler TRES facilement
	   les structures */

task_reload(taskid, modid) [todo k4]

--

expliquer que le chainage de trap va permettre de faire du multicasting de
message mais egalement de gerer les conflits d'irq avec 2 periph utilisant
la meme irq.

dans tous les cas c est du multicast car les drivers regarderont juste si
c est bien leur periph qui a fait le msg.

et priorites via un systeme de classes + chainage dans le kernel des messages
sils ne peuvent pas etre achemines.

+ priorites du scheduler.

--

t_as
{
  t_taskid taskid; /* dans k4 ou k5 */
  t_asid asid;
  [physical description]
  [virtual description]
}

-- avec les traps

expliquer le systeme pour recueillir les int avec handler generic etc..

. dire dans k5 que desormais les handlers de traps devront gerer les messages

struct
{
  ia32_pm_init, -> seg_init() + seg_add() * 4
  ia32_pm_rsv,
  ia32_pm_rel,
  ia32_pm_clear,
}	t_pm_dep;

--

expliquer le systeme:

prsv ajoute un truc dans la liste physique de l asid (*)
vrsv ajoute un truc dans la liste virtuelle
vmap enleve dans la liste physique mais ajoute l addr physique dans le truc v
vunmap enleve la reference vers physique et ajoute un truc physique
vrel enelve dans v
prel enleve dan p (*)

--

expliquer que lorsque l'on fait un msg_init -> int_add() * N +
  wrapper etc..

-- 

lors du trap_add() on recupere le PL par rapport au thread
et on en deduit le segid et hop int_add()

--

expliquer la table de traps et faire en sorte qu on puisse register plusieurs
  handler pour les traps mais egalement pour les msgs

--

schedule de threads

-- spargo

prevoir pour plusieurs processeurs, reprendre sur vianney

--

trap avec priorites reduite: USER => bottom halves. si bcp de traps
de register sur un evenement alors les derniers registers se comporteront
comme des bottom halves du fait du nombre de personnes a reveiller.

-- trap

expliquer que dans tous les cas les handlers d interruptions seront des
INTGATE (ce qui facilite le portage) et que ensuite on dispatch. + bottom-h

-- spargo

virer tous les cas de write pendant un read et comme ca distribue tres
simplle -> demander a laurent

-- spargo

il faudrait deja penser le systeme de groupe sur une seule machine et ensuite
pour le distribue ce serait pareil avec +machid

alors:

 - il faut pouvoir faire en sorte qu'une interruption lance plusieurs thread
 - il faut pouvoir faire qu un message arrive chez plusieurs personne pour
   un seul envoie -> broadcast

. un systeme de groupe est complique a envisage dans le seul ou implicitement
  c'est bizarre et explicitement c'est difficile de savoir a l avance qui va
  vouloir se joindre a son groupe pour eventuellement recevoir les messages
  du groupe.

. un systeme de ressource hardware et virtuelle c'est le bon truc sauf que
  ce n'est pas le bon nommage. finallement on veut acceder a un point
  de liaison qui se trouve etre finallement une trap.

. la question est donc comment creer, joindre et gerer ces points de liaisons.
  quels vont etre les noms de ces points, comment la gestion des traps va
  t elle evoluer pour utiliser ces points? comment les message vont etre
  crees pour utiliser ces points de liaison?

en fait les groups c est cool mais il faudrait que le createur du groupe
broadcast pour demander si des gens veulent rentrer. meme systeme que j avais
penser.

--

trap_add(*trapid, thrid, eventid);

srv_add(*srvid, thrid);

-- k4 avec les classes

user = ne communique pas avec le hard

service = un processus qui "fournit un service" avec des privileges accrus.
          generalement ces processus recoivent des messages et execute une
          tache mais si ceux ci ne le font pas ils se nomment tout de meme
          services par rapport a leurs privileges. finallement un appelle
          service un processus qui sert le kernel dans ses taches.

driver = service mais qui communique en plus avec le hard

kernel = il peut communiquer avec tlm et a acces a tout

--

processus = la notion de processus n'existe pas dans LSE/OS. neanmoins nous
            utiliserons ce terme comme alias du mot "task" et plus
            particulierement pour les taches utilisateur.

--

il faut etre root ou systeme pour ajouter des services/drivers

load(PL_SERVICE) /* service */
load(PL_USER); /* processus */

-- spargo

mutex: acquire + release, avec des noms de zones critiques. bien pour la
 memoire distribuee. mais peut etre peut on berner les autre a chopper une
 zone de merde pour faire de la merde sur une autre zone finallement. si
 c'est le cas, le coup des objets avec methodes c'est mieux car c'est du code
 sur qui sera execute et en plus au bon endroit, style sur la machine owner
 de la zone partagee.

-- spargo

nodeid

-- spargo

faire un schema d'un machine et aussi d'un reseau:

-- k3

modifier les attr d une page virtuelle: rwx dans k3

-- k5

\item gestionnaire de traps.

\subsection{Traps}

\paragraph{}

La gestion des interruptions est tr\`es importante car elle va permettre
\`a votre kernel de recevoir des messages provenant des p\'eriph\'eriques.

\paragraph{}

Le concept d'interruption et d'exception est encore une fois trop
sp\'ecifique \`a Intel. Il pourrait exister des architectures sur
lesquelles ces concepts sont confondus. Pour cette raison les exceptions
comme les interruptions seront consid\'er\'ees en tant que \textbf{trap}.

\paragraph{}

Une \textbf{trap} repr\'esentant une porte d'entr\'ee vers une t\^ache pour
les \'ev\`enements mat\'eriels, que ce soit un \'ev\`enement provenant
d'un p\'eriph\'erique comme du processeur.

\paragraph{}

La gestion de message inter-processus ne se base pas sur les traps
mais utilise un autre m\'ecanisme. Les traps sont exclusivement
r\'es\`erv\'ees \`a l'acheminement d'\`ev\`enement que nous
nommeront ``mat\'eriels''.

\paragraph{}

Il faut tout de m\^eme savoir que chaque \'ev\`enement mat\'eriel sera
transmis au handler sous forme de message. Lorsque vous ajouterez donc une
trap sur un tel \'ev\`enement, pensez que le thread qui sera r\'eveill\'e
devra \^etre capable de traiter un message en entr\'ee.

\paragraph{}

\hspace{1.5cm}int \textbf{trap\_init}(void);

\paragraph{}

Cette fonction initialise la gestion des traps.

\paragraph{}

\hspace{1.5cm}int \textbf{trap\_add}(t\_hwid \textbf{hwid},
                                     t\_thrid \textbf{thrid},
                                     t\_trapid \textbf{*trapid});

\paragraph{}

Cette fonction ajoute une trap qui d\'eclenchera l'ex\'ecution du thread
\textbf{thrid} lorsque l'\'ev\`ement \textbf{hwid} se manifestera.

\paragraph{}

Nous vous conseillons de faire en sorte qu'une fois la trap trait\'ee il
soit possible d'en recevoir une nouvelle. Ceci n'est qu'un conseil qu'il
faudra prendre en compte lors de l'\'elaboration du code de vos handlers
de messages.

\paragraph{}

Le param\`etre \textbf{hwid} peut sembler flou. En effet cet argument
repr\'esente un identifiant de ressource. Dans le cas d'Intel nous pouvons
imaginer que vos drivers vont interroger le controlleur PCI pour obtenir
l'IRQ correspondant \`a ce p\'eriph\'erique. Dans le cas d'Intel, cet
IRQ sera transmis en tant que \textbf{hwid} puisqu'il repr\'esente l'unique
identifiant de ressource disponible.

\paragraph{}

\hspace{1.5cm}int \textbf{trap\_modify}(t\_trapid \textbf{*trapid},
                               	        t\_thrid \textbf{thrid});

\paragraph{}

Cette fonction permet de modifier une trap d\'ej\`a enregistr\'ee.
Cette fonction met \'egalement \`a jour l'identifiant \textbf{trapid}.

\paragraph{}

\hspace{1.5cm}int \textbf{trap\_remove}(t\_trapid \textbf{trapid});

\paragraph{}

Permet d'effacer la trap du gestionnaire de traps.

\paragraph{}

\hspace{1.5cm}int \textbf{trap\_enable}(t\_trapid \textbf{trapid});

\paragraph{}

Permet d'activer la gestion de cette trap. \`A vous de d\'ecider si jamais
l'installation d'une trap l'active par d\'efaut.

\paragraph{}

\hspace{1.5cm}int \textbf{trap\_disable}(t\_trapid \textbf{trapid});

\paragraph{}

Permet de d\'esactiver la gestion de cette trap.

\paragraph{}

\hspace{1.5cm}int \textbf{trap\_clean}(void);

\paragraph{}

D\'etruit toute les traps enregistr\'ee.

--

\subsection{t\_thrid}

\paragraph{}

Ce type repr\'esente un identifiant de thread. La gestion des threads ne
sera faite que dans k4 mais il est indispensable d'utiliser ce type
d\`es maintenant.

\paragraph{}

L'utilisation de ce type est requis pour l'installation de trap. Pour des
raisons \'evidentes il ne vous sera pas possible d'installer de trap
tant que les threads ne seront pas g\'er\'ees, mais cela n'est pas important.

\begin{verbatim}
typedef u_int32_t       t_thrid;
\end{verbatim}

\subsection{t\_trapid}

\paragraph{}

Ce type repr\'esente un identifiant de trap.

\begin{verbatim}
typedef struct          s_trapid
{
  t_hwid                hwid;
  u_int32_t             id;
}                       t_trapid;
\end{verbatim}

