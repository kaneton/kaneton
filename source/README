##
## copyright quintard julien
## 
## kaneton
## 
## README
## 
## path          /home/mycure/kaneton
## 
## made by mycure
##         quintard julien   [quinta_j@epita.fr]
## 
## started on    Fri Feb 11 14:05:03 2005   mycure
## last update   Mon Jun 20 14:28:55 2005   mycure
##



			----------[ conf ]----------

a kaneton developer has to fill three configuration files located at:

			src/conf/$USER/

---[ $USER.conf

  this file describes the development environment, architecture variables
  compiling variables etc..

---[ modules.conf

  this file lists the files to be loaded by the bootloader.

---[ kaneton.conf

  this file describes the kaneton kernel with many parameters.



			----------[ env ]----------

a development environment describes binaries, compiling options,
linking options etc.. to use when developing kaneton.

a different environment exists for each operating system. for more information
take a look to the env/ directory.

each environment, directory is composed of three (but can be more) files:

---[ kaneton.mk

  this file describes the makefile dependencies to use to compile the
  kaneton kernel.

  so, you can here specify compile and linking options but also binaries
  to use. moreover you can decide how to compile, link, remove, display
  information in relating with the compile process.

---[ init

  this shell script is called by the init shell script located in the
  env/ directory. the goal of this script is to install operating system
  dependent files like kaneton.mk. moreover this script checks wheter
  the binaries required for the compile process.

---[ clean

  this shell script simply clears every installations made by the init
  shell script.



			----------[ make ]----------

first a developer has to install a development environment:

	make init

then he is able to compile:

	make kaneton

when finished, the developer then wants to test his kernel either on
another machine or in an emulator, so he has to build a floppy. before all,
he must initialize the boot device with the kaneton boot device format:

	make build

then the developer just has to install the kernel and modules on the boot
device:

	make install

after all, the boot device is ready.

---[ init

syntax:		make init

  this command will create the working environment like scripts, makefiles,
  dependencies etc..

  this script has to be ran before any another make.

  note that by default this command will be run if never launched before.

---[ clean

syntax:		make clean

  this command cleans the working environment, which is useful before
  committing or packaging.

---[ kaneton

syntax:		make kaneton

  this command will create the kernel, the modules etc..

---[ clear

syntax:		make clear

  this command will clear the development tree.

---[ proto

syntax:		make proto

  this command will create header prototypes.

---[ dep

syntax:		make dep

  this command will generate every C file dependencies.

---[ build

syntax:		make build

  this command will create an initial bootable device.

---[ install

syntax:		make install

  this command copies the kernel and modules on the bootable device.

---[ check

syntax:		make check

  this command runs tests to validate the current kaneton version.

---[ info

syntax:		make info

  this command displays information about the kaneton project.

---[ distrib

syntax:		make distrib

  this command builds a kaneton tarball ready to be evaluated.



			----------[ makefiles ]----------

a portable makefiles system is provided for the kaneton project. each
makefile of the project uses either functions defined in the kaneton.mk
makefile dependency located in the directory env/{operating system}/kaneton.mk
or directly defined commands like $(_MAKE_) or $(_CD_) etc..

this system leads to a central system, so to simpler portability.

this system uses few functions explained below.

for more informations, take a look at a kaneton.mk makefile dependency.

the syntax used to call a function in a makefile is:

	$(call thisfunctionisinteresting,argument1,argument2,argument3)

---[ pretty-printer

  this function is used to pretty print a message. any action performed
  by a makefile is displayed, so this function is called.

  arguments:

    1:		the color used to display the action name
    2:		the name of the action performed
    3:		the file on which the action is performed
    4:		the identation between the action name and the file name

---[ compile-c

  this function is used to compiler a C file to produce an object file.

  arguments:

    1:		the object file name
    2:		the C file name
    3:		advanced options like additional C flags

---[ compile-S

  this function is used to compile a S file to produce an object file.

  arguments:

    1:		the object file name
    2:		the S file name
    3:		advanced options

---[ compile-asm

  this function is used to compile a asm file to produce an object file.

  arguments:

    1:		the object file name
    2:		the asm file name
    3:		advanced options

---[ archive

  this function is used to group object files into one archive.

  arguments:

    1:		the archive file name
    2:		the object file names
    3:		advanced options

---[ archives

  this function is used to build an archive from different archives.

  arguments:

    1:		the archive file name
    2:		the archive file names
    3:		advanced options

---[ static-linker

  this function is used to call the static linker, so to build a
  static library from an archive.

  arguments:

    1:		the archive file name
    2:		advanced options

---[ dynamic-linker

  this function is used to call the dynamic linker, so to build dynamic
  libraries or binaries.

  arguments:

    1:		library file name
    2:		objects and/or archives and/or libraries file names
    3:		advanced options

---[ remove

  this function is called to remove files.

  arguments:

    1:		the file names
    2:		advanced options

---[ purge

  this function is used to clean the current directory from useless files
  like emacs backups (~ files) etc..

  no argument

---[ prototypes

  this function is called to build prototypes in header files.

  arguments:

    1:		the header file name
    2:		advanced options

---[ dependencies

  this function generates makefile rules for C files dependencies. this
  is especially useful for header file dependencies.

  arguments:

    1:		the files for which the dependencies have to be generated
    2:		the output file which will contain makefile rules
    3:		advanced options

---[ version

  this function generates a version file containing a string describing
  the kernel version: date, user, host machine, title, version etc..

  argument:

    1:		the version file to generate

---[ link

  this function build a symbolic link to a file.

  arguments:

    1:		the file name to create so the symbolic link
    2:		the destination file name
    3:		advanced options



			----------[ types ]----------

the types used in the kaneton project follow precise rules defined below.

using these rules leads to a very clear source code. indeed, it is now
very easy to know what a variable is with its type.

---[ structures

  the structures are declared with the prefix 's_'.

---[ basic/general

  the basic/general types are defined using the prefix 't_'.

---[ managers

  the structures used to describe a manager use the prefix 'm_'.

---[ objects

  the object types are declared using the prefix 'o_'.

---[ capabilities

  the capability types are defined with the prefix 'c_'.

---[ interfaces

  the interface types are declared with the prefix 'i_'.

---[ machine-dependent

  the machine-dependent types use the prefix 'd_'.



			----------[ defines ]----------

the kaneton kernel uses few fundamental defines listed below:

---[ ___bootloader

  indicates that we are currently compiling the bootloader.

---[ ___kernel

  indicates that we are currently compiling the kernel

---[ ___kaneton

  indicates that this program was compiled for the kaneton kernel.

---[ ___wordsz

  indicates that this program was compiled to run on a ___wordsz
  value processor.

---[ ___endian

  indicates that this program was compiled to run on a ___endian value
  processor.



			----------[ coding style ]----------

the kaneton project developers try to follow a coding style. this
coding style was introduced to normalize the source code, leading to
a more readable source code.

nevertheless, you can adapt this coding style to your own but try
to follow the rules.

---[ low case

  the entire source code is written using low case. moreover the comments
  are also written using low case.

---[ function returns

  a function must return zero if there is no error, otherwise return minus one.
  an error code can be returned to specify a precise error.

---[ headers

  please use this header for all the files you want to edit.

	/*
	 * copyright quintard julien
	 * 
	 * kaneton
	 * 
	 * kaneton.c
	 * 
	 * path          /home/mycure/kaneton/core/kaneton
	 * 
	 * made by mycure
	 *         quintard julien   [quinta_j@epita.fr]
	 * 
	 * started on    Fri Feb 11 14:05:03 2005   mycure
	 * last update   Sun Jun 19 01:02:32 2005   mycure
	 */

---[ types

  try to use the kaneton types: t_uint8, t_sint16, t_uint64 etc..
  rather than unsigned char or unsigned long long int.

---[ comments

  the comments must have this specific form:

	/*
	 * a comment
	 */

  or on multi-lines:

	/*
	 * a comment on line one
	 * a comment on line two
	 * a comment on line three
	 */

---[ includes

  the kaneton kernel was developed in a way that permits programmers
  to only have to include two files: libc.h for the C library and
  kaneton.h for the operating system headers.

	#include <libc.h>
	#include <kaneton.h>

	int		main(int		argc,
			     char**		argv)
	{
	  /*
	   * your code here
	   */

	  return (0);
	}

---[ indentation

  the indentation used in kaneton is the one shown bellow:

	#include <libc.h>

	struct		s_mystruct
	{
	  int		value;
	};

	typedef s_mystruct		t_mytype;

	#define DEBUG			1

	#ifdef DEBUG
	t_uint8			flag = 0;
	#endif

	extern int		errno;

	int			function(int			arg1,
					 char			arg2,
					 void*			arg3)
	{
	  t_mytype		myvar;

	  if (arg1 == 0)
	    {
	      function(0, '0', NULL);
	    }

	  return (-1);
	}

---[ variable names

  few rules must be followed.

  every variable representing a size use the 'sz' suffix.

	#define PAGESZ

	int			modsz;

  every variable representing a number of objects use the 'n' prefix:

	int			nclusters;

  moreover, the types are used as pre-names:

	t_vaddr			video_vaddr;

  is not correct, instead prefer:

	t_vaddr			video;

---[ names

  names for functions, structures, types, variables etc.. must be choose
  carefully. first the names must be in english and in lower case.

  every function name must be prefixed by its module, manager, in other
  words by its context name or its name space.
  for example every function for the console driver are prefixed by 'cons_':
  cons_init(), cons_print_char(), etc..

---[ comments

  to keep the code clear while commenting each part of functions, we
  advise you to use this form:

	/*
	 * description of the function in few lines.
	 *
	 * steps:
	 *
	 * 1) first the function does that.
	 * 2) then it does another thing.
	 * 3) after, ...
	 * 4) finally, it does nothing.
	 */

  also try to cut the includes into parts like: dependencies, includes,
  defines, types, prototypes etc..

	/*
	 * dependencies
	 */

	#include <...>

	/*
	 * includes
	 */

	#include <...>
	#include <...>

	/*
	 * defines
	 */

	#define ...

	/*
	 * types
	 */

	typedef ...;

	/*
	 * prototypes:             ../../directory/file1.c
	 *                         ../../directory/file2.c
	 */

	/*
	 * eop
	 */

---[ prototypes

  note that the prototypes are generated using the command: 'make proto'.
  all you have to write these lines:

	/*
	 * prototypes:             path/to/file1
	 *                         path/to/file2
	 */

	/*
	 * eop
	 */

  and the command 'make proto' will generate prototypes from the C files
  and insert them between the two tags: prototypes and eop.

---[ redefinition

  the includes files contain anti-redifinition defines.

	#ifndef KANETON_INIT_H
	#define KANETON_INIT_H

	/*
	 * your code here
	 */

	#endif

  please respect this rule: always compose the name of the anti-redefinition
  using the path from the include directory.

			----------[ evaluation ]----------

the kaneton project will be automatically evaluated.

please set the mode RELEASE to indicate that we can evaluate your project.

the user configuration used to evaluate your project is 'eval'.

---[ sections

  each file including header files, source files and makefiles are divided
  into sections.

  for example header files contain info, dependencies, defines, types,
  prototypes, macros etc.. sections.

  source files contain globals, includes, functions etc.. sections.

  makefiles contain dependencies, directives, variables, rules etc.. sections.

  try to respect the syntax used to divide files into sections, for example
  for source files:

	/*
	 * ---------- includes ------------------------------------------------
	 */
