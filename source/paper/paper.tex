%%
%% copyright quintard julien
%% 
%% v3-design
%% 
%% v3-design.tex
%% 
%% path          /home/mycure/data/research/projects/spargo/specifications/paper
%% 
%% made by mycure
%%         quintard julien   [quinta_j@epita.fr]
%% 
%% started on    Fri Feb  4 15:10:05 2005   mycure
%% last update   Thu May 19 08:48:40 2005   mycure
%%

\documentclass[10pt,a4wide]{article}
\usepackage[english]{babel}
\usepackage{a4wide}
\usepackage{graphicx}
\usepackage{fancyheadings}
\usepackage{multicol}
\pagestyle{fancy}
\setlength{\footrulewidth}{0.3pt}

\bibliographystyle{plain}

\lhead{\scriptsize{The Spargo Distributed Operating System}}
\rhead{\scriptsize{Specifications}}
\rfoot{\scriptsize{EPITA System Laboratory}}

\title{The Spargo Distributed Operating System Specifications}

\author{\small{Julien Quintard} \\
        \scriptsize{Epita System Laboratory, Paris, France}}

\date{\scriptsize{\today}}

\begin{document}

\maketitle

\begin{abstract}

This paper describes the design of the Spargo distributed operating system.
This system was designed to be ported on many architectures without being
intrusive. Moreover, the main goal of this system was to design a powerful
system able to adapt itself on a network constantly in evolution and to
provide a transparent and easy way to migrate processes, communicate
with system's entities and to be fault tolerant. This paper is composed of
two parts, the first describing the microkernel concepts and components,
the latter describing the distributed operating system algorithms.

\end{abstract}

\paragraph{}
\paragraph{}



\begin{multicols}{2}



\section{The Spargo History}

\paragraph{}

Spargo originated at the EPITA System Laboratory as a research project
in operating systems. Having recently developed a nano-kernel, the laboratory
decided to begin the design and development of an operating system with
a more powerful design and able to share ressources on a large network.
Nevertheless, the goal of the first release is to develop an operational
prototype running on a dozen of computers.

\paragraph{}

The project was designed primarly by two students, Julien Quintard and
Jean-Pascal Billaud although many other people also contributed to the
design and will especially contribute to the implementation.
The development of the project is now ready to start and the first release
is announced for the end of the year.



\section{The Spargo Goals}

\paragraph{}

Many research projects in distributed systems started with an existing system.
For the Spargo distributed operating system, we decided to totally design a
new system. Nevertheless, the EPITA system laboratory previously developed a
nano-kernel under the supervisation of Vianney Rancurel. This system had
powerful features and was able to run UNIX programs due to the development of
a UNIX-emulation library. This system, having reached an interesting state,
was not designed to be portable enough, so we decided to work on a new
core design rather than modify the LSE/OS kernel.

\paragraph{}

It was obvious that to avoid the work of having to rewrite a huge amount
of application softwares, a UNIX emulation library will be added later.
Indeed, some of the good ideas of the LSE/OS nano-kernel have been
reintroduced with little changes or rethinking.

\paragraph{}

The primary goal of the Spargo operating system was to design a distributed
operating system but to be totally transparent from the user point of view.
Moreover, a special interest was made on scalable networks, especially
to manage the distributed system nodes neither in a totally centralized way
nor in a totally distributed way but rather in a more moldable way where groups
constantly evolve in size. Another goal was to provide an abstraction to
communications in the distributed system. In addition, the Spargo distributed
operating system will provide a transparent and easy way to migrate processes
on the network, to manage distributed memory while being fault tolerant.

\paragraph{}

The Spargo operating system was first developed to looks like a typical
timesharing system to the user. Nevertheless, Spargo was also designed to
become a very scalable system and to provide a powerful system for
parallel programming.



\section{The Spargo Architecture}

\paragraph{}

Before describing the Spargo microkernel internals or the Spargo distributed
operating system, it is useful first to outline the kind of hardware for
which the system was designed.

\paragraph{}

The Spargo microkernel has been designed to deal with multiple architectures
and heterogeneous systems. It was designed with two main requirements about the
hardware:

\begin{enumerate}

\item Virtual memory is needed by the microkernel.

\item Each CPU must have about tens of megabytes of memory.

\end{enumerate}

The Spargo microkernel can be ported on any architecture which respects these
requirements.



\section{The Spargo Microkernel}

\paragraph{}

The Spargo operating system is composed of two parts: a \textbf{microkernel}
which runs on every processor machine of the system and a collection of
\textbf{servers} that provide most of traditional operating system
functionalities: drivers, file servers etc..

\paragraph{}

We will see later that the term \textbf{server} is not used in the Spargo
documentation. Instead the terms: driver, service etc.. will be used.

\paragraph{}

The Spargo microkernel runs on every machine of the system including
workstations, the pool processors, specialized servers etc.. The microkernel
has four primary functionalities to provide:

\begin{enumerate}

\item Communication

\item Memory management

\item Process management

\item I/O

\end{enumerate}

\paragraph{}

We will now describe microkernel's components to understand how the Spargo
microkernel provides communication, memory management, process management etc..

\subsection{Objects And Protections}

\paragraph{}

To protect objects on the system, the Spargo distributed operating system uses
capabilities.

\paragraph{}

A \textbf{capability} provides an easy way to allow other tasks of the
system to access a privileged object.

\paragraph{}

To illustrate this concept, consider a program which allocate a segment of
physical memory. Then it decides to allow another program to only read
this segment. Then it will generate a less privileged capability and give
it to the other program. After all, the second program will be able to read
the segment but not to write it.

\paragraph{}

A common capability includes the object identifier, the permissions of the
capability on the object, listing allowed operations, a check field assuring
security and other specific fields like for example the location of the
service, a lifetime etc..

\paragraph{}

Unlike many distributed systems, the Spargo microkernel uses specific and
specialized capabilites to increase scalability.

\paragraph{}

Consider a modern file system with billions of inodes; this file system
certainly wants to build capabilities with a 64-bit identifier.
We can now consider another service, for example a printer service, listing
every printer of the system. This service certainly wants to use 16-bit
identifier in its capabilities because there will certainly never be more than
65000 printers on this system. Each service is different so each service
will want to use its own capability's format.

\paragraph{}

The use of specific and specialized capabilites forces the programs to ask
the services to build new capabilites, unlike other systems. Indeed,
the other systems generally use generic capabilites to permit programs to
generate capabilities by themselves. This was not our choice and the result is
more scalable capabilites but a performance loss in capability generation.

\paragraph{}

Moreover, using this scheme permit services to use the cryptographic algorithm
they want.

\paragraph{}

Note that the capability generation does not often happen. Moreover,
a capability can be generated and used by many other programs because
capabilites are generally used to restrict permissions. A capability
is not unique to its user, so a program can generate a capability and
distribute it to many other programs giving them the same permissions.

\paragraph{}

To conclude, this system is performant in a normal use but can become
slow if a program has to generate many different capabilities, this case
being rare.

\paragraph{}

The use of specific capabilities allows services to create capabilities,
for example, without identifier or with extra permission fields.

\paragraph{}

Nevertheless a capability has to protect operations from malicious programs
trying to generate correct capabilites. For this reason, the check field is
highly recommended.

\paragraph{}

Note that the use of the check field does not garantee security on a
distributed system. For this reason, the Spargo distributed operating
system can evolve with three security policy:

\begin{enumerate}

\item \textbf{No security}: with this policy, the security fields of the
      capabilities are not used. No cryptography is used on the system
      to garantee security.

\item \textbf{Local security}: with it, the capabilities are protected from
      malicious programs and users using the check field. So, while there
      is no network message passing of capabilites, the system can be
      considered as safe.

\item \textbf{Global security}: with this security policy, the distributed
      operating system is safe. Every capability is protected with its check
      field but in addition each message on the network is protected by
      cryptographic algorithms.

\end{enumerate}

\subsection{Communication}

\paragraph{}

The Spargo microkernel and more generally the Spargo distributed operating
system uses messages to communicate with everything.

\paragraph{}

A key concept behind the Spargo microkernel is precisly the use of messages
to communicate with everything including, tasks, groups, nodes etc..
The communication unification is one of the choice that many other distributed
operating systems do not make. Instead, many systems uses RPC as the key
mechanism for communication between machines.

\paragraph{}

The RPC system deals with many problems like memory references from which the
RPC system does not know the size. These problems are very difficult to
resolve and implies many complex mechanisms to install while being performant.

\paragraph{}

A distributed operating system communicates with other nodes of the system in
a very strict way, dealing with a protocol. So the RPC system seemed to be very
complex for our requirements. We decided to not base our system on it and
instead, to use a simple unified message mechanism. Nevertheless, the RPC
system will be allowed but for the userland applications.

\paragraph{}

To unify communications via messages, the microkernel translates every event
into a message. For example, when an interrupt is received by the kernel
interrupt handler, a message is built and forwarded to the server dedicated
to this interrupt. So, each server just has to take care of how to receive
messages and how to reply them.

\paragraph{}

Note that no group communication is provided by the microkernel. Indeed, the
group communication concept is inherent to the distributed oeprating system.
The group communication is explained later in this paper.

\paragraph{}

The microkernel includes an authentification mechanism to protect tasks from
sending messages everywhere they want to. To communicate with another task
which will commonly be a server, the client has to ask a capability to
the authentification server. Then the client will be allowed to send messages
to the server. The authentification server is described later in this paper.

\subsection{Memory}

\paragraph{}

The memory model of the Spargo microkernel is very simple. Each address space
of the system is composed of segments and regions.

\paragraph{}

A \textbf{segment} consists of a linear sequence of physical addresses.
A segment describes one area of physical memory including the
first address, the last but also some properties like the owner of this
segment, the permissions: execution, read, write etc.. and some
extra attributes. Segments can be accessed via mappings or directly with
the functions \textbf{seg\_read}(), \textbf{seg\_write}() and
\textbf{seg\_copy}(). Each segment is identified by an unique identifier
and manipulated with a capability.

\paragraph{}

A \textbf{region} consists of a linear sequence of virtual addresses.
A region has no properties and is only used to map a valid segment.
Using a region in the virtual memory will reference the segment's data
it maps.

\paragraph{}

An \textbf{address space} is a list of memory locations. In the Spargo
microkernel, an address space includes the list of the segments and regions.
So an address space describes the available process' memory. An address space
is identified by its unique identifier and manipulated with a capability.

\paragraph{}

Like all the system, the Spargo memory model is based on little objects which
are linked to build more complex objects. An address space is composed
of segments and regions. This model implies that a program is allow to
manages its entire memory itself, its physical memory like its virtual one.

\paragraph{}

This design leads to very interesting features and more parallelism.
The kernel is now able to create a dozen of address spaces, and then to
insert into them segments and regions. Moreover it is now possible to allocate
segments and to migrate them to another address space without effort. This
memory model also permits to easily recycle data structures because each one
is independent from others.

\subsection{Set}

\paragraph{}

The Spargo microkernel internally uses a set manager which organizes data
for other kernel managers. Each set is identified by an unique identifier.

\paragraph{}

Using this manager leads to a very elegant and maintenable source code. From
this fact, every kernel manager uses the set manager to store its data. For
example the task manager uses the set manager to store every task of the
system. Additionnaly, each task contains a set composed of the threads of
this task.

\paragraph{}

Such a system provides an easy way to store data without effort. From this
fact, the task manager for example do not care about how to store data.

\paragraph{}

Moreover, it is possible to optimize the code where it is needed. In this
case, it will be useful to optimize the data structures in the set manager
and \textit{not} in every manager using such a data structure like
other systems do.

\paragraph{}

Indeed, the other operating systems generally use pointers to link kernel
structures together and implicitly form sets. Nevertheless, such a source code
is human unreadable and leads to many programming confusions and errors.

\paragraph{}

The set manager provides many different data structures like linked-list,
double linked-list, circular queue, stack, pipe, array, binary tree, b+-tree
etc..

\paragraph{}

In this way, every kernel manager is now able to use the set manager to
store its data. The set manager also provides tools like \textbf{iterators}
to easily and quickly go through sets.

\subsection{Process}

\paragraph{}

The Spargo microkernel uses a specific nomenclature which is different
from other oeprating systems.

\paragraph{}

The system is composed of five different entities in relation with execution.

\paragraph{}

A \textbf{module} represents an passive execution entity in main memory.
Indeed, a module does not run and has no execution context. The modules are
managed by the module service to reside in main memory the time it is
necessary. For example a very used program like \textbf{/bin/ls} certainly
becomes an important module due of its use. Fundamental system's drivers
and services are persistent modules because they will be used in the case
of a crash to restart the crashed service without any dependency.
A module is identified by an unique identifier and manipulated with a
capability.

\paragraph{}

A \textbf{user} task is the lowest privileged task on the system.
The common user programs are the well-known UNIX{\scriptsize \copyright}
programs like \textbf{/bin/ls}, \textbf{/bin/wc}, \textbf{/usr/bin/cc} etc..
A user task is a task with no privilege. All it can do is compute some things,
manage data and send messages to more privileged processes.

\paragraph{}

A \textbf{service} is a server which provides a so-called service. A service
waits for messages, perform a task, and return the result of the service.

\paragraph{}

A \textbf{driver} is a service which can communicate with hardware devices.
So, the I/O operations are reserved to tasks which are at least a driver.

\paragraph{}

Finally, a \textbf{kernel} is a kind of super-driver in which it provides
many services while communicating with hardware devices. Moreover, it is
the only task able to modify every system's internal data structure.

\paragraph{}

Every task can only be called by less or equal privileged tasks.

\paragraph{}

The Spargo microkernel does not have processes in the
UNIX{\scriptsize \copyright} terms. Indeed, the Spargo microkernel manage tasks.
A \textbf{task} is a non-active entity because a task is never scheduled.
A task, in the Spargo terms, is a container which describes an executive
environment, context. Each task has an address space describing its useable
memory and one or more threads. A task with only an address space and one
thread is essentially identical to a UNIX{\scriptsize \copyright} process.
The term \textbf{process} will sometimes be used in this paper to describe
a Spargo task.

\paragraph{}

Each task of the Spargo system is manipulated with a capability including
its unique identifier.

\paragraph{}

The consequence of this scheme is a huge parallelism for the
task creation and more generally in all operations in relation with
a task or a subpart of tasks. For example, the kernel can create all
address spaces, then all threads and at the end link them to tasks before
running them. Moreover, this scheme facilitates the recycling of data
structures: task, thread, address space, etc.. Indeed, it is now possible to
unlink, for example, an address space either to release it or to link it to
another task.

\paragraph{}

A \textbf{thread} is the active entity because it is this one which is
scheduled. Such a thread has a single address space, belongs to a single
task, has a set of registers, a program counter and finally a stack.
Needless to say that the Spargo microkernel handles threads as kernel threads.
Each thread has an unique identifier and is manipulated by a capability.

\paragraph{}

Like address spaces and many other parts of the system, a more complex
object is created by linking simpler one. The process of task creation
it listed below:

\begin{enumerate}

\item a task structure is reserved

\item an address space is linked to the task

\item one or more threads are linked to the task

\end{enumerate}

\paragraph{}

Each task has three important properties: a class, a behaviour and a priority.

\paragraph{}

The \textbf{class} is chosen at the task creation time. This property
informs the kernel about the nature of the task, its role on the system.
In addition, this class will implicitly determine the rights of the task
on the system. The different classes are \textit{kernel}, \textit{driver},
\textit{service}, \textit{user}. On many architectures, the kernel, driver
and service classes will have the same system priority. Nevertheless few
architectures provides different system privileges.

\paragraph{}

The \textbf{behaviour} specifies the kernel the type of the task from the
scheduler point of view. The different values for the behaviour are
\textit{kernel}, \textit{realtime}, \textit{interactive}, \textit{timesharing},
\textit{backgroud}. Each behaviour defines a range of priorities for the
task.

\paragraph{}

The \textbf{priority} is a value included in the range defined by the
task behaviour. Any thread of a task can update the priority of its
task in this range modifying the task priority from the scheduler point of view.

\paragraph{}

With these properties, a user can create a task very reactive setting an
appropriate behaviour and then update its priority to adjust its quantum.
This mechanism gives the programs many possibilities and permits them to
choose its execution context.

\paragraph{}

The threads also have an important property: a priority.

\paragraph{}

Each thread of a task can set its own priority in the range \textbf{[10, 250[}.
From this fact, a thread can set itself an higher priority than the other
threads of its task. The resulting effect is a thread having a longer quantum.
Once again, this mechanism give more liberty to the programs.

\subsection{Processor}

\paragraph{}

The processor manager also and commonly called cpu manager provides a small
set of primitives to manages the processors on which a task run.

\paragraph{}

Each thread of the system has the possibility of choosing the processors
on which they want to be run or more precisly the processors which are allowed
to run this thread.

\paragraph{}

This feature was directly imported from Mach [XXX]. Indeed this mechanism
provides the threads of a task the possibility of settle, distribute
the processors in the best way for the program execution on multiprocessors.
The scheduling is done using priorities, so the programmer has fine-grain
control over which threads are most important and which are least important.

\paragraph{}

Each processor of each machine has an unique identifier and is manipulated
with a capability.

\subsection{Servers}

\paragraph{}

Let's talk about the most important servers of the Spargo microkernel.

\subsubsection{Module}

\paragraph{}

The module service keep track of the current modules.

\paragraph{}

With each module is associated a \textbf{lifetime} specifying module's
importance. With it, the module service will be able to release certain
modules due to their uselessness. Nevertheless, few modules have a
unlimited lifetime due to their fundamental use. For example the module
corresponding to the IDE driver binary will always reside in the module
service's main memory to be re-launched if the current IDE driver crashes.
This mechanism provides an easy way to lauch fundamental servers independlty
of others.

\paragraph{}

Due to this mechanism, the programs have to ask the module service to load
a binary into their address spaces. Notice that from this fact, the module
service role is also to bind server's name to modules' identifier. By this
the kernel \textit{never} handles strings in its core source code, resulting
in a simpler source code.

\paragraph{}

The module service is divided into two parts. The first one called \textbf{mod}
manages modules, lifetime and loads the module into address spaces when needed.
The other part called \textbf{modfs} is a main memory file system listing
current modules managed by the module manager.

\paragraph{}

When a program asks the module service to load a module into its address
space, the module manager just reserve a region into the program's address
space mapping the shared segment corresponding to the module's binary in
main memory.

\subsubsection{Name}

\paragraph{}

The name service \textbf{ns} provides few primitives to locate services
either on the local machine or on the network.

\paragraph{}

Indeed, the name service is composed of two parts, the centralized name
service \textbf{cns} which is used to locate drivers, services etc.. on
the local machine and the distributed name service \textbf{dns} which is
used to locate nodes, groups, etc.. on the distributed operating system.
The distributed name service and more precisly the name group will be
explained later in the paper.

\paragraph{}

The name service was introduced to provide dynamic service execution, allowing
concurrency. Indeed, the name service can decide to dispatch the work between
few identical services. Moreover, the concurrency is allowed and a client
can ask the name service to locate a precise service.

\subsubsection{Authentification}

\paragraph{}

The \textbf{auth} service checks if two tasks are allowed to communicate.

\paragraph{}

When a task wants to send a message to another one, it first has to ask
the authentification service a capability allowing it to send messages. Then,
when sending a message, the kernel will check the capability's validity.
For example, the IDE driver should only receive messages from the file systems.
A user application trying to forge an illegal message will be refused.

\paragraph{}

Moreover, the authentification service will establish a blacklist listing
malicious programs and/or users, preventing system saturation or other
problems.

\subsubsection{Shared Memory}

\paragraph{}

The shared memory service commonly called the \textbf{sm} service is used
to shared segments with other address space.

\paragraph{}

The shared memory manager is composed of two subparts, the centralized
shared memory \textbf{csm} and the distributed shared memory \textbf{dsm}.
Each one manages shared memory in its context either on the local system
or on the global distributed system.

\paragraph{}

Using the shared memory manager ensures that the memory will not be release
if one or more programs are using it.

\paragraph{}

The distributed shared memory service is used to share memory with
programs on the network. Moreover, it provides a way to reserve huge amount
of memory even if not available on the host machine. The distributed shared
memory group will be explained later in this paper.

\subsection{Conclusion}

\paragraph{}

The Spargo microkernel uses a simple paradigm which allow programmers to
manage memory and execution context as they wanted to. A special interest
was ported on the parallel programming providing complete primitives to
manage priorities on many levels: thread, task and processor.

\paragraph{}

To conclude, the Spargo microkernel allows programs to manage their objects
themselves to scale little by little to a better ressources distribution.

\end{multicols}

\end{document}

--

XXX cauth et dauth -> revoir cela
XXX dauth fera les droits entre les nodes. ensuite un message qui arrive
XXX de l exterieur est considere comme un programme user mais etant identifie
XXX comme venant de l ext. bien dissocier les differents noeuds ext sinon un
XXX mec qui fout la merde et hop plus personne n a le droit de send de msg.

\section{The Distributed Operating System}

\paragraph{}

The Spargo distributed operating system is based on the concept of scalable groups.

XXX

XXX le groupe de memoire distribuee permet egalement de reserver bcp de memoire.
XXX le groupe se charge meme si il faut de reserver sur differentes machines
XXX et de ensuite faire mapper ce qu il faut au client.

--

---[ il me reste a concevoir:

-- microkernel

3) integrer le gestionnaire de cpu avec une interface sched plus complete
   gerant le scheduler pour que les threads puissent choisir de s executer
   sur tel ou tel processeur reserve. (bien entendu lorsque l on reservera
   N processeurs, il est clair que ces N processeurs doivent se trouver sur
   un meme machine sinon ca n a pas de sens de scheduler le thread t0 sur la
   machine m9 et le thread t1 sur la machine m2)

4) revoir les processus pour que ce soit coherent

-- distributed operating system

5) synchronization du temps: clock, mutex, transactions, deadlocks

6) etablir la couche de transport

7) gestion des messages (trouver un nom au systeme de message car IPC
   et RPC ca va pas: GEC: generic entity communication?, ne pas utiliser
   le P pour process car pas de process dans spargo): unicast, multicast
   broadcast, Point-to-Point, Group

8) pool de processeurs

--

XXX tableau recapitulatif et comparatif avec les autres kernel
